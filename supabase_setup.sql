-- Drop existing notes table if it exists
drop table if exists notes;

-- Create new notes table with JSON data column
create table notes (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  data jsonb not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Set up RLS (Row Level Security)
alter table notes enable row level security;

-- Create policy to allow users to only see their own notes
create policy "Users can only access their own notes"
  on notes for all
  using (auth.uid() = user_id);

-- Create habits table to store JSON data
create table habits (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  data jsonb not null default '{}'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id)
);

-- Enable RLS
alter table habits enable row level security;

-- Create policies
create policy "Users can view their own habits"
  on habits for select
  using ( auth.uid() = user_id );

create policy "Users can insert their own habits"
  on habits for insert
  with check ( auth.uid() = user_id );

create policy "Users can update their own habits"
  on habits for update
  using ( auth.uid() = user_id );

-- Create reading table to store JSON data
create table reading (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  data jsonb not null default '{}'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id)
);

-- Enable RLS
alter table reading enable row level security;

-- Create policies
create policy "Users can view their own reading data"
  on reading for select
  using ( auth.uid() = user_id );

create policy "Users can insert their own reading data"
  on reading for insert
  with check ( auth.uid() = user_id );

create policy "Users can update their own reading data"
  on reading for update
  using ( auth.uid() = user_id );

-- Create new user_settings table for storing user Gemini API settings
drop table if exists user_settings;

create table user_settings (
  user_id uuid references auth.users not null primary key,
  api_key text not null,
  firecrawl_api_key text not null,
  model text not null,
  preferences jsonb default '{}'::jsonb, -- Stores user-specific UI and feature preferences
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add comment for the preferences column
comment on column public.user_settings.preferences is 'Stores user-specific UI and feature preferences as a JSON object.';

-- Enable RLS (Row Level Security) for user_settings
alter table user_settings enable row level security;

-- Create policy to allow users to view their own settings
create policy "Users can view their own settings"
  on user_settings for select
  using ( auth.uid() = user_id );

-- Create policy to allow users to insert their own settings
create policy "Users can insert their own settings"
  on user_settings for insert
  with check ( auth.uid() = user_id );

-- Create policy to allow users to update their own settings
create policy "Users can update their own settings"
  on user_settings for update
  using ( auth.uid() = user_id );

-- Create policy to allow users to delete their own settings
create policy "Users can delete their own settings"
  on user_settings for delete
  using ( auth.uid() = user_id );

-- Add flashcards table for the flashcards app

-- Drop the existing flashcards table if it exists
drop table if exists flashcards;

-- Drop existing book_lists table if it exists
drop table if exists book_lists;

-- Create book_lists table
create table book_lists (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  name text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, name) -- Ensure list names are unique per user
);

-- Enable RLS on book_lists table
alter table book_lists enable row level security;

-- RLS Policies for book_lists
create policy "Users can view their own book lists"
  on book_lists for select
  using ( auth.uid() = user_id );

create policy "Users can insert their own book lists"
  on book_lists for insert
  with check ( auth.uid() = user_id );

create policy "Users can update their own book lists"
  on book_lists for update
  using ( auth.uid() = user_id );

create policy "Users can delete their own book lists"
  on book_lists for delete
  using ( auth.uid() = user_id );

-- Create e-books table for the ebook reader app
drop table if exists ebooks;

create table ebooks (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  title text not null,
  author text,
  file_type text not null,
  content text,
  metadata jsonb not null default '{}'::jsonb,
  last_position jsonb not null default '{"chapter": 0, "scroll": 0}'::jsonb,
  list_id bigint references book_lists(id) on delete set null, -- Link to book_lists, set null if list is deleted
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, list_id, title) -- Ensure book titles are unique within a list for a user
);

-- Enable RLS on ebooks table
alter table ebooks enable row level security;

-- Create policy to allow users to view their own ebooks
create policy "Users can view their own ebooks"
  on ebooks for select
  using ( auth.uid() = user_id );

-- Create policy to allow users to insert their own ebooks
create policy "Users can insert their own ebooks"
  on ebooks for insert
  with check ( auth.uid() = user_id );

-- Create policy to allow users to update their own ebooks
create policy "Users can update their own ebooks"
  on ebooks for update
  using ( auth.uid() = user_id );

-- Create policy to allow users to delete their own ebooks
create policy "Users can delete their own ebooks"
  on ebooks for delete
  using ( auth.uid() = user_id );

-- Add index for list_id on ebooks table
create index idx_ebooks_user_list on ebooks(user_id, list_id);

-- Create flashcards table to store flashcard data for the flashcards app
create table flashcards (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  word text not null,
  phrase text not null, -- "This is a phrase with <b> word </b> in side it, in bold.", real example : """The <b>ambassador</b> represents their country's interests in a foreign nation."""
  translation_answer text not null, -- "vietnamese\nMeaning phrase"
  review_count integer not null default 0,
  last_reviewed timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, word),
  state text,
  due timestamp with time zone,
  stability double precision,
  difficulty double precision,
  elapsed_days double precision,
  scheduled_days double precision,
  reps integer,
  lapses integer,
  ipa text,
  word_audio text,
  phrase_audio text
);

-- Enable RLS on flashcards table
alter table flashcards enable row level security;

-- Create policy to allow users to view their own flashcards
create policy "Users can view their own flashcards"
  on flashcards for select
  using ( auth.uid() = user_id );

-- Create policy to allow users to insert their own flashcards
create policy "Users can insert their own flashcards"
  on flashcards for insert
  with check ( auth.uid() = user_id );

-- Create policy to allow users to update their own flashcards
create policy "Users can update their own flashcards"
  on flashcards for update
  using ( auth.uid() = user_id );

-- Create policy to allow users to delete their own flashcards
create policy "Users can delete their own flashcards"
  on flashcards for delete
  using ( auth.uid() = user_id );

-- Set default values for existing rows
update flashcards
set 
  state = 'New',
  due = now(),
  stability = 0,
  difficulty = 0,
  elapsed_days = 0,
  scheduled_days = 0,
  reps = 0,
  lapses = 0
where state is null;

-- Create time_tracking table for the Time Tracker app

-- Create the time_tracking table for daily activity totals
CREATE TABLE time_tracking (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_id TEXT NOT NULL,
  activity_name TEXT NOT NULL,
  total_seconds INTEGER NOT NULL DEFAULT 0,
  date DATE NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Create a unique constraint to ensure we only have one entry per user/activity/date
  UNIQUE(user_id, activity_id, date)
);

-- Add RLS (Row Level Security) policies to time_tracking table
ALTER TABLE time_tracking ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only view their own time tracking data
CREATE POLICY "Users can view their own time tracking data"
  ON time_tracking
  FOR SELECT
  USING (auth.uid() = user_id);

-- Policy: Users can only insert their own time tracking data
CREATE POLICY "Users can insert their own time tracking data"
  ON time_tracking
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can only update their own time tracking data
CREATE POLICY "Users can update their own time tracking data"
  ON time_tracking
  FOR UPDATE
  USING (auth.uid() = user_id);

-- Policy: Users can only delete their own time tracking data
CREATE POLICY "Users can delete their own time tracking data"
  ON time_tracking
  FOR DELETE
  USING (auth.uid() = user_id);

-- Create the activity_sessions table for tracking individual sessions
CREATE TABLE activity_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  activity_id TEXT NOT NULL,
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ,
  duration_seconds INTEGER,
  date DATE NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add RLS (Row Level Security) policies to activity_sessions table
ALTER TABLE activity_sessions ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only view their own activity sessions
CREATE POLICY "Users can view their own activity sessions"
  ON activity_sessions
  FOR SELECT
  USING (auth.uid() = user_id);

-- Policy: Users can only insert their own activity sessions
CREATE POLICY "Users can insert their own activity sessions"
  ON activity_sessions
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can only update their own activity sessions
CREATE POLICY "Users can update their own activity sessions"
  ON activity_sessions
  FOR UPDATE
  USING (auth.uid() = user_id);

-- Policy: Users can only delete their own activity sessions
CREATE POLICY "Users can delete their own activity sessions"
  ON activity_sessions
  FOR DELETE
  USING (auth.uid() = user_id);

-- Create indexes for performance
CREATE INDEX idx_time_tracking_user_date ON time_tracking(user_id, date);
CREATE INDEX idx_activity_sessions_user_date ON activity_sessions(user_id, date);
CREATE INDEX idx_activity_sessions_activity ON activity_sessions(activity_id);

-- Create a function to update updated_at column automatically
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers to set updated_at columns
CREATE TRIGGER set_time_tracking_updated_at
BEFORE UPDATE ON time_tracking
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER set_activity_sessions_updated_at
BEFORE UPDATE ON activity_sessions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Trigger for book_lists updated_at
CREATE TRIGGER set_book_lists_updated_at
BEFORE UPDATE ON book_lists
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Trigger for ebooks updated_at
CREATE TRIGGER set_ebooks_updated_at
BEFORE UPDATE ON ebooks
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Optional: Create a view for daily summaries
CREATE VIEW daily_activity_summary AS
SELECT 
  user_id,
  date,
  SUM(total_seconds) as total_seconds_tracked,
  COUNT(DISTINCT activity_id) as unique_activities
FROM 
  time_tracking
GROUP BY 
  user_id, date
ORDER BY 
  date DESC;
