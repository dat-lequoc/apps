<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Ebook Reader</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --light-bg: #f8f8f8;
            --light-text: #333;
            --light-panel-bg: #fff;
            --light-border: #eee;
            --light-panel-shadow: rgba(0, 0, 0, 0.08);
            --light-highlight: rgba(66, 133, 244, 0.3);

            --sepia-bg: #f8f1e3;
            --sepia-text: #5f4b32;
            --sepia-panel-bg: #f7f0e0;
            --sepia-border: rgba(95, 75, 50, 0.15);
            --sepia-panel-shadow: rgba(95, 75, 50, 0.1);
            --sepia-highlight: rgba(210, 180, 140, 0.3);

            --dark-bg: #222;
            --dark-text: #e0e0e0;
            --dark-panel-bg: #333;
            --dark-border: #444;
            --dark-panel-shadow: rgba(0, 0, 0, 0.2);
            --dark-highlight: rgba(66, 133, 244, 0.4);

            --primary-color: #4285f4;
            --success-color: #34a853;
            --danger-color: #d93025;
            --panel-radius: 12px;

            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
            --reader-line-height: 1.6; /* Default line height */
        }

        body.light-theme {
            --bg-color: var(--light-bg);
            --text-color: var(--light-text);
            --panel-bg: var(--light-panel-bg);
            --border-color: var(--light-border);
            --panel-shadow: var(--light-panel-shadow);
            --highlight-color: var(--light-highlight);
        }

        body.sepia-theme {
            --bg-color: var(--sepia-bg);
            --text-color: var(--sepia-text);
            --panel-bg: var(--sepia-panel-bg);
            --border-color: var(--sepia-border);
            --panel-shadow: var(--sepia-panel-shadow);
            --highlight-color: var(--sepia-highlight);
        }

        body.dark-theme {
            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
            --input-bg: rgba(255, 255, 255, 0.05);
            --select-bg: rgba(255, 255, 255, 0.05);
            --modal-backdrop-color: rgba(0, 0, 0, 0.6);
            --text-muted: rgba(224, 224, 224, 0.7);
        }

        .hidden {
            display: none !important;
        }

        #ai-response-area {
            display: none;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        ::selection {
            background-color: var(--highlight-color);
        }

        html {
            font-size: 16px;
        }

        @media (max-width: 768px) {
            html {
                font-size: 14px;
            }
        }

        #app {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
        }

        #welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Changed from center to start */
            background-color: var(--bg-color);
            z-index: 100;
            padding: 3vh 1rem 1rem; /* Reduced top padding, added bottom */
            overflow-y: auto;
        }

        #welcome-screen h1 {
            margin-bottom: 1.5rem;
            text-align: center;
            font-size: 2.2rem;
        }

        .welcome-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align items to the top */
            width: 100%;
            max-width: 650px; /* Slightly wider */
            padding: 1rem;
            flex-grow: 1; /* Allow content to take space */
            display: flex; /* Ensure flex properties apply */
            flex-direction: column; /* Stack children vertically */
        }

        .welcome-actions {
            display: flex;
            flex-direction: column;
            gap: 1.5rem; /* Adjusted gap */
            margin-top: 1rem; /* Reduced top margin */
            width: 100%;
            align-items: center;
        }

        .main-actions {
             display: flex;
             gap: 1rem;
             justify-content: center;
             flex-wrap: wrap;
             width: 100%;
        }

        #library-section {
            width: 100%;
            max-width: 600px;
            margin-top: 2.5rem;
            background-color: var(--panel-bg);
            border-radius: 8px;
            /* Removed fixed height, let flexbox handle it */
            box-shadow: 0 2px 8px var(--panel-shadow);
            display: flex; /* Keep flex */
            flex-direction: column;
            overflow: hidden;
        }

        #list-management {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            gap: 1rem;
            flex-wrap: wrap;
        }

        #list-filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #list-filter {
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.9rem;
        }

        #create-list-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        #new-list-name {
            display: none;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.9rem;
            flex: 1;
            margin-right: 0.5rem;
        }

        #create-list-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            min-width: 40px;
            height: 34px;
            line-height: 1;
            text-align: center;
        }

        #list-controls-wrapper {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            flex-shrink: 0;
            padding: 1.25rem 1.25rem 0.5rem;
        }

        #list-badge-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            flex-grow: 1;
        }

        .list-badge {
            padding: 0.3rem 0.8rem;
            border-radius: 12px;
            font-size: 0.85rem;
            cursor: pointer;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            white-space: nowrap;
        }

        .list-badge:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .list-badge.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            font-weight: 500;
        }

        .list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.2); border-color: rgba(52, 168, 83, 0.4); color: #6fbf73; }
        .list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.2); border-color: rgba(251, 188, 5, 0.4); color: #fdd663; }
        .list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.2); border-color: rgba(234, 67, 53, 0.4); color: #f28b82; }
        .list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.2); border-color: rgba(66, 133, 244, 0.4); color: #8ab4f8; }
        .list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.2); border-color: rgba(156, 39, 176, 0.4); color: #c58af9; }

        body.light-theme .list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.1); border-color: rgba(52, 168, 83, 0.2); color: #0d652d; }
        body.light-theme .list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.1); border-color: rgba(251, 188, 5, 0.2); color: #995200; }
        body.light-theme .list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.1); border-color: rgba(234, 67, 53, 0.2); color: #940a0a; }
        body.light-theme .list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.1); border-color: rgba(66, 133, 244, 0.2); color: #0b57d0; }
        body.light-theme .list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.1); border-color: rgba(156, 39, 176, 0.2); color: #58117a; }

        .list-badge.active[data-color-index="0"],
        .list-badge.active[data-color-index="1"],
        .list-badge.active[data-color-index="2"],
        .list-badge.active[data-color-index="3"],
        .list-badge.active[data-color-index="4"] {
             background-color: var(--primary-color);
             border-color: var(--primary-color);
             color: white;
        }

        #create-list-group {
            flex-shrink: 0;
        }

        #new-list-name {
            width: 150px;
        }

        #create-list-btn {
        }

        #ai-cleanup-btn {
            padding: 0.4rem;
            font-size: 1.1rem;
            min-width: 34px;
            width: 34px;
            height: 34px;
            line-height: 1;
            margin-left: 0.5rem;
        }

        #library-list {
            flex: 1 1 auto;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            padding: 0 1.25rem 1.25rem;
            min-height: 0;
            position: relative;
            max-height: calc(100% - 50px);
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }

        #library-list::-webkit-scrollbar {
            width: 8px;
        }

        #library-list::-webkit-scrollbar-track {
            background: transparent;
        }

        #library-list::-webkit-scrollbar-thumb {
            background-color: rgba(155, 155, 155, 0.5);
            border-radius: 4px;
            border: 2px solid transparent;
        }

        #library-list::-webkit-scrollbar-thumb:hover {
            background-color: rgba(155, 155, 155, 0.8);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .input-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .input-field,
        .select-field {
            flex: 1;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            font-size: 1rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Added transition */
        }

        .input-field:focus,
        .select-field:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color), 0.2); /* Added focus ring */
        }

        #text-input {
            width: 100%;
            min-height: 120px;
            margin-bottom: 0;
        }

        #toggle-text-input-container {
            text-align: center;
            margin-top: 0.5rem;
        }

        #toggle-text-input {
            font-size: 0.9rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        #toggle-text-input:hover {
            text-decoration: underline;
        }

        #text-input-container {
            width: 100%;
        }

        .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1rem; /* Slightly increased padding */
            margin-bottom: 0.6rem; /* Increased gap */
            background-color: transparent; /* Transparent background */
            border: 1px solid var(--border-color); /* Subtle border */
            border-radius: 6px; /* Slightly larger radius */
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .library-item:hover {
            background-color: rgba(255, 255, 255, 0.05); /* Adjusted hover */
            border-color: rgba(255, 255, 255, 0.15); /* Highlight border on hover */
        }

        .library-item-details {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }

        .library-item-title {
            display: inline;
            font-weight: 500;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        .library-item-list-badge {
            font-size: 0.65rem;
            padding: 0.1rem 0.4rem;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            margin-left: 0.5rem;
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }
        .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.15); border: 1px solid rgba(52, 168, 83, 0.3); color: #6fbf73; }
        .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.15); border: 1px solid rgba(251, 188, 5, 0.3); color: #fdd663; }
        .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.15); border: 1px solid rgba(234, 67, 53, 0.3); color: #f28b82; }
        .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.15); border: 1px solid rgba(66, 133, 244, 0.3); color: #8ab4f8; }
        .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.15); border: 1px solid rgba(156, 39, 176, 0.3); color: #c58af9; }

        body.light-theme .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.1); border-color: rgba(52, 168, 83, 0.2); color: #0d652d; }
        body.light-theme .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.1); border-color: rgba(251, 188, 5, 0.2); color: #995200; }
        body.light-theme .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.1); border-color: rgba(234, 67, 53, 0.2); color: #940a0a; }
        body.light-theme .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.1); border-color: rgba(66, 133, 244, 0.2); color: #0b57d0; }
        body.light-theme .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.1); border-color: rgba(156, 39, 176, 0.2); color: #58117a; }

        .library-item-title-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .library-item-list-badge {
            font-size: 0.65rem;
            padding: 0.1rem 0.4rem;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            margin-left: 0.5rem;
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }
        .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.15); border: 1px solid rgba(52, 168, 83, 0.3); color: #6fbf73; }
        .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.15); border: 1px solid rgba(251, 188, 5, 0.3); color: #fdd663; }
        .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.15); border: 1px solid rgba(234, 67, 53, 0.3); color: #f28b82; }
        .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.15); border: 1px solid rgba(66, 133, 244, 0.3); color: #8ab4f8; }
        .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.15); border: 1px solid rgba(156, 39, 176, 0.3); color: #c58af9; }

        body.light-theme .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.1); border-color: rgba(52, 168, 83, 0.2); color: #0d652d; }
        body.light-theme .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.1); border-color: rgba(251, 188, 5, 0.2); color: #995200; }
        body.light-theme .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.1); border-color: rgba(234, 67, 53, 0.2); color: #940a0a; }
        body.light-theme .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.1); border-color: rgba(66, 133, 244, 0.2); color: #0b57d0; }
        body.light-theme .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.1); border-color: rgba(156, 39, 176, 0.2); color: #58117a; }

        .library-item-title-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .library-item-meta {
            font-size: 0.75rem;
            color: rgba(var(--text-color), 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .library-item-move {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            margin-right: 0.5rem;
            transition: background-color 0.2s;
        }
        .library-item-move:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .move-list-dropdown {
            position: absolute;
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 2px 8px var(--panel-shadow);
            z-index: 10;
            min-width: 150px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            margin-top: 2px;
            right: 0;
        }

        .move-list-dropdown.visible {
            display: block;
        }

        .move-list-option {
            padding: 0.5rem 0.8rem;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-bottom: 1px solid var(--border-color);
        }
        .move-list-option:last-child {
            border-bottom: none;
        }

        .move-list-option:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .move-list-option.disabled {
            color: var(--text-muted);
            cursor: default;
            background-color: transparent;
        }


        .progress-bar-container {
            height: 4px;
            background-color: rgba(var(--text-color), 0.1);
            border-radius: 2px;
            margin-top: 0.3rem;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .library-item-actions {
            display: flex;
            gap: 0.5rem;
            margin-left: 0.5rem;
            flex-shrink: 0;
        }

        .library-item-delete {
            color: var(--danger-color);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.125rem;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
        }

        .library-item-delete:hover {
            background-color: rgba(217, 48, 37, 0.1);
        }

        .auth-section {
            margin-top: 1.875rem;
            text-align: center;
        }

        .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px; /* Slightly larger radius */
            padding: 0.8rem 1.6rem; /* Increased padding */
            font-size: 1rem;
            font-weight: 500; /* Slightly bolder text */
            cursor: pointer;
            box-shadow: 0 1px 3px var(--panel-shadow); /* Softer shadow */
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
        }

        .button:hover {
            background-color: #3367d6;
            box-shadow: 0 2px 6px var(--panel-shadow); /* Enhance shadow on hover */
        }

        .button:active {
            transform: translateY(1px);
        }

        .button-secondary {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            box-shadow: none;
        }

        .button-secondary:hover {
            background-color: rgba(66, 133, 244, 0.1); /* Light primary color background */
            border-color: #3367d6; /* Darker primary on hover */
            box-shadow: none;
        }

        body.light-theme .button-secondary {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }
        body.light-theme .button-secondary:hover {
            background-color: rgba(66, 133, 244, 0.05);
            border-color: #0b57d0;
        }

        .button.loading {
            position: relative;
            color: transparent !important;
            pointer-events: none;
        }

        .button.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1rem;
            height: 1rem;
            margin-top: -0.5rem;
            margin-left: -0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: button-spin 0.8s linear infinite;
        }

        @keyframes button-spin {
            to { transform: rotate(360deg); }
        }

        .success-button {
            background-color: var(--success-color);
        }

        .success-button:hover {
            background-color: #2e9549;
        }

        .example-book-section {
            margin-top: 1.875rem;
            text-align: center;
            padding: 1.25rem;
            background-color: rgba(66, 133, 244, 0.1);
            border-radius: 8px;
            margin-bottom: 1.25rem;
        }

        .example-book-section p {
            margin-bottom: 0.75rem;
        }

        #navbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3.5rem;
            background-color: var(--panel-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            z-index: 20;
        }

        #navbar.visible {
            transform: translateY(0);
        }

        #book-title {
            font-size: 1.125rem;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 40%;
        }

        #navbar-buttons {
            display: flex;
            gap: 1rem;
        }

        .navbar-btn {
            background-color: transparent;
            border: none;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
            font-size: 1.25rem;
            transition: background-color 0.2s;
        }

        .navbar-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #reader-container {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #content-area {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
            padding-top: 2rem;
            -webkit-overflow-scrolling: touch;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
            transition: background-color 0.3s ease, color 0.3s ease;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: var(--reader-line-height); /* Apply reader line height */
        }

        #content-area img {
            max-width: 100%;
            height: auto;
            display: block; /* Optional: ensures block-level behavior */
            margin: 1rem auto; /* Optional: centers images and adds space */
        }

        /* Base paragraph style */
        #content-area p {
            margin-bottom: 1rem;
            /* line-height is inherited from #content-area */
        }

        /* Markdown Content Styling */
        #content-area h1,
        #content-area h2,
        #content-area h3,
        #content-area h4,
        #content-area h5,
        #content-area h6 {
            font-size: 1.1em; /* Slightly larger than paragraphs */
            font-weight: 600; /* Less bold than default */
            margin-top: 1.5rem;
            margin-bottom: 0.5rem; /* Less space after headings */
            line-height: 1.4; /* Specific line height for headings */
        }

        #content-area h1 { font-size: 1.3em; }
        #content-area h2 { font-size: 1.2em; }

        #content-area ul,
        #content-area ol {
            margin-bottom: 1rem;
            padding-left: 1.5em; /* Standard indent */
        }

        #content-area li {
            margin-bottom: 0.5rem; /* Space between list items */
        }

        #content-area blockquote {
            margin-left: 1em;
            padding-left: 1em;
            border-left: 3px solid var(--border-color);
            color: var(--text-muted, rgba(224, 224, 224, 0.7)); /* Muted color for quotes */
            margin-bottom: 1rem;
        }
        body.light-theme #content-area blockquote { color: var(--text-muted, #666); }
        body.sepia-theme #content-area blockquote { color: var(--text-muted, #8c7a64); }


        #content-area code {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-family: monospace;
        }
        body.light-theme #content-area code { background-color: rgba(0, 0, 0, 0.05); }
        body.sepia-theme #content-area code { background-color: rgba(95, 75, 50, 0.08); }


        #content-area pre {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 0.8em;
            border-radius: 4px;
            overflow-x: auto;
            margin-bottom: 1rem;
            font-family: monospace;
            line-height: 1.4; /* Specific line height for code blocks */
        }
        body.light-theme #content-area pre { background-color: rgba(0, 0, 0, 0.03); }
        body.sepia-theme #content-area pre { background-color: rgba(95, 75, 50, 0.05); }


        #content-area pre code {
            background-color: transparent;
            padding: 0;
        }

        #content-area hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 1.5rem 0;
        }
        /* End Markdown Content Styling */

        #settings-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--panel-bg);
            padding: 1.5rem; /* Increased padding */
            border-top-left-radius: var(--panel-radius);
            border-top-right-radius: var(--panel-radius);
            box-shadow: 0 -2px 10px var(--panel-shadow);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 30;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.25rem;
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-grid > .settings-section {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        #settings-panel > .settings-grid:last-of-type {
             border-bottom: none;
        }
         #settings-panel > .settings-section:last-child {
             border-bottom: none;
             margin-bottom: 0;
             padding-bottom: 0;
         }


        #settings-panel.visible {
            transform: translateY(0);
        }

        .settings-section {
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .settings-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
        }

        #ai-settings-content {
            margin-bottom: 1rem;
        }

        .settings-row.ai-toggle {
            margin-top: 0.75rem;
        }

        #ai-response-area {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            padding: 0.75rem;
            margin-top: 0.75rem;
            font-size: 0.875rem;
            max-height: 12.5rem;
            overflow-y: auto;
        }

        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .font-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
        }

        .theme-options {
            display: flex;
            gap: 1rem;
        }

        .theme-option {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .theme-option.active {
            border-color: var(--primary-color);
        }

        .light-option {
            background-color: var(--light-bg);
            border: 1px solid var(--light-border);
        }

        .sepia-option {
            background-color: var(--sepia-bg);
        }

        .dark-option {
            background-color: var(--dark-bg);
        }

        #nav-controls {
            position: fixed;
            bottom: 1.25rem;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 1.25rem;
            pointer-events: none;
            z-index: 15;
        }

        .nav-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background-color: var(--panel-bg);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transition: background-color 0.2s;
        }

        .nav-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #toc-panel {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 80%;
            max-width: 20rem;
            background-color: var(--panel-bg);
            z-index: 30;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px var(--panel-shadow);
        }

        #toc-panel.visible {
            transform: translateX(0);
        }

        #toc-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #toc-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem; /* Increased horizontal padding */
        }

        .toc-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .toc-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .toc-item.toc-active {
            font-weight: bold;
            background-color: rgba(var(--primary-color), 0.1);
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.4);
            z-index: 25;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #overlay.visible {
            display: block;
            opacity: 1;
        }

        #progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background-color: var(--primary-color);
            transition: width 0.2s ease;
            z-index: 10;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #loading.visible {
            display: flex;
            opacity: 1;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-left-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #translation-popup {
            position: fixed;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            padding: 16px;
            min-width: 220px;
            max-width: 320px;
            z-index: 100;
            display: none;
            border: 1px solid rgba(0,0,0,0.08);
            transform: translateY(10px);
            opacity: 0;
            transition: transform 0.2s ease, opacity 0.2s ease;
            font-style: italic;
            color: #4285f4;
        }

        #translation-popup.visible {
            transform: translateY(0);
            opacity: 1;
        }

        body.light-theme #translation-popup {
            background-color: #ffffff;
            color: #4285f4;
        }

        body.sepia-theme #translation-popup {
            background-color: #f7f0e0;
            color: #4285f4;
            border-color: rgba(95, 75, 50, 0.15);
        }

        body.dark-theme #translation-popup {
            background-color: #2d2d2d;
            color: #4285f4;
            border-color: rgba(255,255,255,0.1);
        }

        #translation-popup:before {
            content: '';
            position: absolute;
            top: -8px;
            left: 20px;
            width: 14px;
            height: 14px;
            background-color: inherit;
            border-top: 1px solid rgba(0,0,0,0.08);
            border-left: 1px solid rgba(0,0,0,0.08);
            transform: rotate(45deg);
        }

        body.dark-theme #translation-popup:before {
            border-color: rgba(255,255,255,0.1);
        }

        body.sepia-theme #translation-popup:before {
            border-color: rgba(95, 75, 50, 0.15);
        }

        #translation-content {
            margin-bottom: 10px;
            font-size: 15px;
            line-height: 1.5;
        }

        #translation-loading {
            display: none;
            align-items: center;
            justify-content: center;
            height: 30px;
        }

        #translation-loading .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-left-color: #4285f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        body.dark-theme #translation-loading .spinner {
            border-color: rgba(255,255,255,0.1);
            border-left-color: #4285f4;
        }

        .flashcard-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            padding: 8px 12px;
            width: 240px;
            z-index: 1000;
            font-size: 14px;
            opacity: 1;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        body.dark-theme .flashcard-toast {
            background-color: #333;
            color: #e0e0e0;
        }

        .flashcard-toast.visible {
            display: block;
        }

        .flashcard-toast.fade-out {
            opacity: 0;
            transform: translateY(10px);
        }

        .flashcard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .flashcard-close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #888;
            padding: 0;
            margin: 0;
        }

        .flashcard-word {
            font-weight: bold;
            font-size: 16px;
        }

        .flashcard-translation {
            margin-bottom: 8px;
            line-height: 1.3;
            font-size: 13px;
        }

        .flashcard-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .flashcard-speak-btn {
            background-color: #34a853;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 0 0 auto;
        }

        .flashcard-save-btn {
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 1;
        }

        .flashcard-save-btn:disabled {
            background-color: #a4c2f4;
        }

        @media (max-width: 768px) {
            #toc-panel {
                width: 100%;
                max-width: none;
            }

            .welcome-buttons {
                flex-direction: column;
                width: 100%;
            }

            .welcome-buttons .button {
                width: 100%;
                text-align: center;
            }

            #book-title {
                max-width: 60%;
            }

            #navbar-buttons {
                gap: 0.5rem;
            }

            .flashcard-toast {
                left: 1.25rem;
                right: 1.25rem;
                width: auto;
            }

            #chat-panel {
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                max-width: none;
                max-height: none;
                border-radius: 0;
                transform: translate(0, 0) scale(1);
                border: none;
            }

            #chat-panel:not(.visible) {
                 transform: translateY(100%);
                 opacity: 0;
            }
            #chat-panel.visible {
                 transform: translateY(0);
                 opacity: 1;
            }

        }

        button, input[type="checkbox"] {
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        #content-area a {
            text-decoration: underline;
            font-style: italic;
            color: var(--primary-color);
            cursor: pointer;
        }

        #content-area a:hover {
            color: #3367d6;
        }
        #toast {
            position: fixed;
            bottom: 1.25rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: var(--panel-bg);
            color: var(--text-color);
            padding: 0.75rem 1.25rem;
            border-radius: 4px;
            box-shadow: 0 4px 12px var(--panel-shadow);
            z-index: 1000;
            transition: transform 0.3s ease;
            text-align: center;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
        }

        .link-action-toast {
            position: fixed;
            bottom: 1.25rem;
            left: 50%;
            transform: translateX(-50%) translateY(150px);
            background-color: var(--panel-bg);
            color: var(--text-color);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--panel-shadow);
            z-index: 1001;
            transition: transform 0.3s ease;
            width: 90%;
            max-width: 400px;
            text-align: left;
        }

        .link-action-toast.visible {
            transform: translateX(-50%) translateY(0);
        }

        .link-action-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .link-action-close-btn {
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            line-height: 1;
        }

        .link-action-url {
            font-size: 0.9rem;
            margin-bottom: 1rem;
            word-break: break-word;
        }

        .link-action-target-url {
            font-size: 0.8rem;
            margin-bottom: 1rem;
            word-break: break-all;
            color: var(--text-muted);
            max-height: 4.8em;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .link-action-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .link-action-btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: transparent;
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .link-action-btn.scrape {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .link-action-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .link-action-btn.scrape:hover {
            background-color: #3367d6;
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--modal-backdrop-color);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal-backdrop.visible {
            display: block;
            opacity: 1;
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background-color: var(--panel-bg);
            color: var(--text-color);
            border-radius: var(--panel-radius);
            box-shadow: 0 8px 25px var(--panel-shadow);
            z-index: 1000;
            display: none;
            flex-direction: column;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .modal.visible {
            display: flex;
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .modal-header {
            padding: 0.8rem 1.2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.3rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.2rem;
            line-height: 1;
        }

        .modal-body {
            padding: 1rem 1.2rem;
            overflow-y: auto;
            flex-grow: 1;
            font-size: 0.9rem;
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }
        .modal-body::-webkit-scrollbar { width: 6px; }
        .modal-body::-webkit-scrollbar-track { background: transparent; }
        .modal-body::-webkit-scrollbar-thumb { background-color: rgba(155, 155, 155, 0.5); border-radius: 3px; }

        .modal-body p {
            margin-bottom: 1rem;
            color: var(--text-muted);
        }

        .cleanup-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        .cleanup-item:last-child {
            border-bottom: none;
        }

        .cleanup-item input[type="checkbox"] {
            margin-right: 0.8rem;
            flex-shrink: 0;
            width: 18px;
            height: 18px;
        }

        .cleanup-item-details {
            flex-grow: 1;
            min-width: 0;
        }

        .cleanup-item-title {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 0.1rem;
        }

        .cleanup-item-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .modal-footer {
            padding: 0.8rem 1.2rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            flex-shrink: 0;
        }

        .modal-footer .button {
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
        }

        .modal-footer .button.danger {
            background-color: var(--danger-color);
        }
        .modal-footer .button.danger:hover {
            background-color: #c5221f;
        }

        .line-height-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        #source-url-display {
            display: none;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        #source-url-content-link {
            word-break: break-all;
            color: var(--primary-color);
            text-decoration: none;
        }
        #source-url-content-link:hover {
            text-decoration: underline;
        }

        #api-status-container {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .api-status-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.4rem;
        }

        .api-status-item .status-icon {
            margin-right: 0.5rem;
            font-size: 1rem;
        }

        .api-status-item .status-text a {
            color: var(--primary-color);
            text-decoration: underline;
        }
        .panel {
            position: fixed;
            background-color: var(--panel-bg);
            color: var(--text-color);
            border-radius: var(--panel-radius);
            box-shadow: 0 5px 20px var(--panel-shadow);
            z-index: 1001;
            display: none;
            flex-direction: column;
            border: 1px solid var(--border-color);
        }

        .settings-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 18px 25px;
            padding: 20px;
            max-height: 75vh;
            overflow-y: auto;
            align-items: start;
        }

        .settings-content > .settings-divider,
        .settings-content > .ai-features-section,
        .settings-content > .api-status-section {
            grid-column: 1 / -1;
            margin-top: 0;
            margin-bottom: 0;
        }
        .settings-content > .settings-divider {
            margin-top: 3px;
            margin-bottom: 3px;
        }


        .settings-section {
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-section > label {
            display: block;
            margin-bottom: 0px;
            font-weight: bold;
            color: var(--text-color);
            font-size: 0.95em;
        }

        .setting-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-control.font-size-control,
        .setting-control.line-height-control {
            justify-content: space-between;
        }

        .setting-control.font-size-control span,
        .setting-control.line-height-control span {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            flex-grow: 1;
        }

        .theme-control {
            justify-content: flex-start;
            gap: 10px;
        }

        .theme-option {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: border-color 0.3s ease, transform 0.2s ease;
        }
        .theme-option:hover {
            transform: scale(1.1);
        }
        .theme-option.active {
             border-color: var(--primary-color);
             border-width: 3px;
        }
        .theme-option[data-theme="light"] { background-color: var(--light-panel-bg); }
        .theme-option[data-theme="sepia"] { background-color: var(--sepia-panel-bg); }
        .theme-option[data-theme="dark"] { background-color: var(--dark-panel-bg); }


        .setting-control.checkbox-control {
            justify-content: space-between;
            width: 100%;
            padding: 1px 0;
        }

        .setting-control.checkbox-control label {
            margin-bottom: 0;
            font-weight: normal;
            flex-grow: 1;
            cursor: pointer;
        }

        .setting-control.checkbox-control input[type="checkbox"] {
            margin: 0;
            flex-shrink: 0;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }

        .settings-section:has(#markdownModeToggle) > label {
            margin-bottom: 5px;
        }
        .settings-section:has(#markdownModeToggle) .setting-control.checkbox-control {
        }

        .setting-control:has(#speechLanguageSelect) {
            justify-content: space-between;
            width: 100%;
            padding: 1px 0;
        }
        .setting-control:has(#speechLanguageSelect) label {
             margin-bottom: 0;
             font-weight: normal;
             flex-shrink: 0;
             cursor: default;
        }
        #speechLanguageSelect {
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            color: var(--text-color);
            max-width: 160px;
            font-size: 0.9em;
        }

        .api-status-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 5px;
        }

        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        .icon-btn {
            padding: 0;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
            font-size: 1.1em;
            flex-shrink: 0;
        }
        .icon-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-color);
        }
        .icon-btn:active {
            transform: scale(0.95);
        }

        #chat-panel {
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%) scale(0.9);
             width: 90%;
             max-width: 700px;
             height: 80vh;
             max-height: 700px;
             opacity: 0;
             transition: transform 0.3s ease, opacity 0.3s ease;
             overflow: hidden;
         }

        #chat-panel.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            display: flex;
        }

        #chat-header {
            padding: 0.6rem 1.1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .chat-header-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        #chat-header h3 {
            margin: 0;
            font-size: 1.1rem;
            flex-grow: 1;
        }

        .chat-clear-btn {
            font-size: 1rem;
            width: 28px;
            height: 28px;
        }

        .chat-context-toggle {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        #chat-messages {
            flex: 1 1 auto;
            overflow-y: auto;
            padding: 1rem 1.1rem;
            display: flex;
            flex-direction: column;
            gap: 0.85rem;
            min-height: 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }

        #chat-messages::-webkit-scrollbar { width: 6px; }
        #chat-messages::-webkit-scrollbar-track { background: transparent; }
        #chat-messages::-webkit-scrollbar-thumb { background-color: rgba(155, 155, 155, 0.5); border-radius: 3px; }

        .chat-message {
            padding: 0.6rem 0.9rem;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
            line-height: 1.5;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .chat-message.user {
            background-color: var(--primary-color);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 2px;
        }

        .chat-message.assistant {
            background-color: var(--panel-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            align-self: flex-start;
            border-bottom-left-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            max-width: 100%;
        }

        .chat-message.assistant a {
            color: var(--primary-color);
            text-decoration: underline;
        }
        .chat-message.assistant a:hover {
            color: #66a3ff;
        }

        .chat-message.assistant.loading::after {
            content: '...';
            display: inline-block;
            animation: loading-dots 1.5s infinite;
        }

        #chat-suggestions {
            display: none;
            padding: 0.25rem 0 0.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
            flex-shrink: 0;
        }

        .suggestion-chip {
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            cursor: pointer;
            border: 1px solid var(--border-color);
            background-color: rgba(255, 255, 255, 0.08);
            color: var(--text-muted);
            transition: background-color 0.2s, color 0.2s;
            white-space: nowrap;
        }

        .suggestion-chip:hover {
            background-color: rgba(255, 255, 255, 0.15);
            color: var(--text-color);
        }

        @keyframes loading-dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }


        #chat-input-area {
            flex-direction: column;
            display: flex;
            padding: 0.4rem 0.6rem;
            border-top: 1px solid var(--border-color);
            gap: 0.5rem;
            align-items: stretch;
            flex-shrink: 0;
        }

        .chat-input-row {
            display: flex;
            align-items: flex-end;
            gap: 0.5rem;
            width: 100%;
        }

        #chat-input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            font-size: 0.95rem;
            resize: none;
            line-height: 1.4;
            min-height: 36px;
            max-height: 80px;
            overflow-y: auto;
        }

        #chat-send-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.95rem;
            height: 36px;
            flex-shrink: 0;
        }

    </style>
</head>
<body class="dark-theme">
    <div id="app">
        <div id="welcome-screen">
            <div class="welcome-content">
                <h1>Enhanced Ebook Reader</h1>
                <p>Read from a URL, paste text, or open a local file.</p>

                <div class="welcome-actions">
                    <!-- URL Input First -->
                    <div class="input-group" id="url-input-container">
                        <div class="input-row">
                            <input id="url-input" type="url" placeholder="Enter a URL to read" class="input-field">
                            <button type="button" id="process-url-btn" class="button">Read URL</button>
                            <button type="button" id="process-url-btn" class="button">Read URL</button>
                        </div>
                    </div>

                    <!-- Text Input Section -->
                    <div id="toggle-text-input-container">
                        <a href="#" id="toggle-text-input">or paste text directly</a>
                    </div>
                    <div class="input-group" id="text-input-container" style="display: none;">
                        <textarea id="text-input" class="input-field" placeholder="Paste your text here..."></textarea>
                        <div class="input-row">
                            <input id="text-input-title" type="text" placeholder="Enter a title (optional)" class="input-field">
                            <button type="button" id="process-text-btn" class="button">Read Text</button>
                            <button type="button" id="process-text-btn" class="button">Read Text</button>
                        </div>
                    </div>

                     <!-- Local File / Example Section -->
                     <div style="margin-top: 1rem; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 1rem;">
                        <button type="button" id="open-file-btn" class="button button-secondary">Open Local File</button>
                        <div class="example-book-section" style="margin-top: 0.5rem; margin-bottom: 0;"> <!-- Reduced margins -->
                            <p style="margin-bottom: 0.5rem;">Don't have an ebook? Try our example:</p>
                            <a id="example-book-btn" class="button success-button" href="https://raw.githubusercontent.com/dat-lequoc/apps/refs/heads/main/ebooks/Kundera%2C%20Milan%20-%20The%20Unbearable%20Lightness%20of%20Being%20(2017%2C%20Faber%20and%20Faber)%20-%20libgen.li.epub" target="_blank" rel="noopener">Download Sample Book</a>
                        </div>
                    </div>

                    <!-- Sign In Button (if needed) -->
                    <div class="main-actions" style="margin-top: 1rem;">
                         <button type="button" id="login-btn" class="button hidden">Sign In</button>
                    </div>
                </div>

                <!-- Auth Status Moved Down -->
                <div class="auth-section" id="auth-section" style="margin-top: auto; padding-top: 1rem;"> <!-- Push to bottom -->
                    <p>Sign in to save books to your library.</p>
                </div>

                <div id="library-section" style="display: none;">
                    <div id="list-controls-wrapper">
                        <div id="list-badge-container">
                        </div>
                        <div id="create-list-group">
                            <input type="text" id="new-list-name" placeholder="New list name..." />
                            <button type="button" id="create-list-btn" class="button">+</button>
                            <button type="button" id="ai-cleanup-btn" class="button icon-btn" title="AI Library Cleanup" aria-label="AI Library Cleanup" style="display: none;">🧹</button>
                        </div>
                    </div>
                    <div id="library-list">
                    </div>
                </div>
            </div>
        </div>

        <div id="navbar">
            <div id="book-title">Ebook Title</div>
            <div id="navbar-buttons">
                <button type="button" class="navbar-btn" id="toc-btn" aria-label="Table of Contents">☰</button>
                <button type="button" class="navbar-btn" id="settings-btn" aria-label="Settings">⚙️</button>
                <button type="button" class="navbar-btn" id="chat-btn" aria-label="Chat">💬</button>
                <button type="button" class="navbar-btn" id="home-btn" aria-label="Home">⌂</button>
            </div>
        </div>

        <div id="reader-container">
            <div id="content-area">
                <div id="source-url-display" style="display: none; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); font-size: 0.9rem;">
                    Source: <a id="source-url-content-link" href="#" target="_blank" rel="noopener noreferrer" style="word-break: break-all; color: var(--primary-color);"></a>
                </div>
            </div>
            <div id="progress-bar"></div>
        </div>

        <div id="nav-controls">
            <button type="button" class="nav-btn" id="prev-btn" aria-label="Previous Chapter">←</button>
            <button type="button" class="nav-btn" id="next-btn" aria-label="Next Chapter">→</button>
        </div>

        <div id="toc-panel">
            <div id="toc-header">
                <h3>Table of Contents</h3>
                <button type="button" class="navbar-btn" id="close-toc-btn" aria-label="Close">✕</button>
            </div>
            <div id="toc-content"></div>
        </div>

        <div id="settings-panel">
            <div class="settings-grid">
                <div class="settings-section">
                    <div class="settings-title">Font Size</div>
                    <div class="font-size-controls">
                        <button type="button" class="font-btn" id="font-decrease-btn" aria-label="Decrease Font Size">A-</button>
                        <span id="font-size-value">100%</span>
                        <button type="button" class="font-btn" id="font-increase-btn" aria-label="Increase Font Size">A+</button>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="settings-title">Line Height</div>
                    <div class="line-height-controls">
                        <button type="button" class="font-btn" id="line-height-decrease-btn" aria-label="Decrease Line Height">-</button>
                        <span id="line-height-value">1.6</span>
                        <button type="button" class="font-btn" id="line-height-increase-btn" aria-label="Increase Line Height">+</button>
                    </div>
                </div>
            </div>

            <div class="settings-grid">
                <div class="settings-section">
                    <div class="settings-title">Theme</div>
                    <div class="theme-options">
                        <div class="theme-option light-option" data-theme="light" title="Light Theme"></div>
                        <div class="theme-option sepia-option" data-theme="sepia" title="Sepia Theme"></div>
                        <div class="theme-option dark-option active" data-theme="dark" title="Dark Theme"></div>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="settings-title">Content View</div>
                    <div class="settings-row">
                        <label for="view-raw-html-toggle">View Raw HTML (URLs/EPUBs)</label>
                        <input type="checkbox" id="view-raw-html-toggle">
                    </div>
                </div>
            </div>

            <div class="settings-section" id="ai-features-section">
                <div class="settings-title">AI Features</div>
                <div class="settings-row ai-toggle">
                    <label for="translation-toggle">Text Selection Translation</label>
                    <input type="checkbox" id="translation-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="auto-speak-toggle">Auto Speak Flashcard Words</label>
                    <input type="checkbox" id="auto-speak-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="speak-selection-toggle">Speak Full Selection (instead of just flashcard word)</label>
                    <input type="checkbox" id="speak-selection-toggle">
                </div>
                <div class="settings-row">
                    <label for="speech-language">Speech Language</label>
                    <select id="speech-language">
                        <option value="en-US">English</option>
                        <option value="fr-FR">French</option>
                    </select>
                </div>
                <div id="ai-settings-content">
                    <p>Loading API status...</p>
                </div>
                <button type="button" id="summarize-chapter-btn" class="button" style="margin-top: 0.75rem; display: none;">Summarize Chapter</button>
                <div id="ai-response-area" style="display: none; margin-top: 1rem; background-color: rgba(255, 255, 255, 0.05); border-radius: 4px; padding: 0.75rem; font-size: 0.875rem; max-height: 15rem; overflow-y: auto;"></div>
            </div>
        </div>

        <div id="chat-panel" class="panel">
            <div id="chat-header">
                <h3>Chat with AI</h3>
                <div class="chat-header-controls">
                    <button type="button" class="icon-btn chat-clear-btn" id="chat-clear-btn" aria-label="Clear Chat" title="Clear Chat History">🗑️</button>
                    <div class="chat-context-toggle">
                        <input type="checkbox" id="chat-full-doc-toggle" style="width: 16px; height: 16px; vertical-align: middle;" checked>
                        <label for="chat-full-doc-toggle" style="font-size: 0.85rem; vertical-align: middle; cursor: pointer;">Use Full Document</label>
                    </div>
                    <button type="button" class="navbar-btn" id="close-chat-btn" aria-label="Close">✕</button>
                </div>
            </div>
            <div id="chat-messages">
                <div class="chat-message assistant">Hello! Ask me anything about the full document <br> (or toggle 'Use Full Document' above to focus on the current chapter).</div>
            </div>
            <div id="chat-input-area">
                <div id="chat-suggestions">
                </div>
                <div class="chat-input-row">
                    <textarea id="chat-input" placeholder="Type your message..." rows="1"></textarea>
                    <button type="button" id="chat-send-btn" class="button">Send</button>
                </div>
            </div>
        </div>

        <div id="overlay"></div>

        <div id="loading">
            <div class="spinner"></div>
        </div>

        <div id="translation-popup">
            <div id="translation-content"></div>
            <div id="translation-loading">
                <div class="spinner"></div>
            </div>
        </div>

        <div id="toast"></div>

        <input type="file" id="file-input" accept=".txt,.epub,.pdf" style="display: none;">
    </div>

    <div id="ai-cleanup-backdrop" class="modal-backdrop"></div>
    <div id="ai-cleanup-modal" class="modal">
        <div class="modal-header">
            <h3>AI Cleanup Suggestions</h3>
            <button type="button" id="ai-cleanup-close-btn" class="modal-close-btn" aria-label="Close">×</button>
        </div>
        <div class="modal-body" id="ai-cleanup-list">
            <p>Loading suggestions...</p>
        </div>
        <div class="modal-footer">
            <button type="button" id="ai-cleanup-cancel-btn" class="button">Cancel</button>
            <button type="button" id="ai-cleanup-confirm-btn" class="button danger">Delete Selected</button>
        </div>
    </div>

    <script>
        const EbookApp = (function() {
            const supabaseUrl = 'https://iioxqphxakvhhtyvdhrh.supabase.co';
            const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpb3hxcGh4YWt2aGh0eXZkaHJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg4MzQ5MjAsImV4cCI6MjA1NDQxMDkyMH0.7I2CaBH1DyiRYEtzunIM5-l3GaWYT15Mly39jW-ga5Q';
            const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);

            const DOM = {
                app: document.getElementById('app'),
                welcomeScreen: document.getElementById('welcome-screen'),
                readerContainer: document.getElementById('reader-container'),
                contentArea: document.getElementById('content-area'),
                navbar: document.getElementById('navbar'),
                bookTitle: document.getElementById('book-title'),
                tocBtn: document.getElementById('toc-btn'),
                settingsBtn: document.getElementById('settings-btn'),
                homeBtn: document.getElementById('home-btn'),
                tocPanel: document.getElementById('toc-panel'),
                closeTocBtn: document.getElementById('close-toc-btn'),
                tocContent: document.getElementById('toc-content'),
                settingsPanel: document.getElementById('settings-panel'),
                overlay: document.getElementById('overlay'),
                fileInput: document.getElementById('file-input'),
                openFileBtn: document.getElementById('open-file-btn'),
                exampleBookBtn: document.getElementById('example-book-btn'),
                textInput: document.getElementById('text-input'),
                textInputTitle: document.getElementById('text-input-title'),
                processTextBtn: document.getElementById('process-text-btn'),
                toggleTextInput: document.getElementById('toggle-text-input'),
                textInputContainer: document.getElementById('text-input-container'),
                urlInputContainer: document.getElementById('url-input-container'),
                urlInput: document.getElementById('url-input'),
                processUrlBtn: document.getElementById('process-url-btn'),
                fontDecreaseBtn: document.getElementById('font-decrease-btn'),
                fontIncreaseBtn: document.getElementById('font-increase-btn'),
                fontSizeValue: document.getElementById('font-size-value'),
                lineHeightDecreaseBtn: document.getElementById('line-height-decrease-btn'),
                lineHeightIncreaseBtn: document.getElementById('line-height-increase-btn'),
                lineHeightValue: document.getElementById('line-height-value'),
                themeOptions: document.querySelectorAll('.theme-option'),
                progressBar: document.getElementById('progress-bar'),
                prevBtn: document.getElementById('prev-btn'),
                nextBtn: document.getElementById('next-btn'),
                loading: document.getElementById('loading'),
                toast: document.getElementById('toast'),
                loginBtn: document.getElementById('login-btn'),
                librarySection: document.getElementById('library-section'),
                authSection: document.getElementById('auth-section'),
                translationToggle: document.getElementById('translation-toggle'),
                autoSpeakToggle: document.getElementById('auto-speak-toggle'),
                speakSelectionToggle: document.getElementById('speak-selection-toggle'),
                speechLanguage: document.getElementById('speech-language'),
                translationPopup: document.getElementById('translation-popup'),
                translationContent: document.getElementById('translation-content'),
                translationLoading: document.getElementById('translation-loading'),
                viewRawHtmlToggle: document.getElementById('view-raw-html-toggle'), // Renamed
                sourceUrlDisplay: document.getElementById('source-url-display'),
                sourceUrlContentLink: document.getElementById('source-url-content-link'),
                listBadgeContainer: document.getElementById('list-badge-container'),
                createListBtn: document.getElementById('create-list-btn'),
                newListNameInput: document.getElementById('new-list-name'),
                createListGroup: document.getElementById('create-list-group'),
                aiCleanupBtn: document.getElementById('ai-cleanup-btn'),
                aiCleanupModal: document.getElementById('ai-cleanup-modal'),
                aiCleanupBackdrop: document.getElementById('ai-cleanup-backdrop'),
                aiCleanupList: document.getElementById('ai-cleanup-list'),
                aiCleanupCloseBtn: document.getElementById('ai-cleanup-close-btn'),
                aiCleanupCancelBtn: document.getElementById('ai-cleanup-cancel-btn'),
                aiCleanupConfirmBtn: document.getElementById('ai-cleanup-confirm-btn'),
                chatBtn: document.getElementById('chat-btn'),
                chatPanel: document.getElementById('chat-panel'),
                closeChatBtn: document.getElementById('close-chat-btn'),
                chatMessages: document.getElementById('chat-messages'),
                chatInput: document.getElementById('chat-input'),
                chatSendBtn: document.getElementById('chat-send-btn'),
                chatClearBtn: document.getElementById('chat-clear-btn'),
                chatFullDocToggle: document.getElementById('chat-full-doc-toggle'),
                chatSuggestions: document.getElementById('chat-suggestions'),
                aiSettingsContent: document.getElementById('ai-settings-content'),
                summarizeChapterBtn: document.getElementById('summarize-chapter-btn'), // Added
                aiResponseArea: document.getElementById('ai-response-area') // Added
            };

            let state = {
                bookData: {
                    title: '',
                    content: '',
                    chapters: [],
                    currentPosition: 0,
                    sourceUrl: null,
                    rawContent: null,
                    currentListId: null
                },
                settings: {
                    fontSize: 100,
                    lineHeight: 1.6,
                    theme: 'dark',
                    // preferHtmlView: false, // Removed
                    viewRawHtmlEnabled: false, // Renamed
                    speakSelectionEnabled: false
                },
                session: null,
                userApiSettings: null,
                translationTimer: null,
                navbarHideTimer: null,
                debounceTimers: {},
                bookLists: [],
                selectedListId: 'all',
                isCreatingList: false,
                isAiCleanupModalOpen: false,
                lastSelectionRect: null,
                chatHistory: [],
                chatUseFullDocument: true,
                lastPosition: null
            };

            const initialSuggestedQuestions = [
                "Summarize this.",
                "Key points?",
                "Explain the main idea.",
            ];

            function init() {
                setupEventListeners();
                checkAuthAndLoadApiSettings();
                loadUserPreferences();
            }

            function setupEventListeners() {
                DOM.openFileBtn.addEventListener('click', () => DOM.fileInput.click());
                DOM.fileInput.addEventListener('change', handleFileSelected);
                DOM.processTextBtn.addEventListener('click', processInputText);
                DOM.exampleBookBtn.addEventListener('click', downloadExampleBook); // Restore listener
                DOM.toggleTextInput.addEventListener('click', (e) => {
                    e.preventDefault();
                    DOM.textInputContainer.style.display = DOM.textInputContainer.style.display === 'none' ? 'block' : 'none';
                });
                DOM.processUrlBtn.addEventListener('click', processUrlInput);

                DOM.tocBtn.addEventListener('click', toggleTocPanel);
                DOM.closeTocBtn.addEventListener('click', closeTocPanel);
                DOM.settingsBtn.addEventListener('click', toggleSettingsPanel);
                DOM.chatBtn.addEventListener('click', toggleChatPanel);
                DOM.homeBtn.addEventListener('click', goToHome);
                DOM.overlay.addEventListener('click', closeAllPanels);
                DOM.closeChatBtn.addEventListener('click', closeChatPanel);
                DOM.prevBtn.addEventListener('click', goToPrevious);
                DOM.nextBtn.addEventListener('click', goToNext);

                DOM.contentArea.addEventListener('click', handleContentClick);
                DOM.contentArea.addEventListener('scroll', debounce(updateProgressBar, 100));
                DOM.contentArea.addEventListener('touchstart', handleTouchStart);
                DOM.contentArea.addEventListener('touchend', handleTouchEnd);

                DOM.fontDecreaseBtn.addEventListener('click', () => { decreaseFontSize(); saveUserPreferences(); });
                DOM.fontIncreaseBtn.addEventListener('click', () => { increaseFontSize(); saveUserPreferences(); });
                DOM.lineHeightDecreaseBtn.addEventListener('click', () => { decreaseLineHeight(); saveUserPreferences(); });
                DOM.lineHeightIncreaseBtn.addEventListener('click', () => { increaseLineHeight(); saveUserPreferences(); });

                DOM.themeOptions.forEach(option => {
                    option.addEventListener('click', () => { setTheme(option.getAttribute('data-theme'));
saveUserPreferences(); });
                });

                // Renamed toggle listener
                DOM.viewRawHtmlToggle.addEventListener('change', function() {
                    state.settings.viewRawHtmlEnabled = this.checked;
                    displayCurrentChapter();
                    saveUserPreferences();
                });

                DOM.translationToggle.addEventListener('change', function() { localStorage.setItem('translation-enabled', this.checked); saveUserPreferences(); });
                DOM.autoSpeakToggle.addEventListener('change', function() { localStorage.setItem('auto-speak-enabled', this.checked); saveUserPreferences(); });
                DOM.speakSelectionToggle.addEventListener('change', function() { state.settings.speakSelectionEnabled = this.checked; localStorage.setItem('speak-selection-enabled', this.checked); saveUserPreferences(); });
                DOM.speechLanguage.addEventListener('change', function() { localStorage.setItem('speech-language', this.value); saveUserPreferences(); });

                document.addEventListener('selectionchange', handleTextSelection);
                DOM.loginBtn.addEventListener('click', () => { window.open('index.html', '_blank'); });

                DOM.listBadgeContainer.addEventListener('click', handleListBadgeClick);
                DOM.createListBtn.addEventListener('click', toggleCreateListInput);

                DOM.aiCleanupBtn.addEventListener('click', showAiCleanupModal);
                DOM.aiCleanupCloseBtn.addEventListener('click', hideAiCleanupModal);
                DOM.aiCleanupCancelBtn.addEventListener('click', hideAiCleanupModal);
                DOM.aiCleanupConfirmBtn.addEventListener('click', handleAiCleanupConfirm);
                DOM.aiCleanupBackdrop.addEventListener('click', hideAiCleanupModal);

                document.addEventListener('keydown', handleKeyPress);
                document.addEventListener('selectionchange', debounce(handleTextSelection, 300));
                document.addEventListener('click', handleGlobalClick);

                DOM.chatSendBtn.addEventListener('click', handleSendMessage);
                DOM.chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } });
                DOM.chatClearBtn.addEventListener('click', clearChat);
                DOM.chatFullDocToggle.addEventListener('change', (e) => {
                    state.chatUseFullDocument = e.target.checked;
                    showToast(`Chat context set to: ${state.chatUseFullDocument ? 'Full Document' : 'Current Chapter'}`, 2000);
                });
                DOM.chatSuggestions.addEventListener('click', handleSuggestionClick);

                // Add listener for Summarize button
                DOM.summarizeChapterBtn.addEventListener('click', summarizeCurrentChapter);
            }

            // Function to handle downloading the example book (restored)
            function downloadExampleBook() {
                // This function is intentionally simple.
                // The link itself handles the download via the href attribute.
                // We might add tracking or other logic here in the future if needed.
                console.log('Example book link clicked.');
                // No need to prevent default as it's a standard link.
            }

             function handleGlobalClick(event) {
                 const openDropdowns = document.querySelectorAll('.move-list-dropdown.visible');
                 openDropdowns.forEach(dropdown => {
                     const moveButton = dropdown.closest('.library-item-actions')?.querySelector('.library-item-move');
                     if (moveButton && !dropdown.contains(event.target) && !moveButton.contains(event.target)) {
                         dropdown.classList.remove('visible');
                     }
                 });

                 if (state.isCreatingList && !DOM.createListGroup.contains(event.target)) {
                     if (!DOM.createListBtn.contains(event.target)) {
                         cancelListCreation();
                     }
                 }

                 if (DOM.chatPanel.classList.contains('visible') && !DOM.chatPanel.contains(event.target) && !DOM.chatBtn.contains(event.target)) { closeChatPanel(); }
                 if (DOM.settingsPanel.classList.contains('visible') && !DOM.settingsPanel.contains(event.target) && !DOM.settingsBtn.contains(event.target)) { closeSettingsPanel(); }
                 if (DOM.tocPanel.classList.contains('visible') && !DOM.tocPanel.contains(event.target) && !DOM.tocBtn.contains(event.target)) { closeTocPanel(); }
             }

            function handleKeyPress(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.key === 'ArrowLeft' && e.altKey) { goToPrevious(); e.preventDefault(); }
                if (e.key === 'ArrowRight' && e.altKey) { goToNext(); e.preventDefault(); }

                if (e.key === 'Escape') {
                    if (state.isCreatingList) { cancelListCreation(); }
                    else if (state.isAiCleanupModalOpen) { hideAiCleanupModal(); }
                    else { closeAllPanels(); }
                    e.preventDefault();
                }

                if (e.key === 'Enter' && state.isCreatingList && e.target === DOM.newListNameInput) { handleCreateList(); e.preventDefault(); }
                if (e.key === 't' && !e.ctrlKey && !e.metaKey) { toggleTocPanel(); e.preventDefault(); }
                if (e.key === 's' && !e.ctrlKey && !e.metaKey) { toggleSettingsPanel(); e.preventDefault(); }
                if (e.key === 'h' && !e.ctrlKey && !e.metaKey) { goToHome(); e.preventDefault(); }
                if ((e.key === '+' || e.key === '=') && (e.ctrlKey || e.metaKey)) { increaseFontSize(); saveUserPreferences(); e.preventDefault(); }
                if (e.key === '-' && (e.ctrlKey || e.metaKey)) { decreaseFontSize(); saveUserPreferences(); e.preventDefault(); }
                if (e.key === 'c' && !e.ctrlKey && !e.metaKey && DOM.readerContainer.offsetParent !== null) { toggleChatPanel(); e.preventDefault(); }
            }

            function handleTouchStart(e) { state.touchStartY = e.touches[0].clientY; }
            function handleTouchEnd(e) {
                state.touchEndY = e.changedTouches[0].clientY;
                const distance = state.touchStartY - state.touchEndY;
                if (distance < -50 && DOM.contentArea.scrollTop <= 0) { toggleNavbar(); }
            }

            function handleFileSelected() {
                const file = DOM.fileInput.files[0];
                if (!file) return;
                showLoading();
                DOM.bookTitle.textContent = file.name;
                state.bookData.title = file.name;
                state.bookData.currentListId = null;
                const fileExtension = file.name.split('.').pop().toLowerCase();
                if (fileExtension === 'txt') { processTextFile(file); }
                else if (fileExtension === 'epub') { processEpubFile(file); }
                else if (fileExtension === 'pdf') { processPdfFile(file); }
                else { hideLoading(); showToast('Unsupported file format'); }
            }

            function processInputText() {
                const text = DOM.textInput.value.trim();
                if (!text) { showToast('Please enter some text'); return; }
                showLoading();
                let customTitle = DOM.textInputTitle.value.trim() || text.substring(0, 20).trim() + (text.length > 20 ? '...' : '');
                DOM.bookTitle.textContent = customTitle;
                state.bookData.title = customTitle;
                state.bookData.currentListId = null;
                try {
                    state.bookData.content = text;
                    state.bookData.chapters = [{ title: customTitle, content: text, startLine: 0, endLine: text.split('\n').length }];
                    showBook();
                } catch (error) { console.error('Error processing input text:', error); showToast('Error processing text'); }
                finally { hideLoading(); }
            }

            function processTextFile(file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        state.bookData.content = text;
                        const lines = text.split('\n');
                        let chapters = [];
                        let chapterMarkers = [];
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if ((line === '' || i === 0) && i < lines.length - 1) {
                                const nextLine = lines[i+1].trim();
                                if (nextLine.match(/^(Chapter|CHAPTER|\bPart\b|\bSection\b|[IVXLCDM]+\.?)/)) {
                                    chapterMarkers.push(i === 0 ? 0 : i+1);
                                }
                            }
                        }
                        if (chapterMarkers.length <= 1) { for (let i = 0; i < lines.length; i += 1000) { chapterMarkers.push(i); } }
                        for (let i = 0; i < chapterMarkers.length; i++) {
                            const start = chapterMarkers[i];
                            const end = i < chapterMarkers.length - 1 ? chapterMarkers[i+1] : lines.length;
                            const chapterContent = lines.slice(start, end).join('\n');
                            let title = `Chapter ${i+1}`;
                            if (lines[start] && lines[start].trim()) { title = lines[start].trim().substring(0, 47) + (lines[start].trim().length > 50 ? '...' : ''); }
                            chapters.push({ title: title, content: chapterContent, startLine: start, endLine: end });
                        }
                        state.bookData.chapters = chapters;
                        showBook();
                    } catch (error) { console.error('Error processing text file:', error); showToast('Error processing file'); }
                    finally { hideLoading(); }
                };
                reader.onerror = function(error) { console.error('Error reading file:', error); hideLoading(); showToast('Error reading file'); };
                reader.readAsText(file);
            }

            function processEpubFile(file) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const arrayBuffer = e.target.result;
                        if (typeof JSZip === 'undefined') { await loadExternalScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'); }
                        await extractEpubContent(arrayBuffer);
                    } catch (error) { console.error('Error processing EPUB:', error); hideLoading(); showToast('Error processing EPUB file'); }
                };
                reader.onerror = function(error) { console.error('Error reading EPUB file:', error); hideLoading(); showToast('Error reading EPUB file'); };
                reader.readAsArrayBuffer(file);
            }

            async function loadExternalScript(url) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = url;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
                    document.head.appendChild(script);
                });
            }

            async function extractEpubContent(arrayBuffer) {
                try {
                    const jszip = new JSZip();
                    const zip = await jszip.loadAsync(arrayBuffer);
                    const containerXml = await zip.file('META-INF/container.xml').async('text');
                    const parser = new DOMParser();
                    const containerDoc = parser.parseFromString(containerXml, 'application/xml');
                    const rootFile = containerDoc.querySelector('rootfile');
                    if (!rootFile) throw new Error('Invalid EPUB: container.xml doesn\'t contain a rootfile');
                    const rootFilePath = rootFile.getAttribute('full-path');
                    const rootDir = rootFilePath.substring(0, rootFilePath.lastIndexOf('/') + 1) || '';
                    const opfContent = await zip.file(rootFilePath).async('text');
                    const opfDoc = parser.parseFromString(opfContent, 'application/xml');
                    const metadataElem = opfDoc.querySelector('metadata');
                    if (metadataElem) {
                        const titleElem = metadataElem.querySelector('dc\\:title, title');
                        if (titleElem && titleElem.textContent) { state.bookData.title = titleElem.textContent.trim(); DOM.bookTitle.textContent = state.bookData.title; }
                    }
                    const spine = opfDoc.querySelector('spine');
                    const manifest = opfDoc.querySelector('manifest');
                    if (!spine || !manifest) throw new Error('Invalid EPUB: missing spine or manifest');
                    const manifestItems = {};
                    manifest.querySelectorAll('item').forEach(item => { manifestItems[item.getAttribute('id')] = { href: item.getAttribute('href'), mediaType: item.getAttribute('media-type') }; });
                    const spineItems = [];
                    spine.querySelectorAll('itemref').forEach(itemref => {
                        const idref = itemref.getAttribute('idref');
                        if (manifestItems[idref] && manifestItems[idref].mediaType.includes('html')) { spineItems.push({ id: idref, href: manifestItems[idref].href }); }
                    });
                    const contentPromises = spineItems.map(item => {
                        const fullPath = rootDir + item.href;
                        return zip.file(fullPath).async('text').then(content => ({ id: item.id, content, href: item.href })).catch(error => { console.error(`Error loading ${fullPath}:`, error); return { id: item.id, content: `[Error loading content: ${error.message}]`, href: item.href }; });
                    });
                    const chaptersContent = await Promise.all(contentPromises);
                    state.bookData.chapters = [];
                    chaptersContent.forEach((chapter, index) => {
                        const htmlDoc = parser.parseFromString(chapter.content, 'text/html');
                        let title = `Chapter ${index + 1}`;
                        const headingElements = htmlDoc.querySelectorAll('h1, h2, h3, h4');
                        if (headingElements.length > 0) { title = headingElements[0].textContent.trim(); }
                        else { const filename = chapter.href.split('/').pop().replace(/\.[^/.]+$/, ""); if (filename && !filename.startsWith('chapter') && !/^\d+$/.test(filename)) { title = filename.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase()); } }
                        let textContent = '';
                        const contentElements = htmlDoc.querySelectorAll('body *');
                        contentElements.forEach(element => {
                            if (element.tagName === 'SCRIPT' || element.tagName === 'STYLE') return;
                            if (element.tagName.match(/^H[1-6]$/)) { if (element.textContent.trim()) textContent += element.textContent.trim() + '\n\n'; }
                            else if (element.tagName === 'P') { if (element.textContent.trim()) textContent += element.textContent.trim() + '\n\n'; }
                            else if (element.tagName === 'BR') { textContent += '\n'; }
                            else if (element.tagName === 'HR') { textContent += '\n* * *\n\n'; }
                            else if (element.tagName === 'BLOCKQUOTE') { if (element.textContent.trim()) textContent += '> ' + element.textContent.trim().replace(/\n/g, '\n> ') + '\n\n'; }
                            else if (element.tagName === 'UL' || element.tagName === 'OL') { const listItems = element.querySelectorAll('li'); listItems.forEach((li, liIndex) => { const prefix = element.tagName === 'OL' ? `${liIndex + 1}. ` : '- '; if (li.textContent.trim()) textContent += prefix + li.textContent.trim() + '\n'; }); textContent += '\n'; }
                            else if (element.tagName === 'DIV' && element.children.length === 0 && element.textContent.trim()) { textContent += element.textContent.trim() + '\n\n'; }
                        });
                        if (textContent.trim() === '') { const body = htmlDoc.querySelector('body'); if (body) { textContent = body.textContent.trim().replace(/\s+/g, ' ').replace(/\.\s+/g, '.\n\n'); } }
                        textContent = textContent.replace(/\n{3,}/g, '\n\n');
                        state.bookData.chapters.push({ title: title, content: textContent, startLine: 0, endLine: textContent.split('\n').length });
                    });
                    if (state.bookData.chapters.length === 0) { state.bookData.chapters.push({ title: state.bookData.title || 'Content', content: "Could not extract readable content from this EPUB file.", startLine: 0, endLine: 1 }); }
                    showBook();
                    hideLoading();
                } catch (error) { console.error('Error extracting EPUB content:', error); hideLoading(); showToast('Error processing EPUB file'); }
            }

            function processPdfFile(file) {
                const reader = new FileReader();
                reader.onload = function() {
                    showToast('PDF support is limited. For a better experience, use a dedicated PDF reader app.');
                    state.bookData.chapters = [{ title: state.bookData.title || 'PDF Content', content: "PDF content extraction is limited in this simple reader.\n\nFor a better experience with PDFs, consider using a dedicated PDF reader app.", startLine: 0, endLine: 2 }];
                    showBook();
                    hideLoading();
                };
                reader.onerror = function(error) { console.error('Error reading PDF file:', error); hideLoading(); showToast('Error reading PDF file'); };
                reader.readAsArrayBuffer(file);
            }

            async function firecrawlScrapeRequest(apiKey, url) {
                console.log('Attempting to scrape URL:', url);
                try {
                    const response = await fetch('https://api.firecrawl.dev/v0/scrape', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({
                             url: url,
                             pageOptions: { onlyMainContent: false },
                             extractorOptions: { extractionSchema: 'markdown' }
                         })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `Firecrawl API request failed with status ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Error calling Firecrawl API:', error);
                    console.error('Error details during Firecrawl API call:', error);
                    return { error: { message: error.message || 'Failed to connect to Firecrawl API' } };
                }
            }

            async function processUrlInput() {
                const url = DOM.urlInput.value.trim();
                if (!url || !url.startsWith('http')) { showToast('Please enter a valid URL'); return; }
                if (!state.userApiSettings || !state.userApiSettings.firecrawl_api_key) { showToast('Firecrawl API key not configured. Please set it up in the main dashboard.'); return; }

                const defaultModel = 'gemini-2.0-flash-thinking-exp-01-21';
                const fallbackModels = ['gemini-2.0-flash'];
                let modelUsedForCleaning = defaultModel;
                let modelUsedForTitle = defaultModel;

                DOM.processUrlBtn.classList.add('loading');
                DOM.processUrlBtn.disabled = true;
                DOM.bookTitle.textContent = `Reading: ${url}`;
                state.bookData.title = url;
                state.bookData.currentListId = null;

                try {
                    const response = await firecrawlScrapeRequest(state.userApiSettings.firecrawl_api_key, url);
                    if (response.error) throw new Error(response.error.message);
                    if (!response.data || !response.data.markdown) console.warn('No markdown content received from Firecrawl. Title generation might be less accurate.');

                    const rawMarkdownContent = response.data.markdown || '';
                    state.bookData.rawContent = rawMarkdownContent;
                    state.bookData.content = rawMarkdownContent;

                    showToast('Generating title & category with AI...', 3000);
                    let titleCategoryResult = { generatedTitle: null, listId: null };
                    modelUsedForTitle = defaultModel;

                    if (state.bookData.content) {
                        try {
                            titleCategoryResult = await generateTitleAndCategory(state.bookData.content, modelUsedForTitle);
                            showToast(`Title/Category generated (Model: ${modelUsedForTitle}).`, 2000);
                        } catch (error) {
                            console.warn(`Model ${modelUsedForTitle} failed for title/category: ${error.message}. Trying fallbacks...`);
                            showToast(`Model ${modelUsedForTitle} failed title/cat. Trying fallbacks...`, 2500);
                            for (const fallback of fallbackModels) {
                                try {
                                    modelUsedForTitle = fallback;
                                    titleCategoryResult = await generateTitleAndCategory(state.bookData.content, modelUsedForTitle);
                                    console.log(`Fallback model ${modelUsedForTitle} succeeded for title/category.`);
                                    showToast(`Title/Category generated (Fallback: ${modelUsedForTitle}).`, 2000);
                                    break;
                                } catch (fallbackError) { console.warn(`Fallback model ${modelUsedForTitle} failed for title/category: ${fallbackError.message}`); }
                            }
                        }
                    } else {
                        showToast('Skipping AI title/category generation (no markdown content).', 2000);
                    }

                    const { generatedTitle, listId } = titleCategoryResult;
                    if (generatedTitle) { state.bookData.title = generatedTitle; DOM.bookTitle.textContent = state.bookData.title; showToast(`AI generated title: "${generatedTitle}"`, 3000); }
                    else { if (response.data.metadata && response.data.metadata.title) { state.bookData.title = response.data.metadata.title; DOM.bookTitle.textContent = state.bookData.title; } showToast('Could not generate AI title, using default.', 2000); }

                    state.bookData.currentListId = listId;
                    if (listId !== null) { const listName = state.bookLists.find(l => l.id === listId)?.name || 'Unknown List'; showToast(`Categorized into: "${listName}"`, 3000); console.log("Categorized into: ", listName); }
                    else { showToast('Categorized as Unlisted.', 2000); console.log("Categorized as Unlisted: ", listId); }

                    // Chapter content now primarily uses markdownContent
                    let chapters = [{ title: state.bookData.title || 'Content', markdownContent: state.bookData.content, content: response.data.content /* Store raw HTML here */, startLine: 0, endLine: 1 }];
                    state.bookData.chapters = chapters;
                    // state.settings.preferHtmlView = false; // Removed
                    // DOM.preferHtmlViewToggle.checked = false; // Removed
                    state.settings.viewRawHtmlEnabled = false; // Default to Markdown view
                    DOM.viewRawHtmlToggle.checked = false;
                    state.bookData.sourceUrl = url;
                    state.bookData.rawContent = response.data.content; // Store raw HTML in rawContent
                    showBook();
                } catch (error) { console.error('Error processing URL:', error); showToast(`Error reading URL: ${error.message}`); goToHome(); }
                finally { DOM.urlInput.value = ''; DOM.processUrlBtn.classList.remove('loading'); DOM.processUrlBtn.disabled = false; hideLoading(); }
            }

            async function scrapeAndSaveLink(url) {
                if (!state.userApiSettings || !state.userApiSettings.firecrawl_api_key) { showToast('Firecrawl API key needed to scrape. Configure in dashboard.', 4000); return; }
                // Optional: Check for Gemini key if cleaning is desired (Note: cleanUrlContentToggle removed)
                // const canClean = state.userApiSettings.api_key; // Simplified check
                // if (canClean && !state.userApiSettings.api_key) { showToast('Gemini API key needed for cleaning. Scraping raw content.', 3000); }

                showToast(`Scraping "${url}"...`, 2000);
                try {
                    const response = await firecrawlScrapeRequest(state.userApiSettings.firecrawl_api_key, url);
                    if (response.error) throw new Error(response.error.message || 'Firecrawl request failed');
                    if (!response.data || !response.data.markdown) throw new Error('No content received from Firecrawl.');

                    const rawHtmlContent = response.data.content;
                    const markdownContent = response.data.markdown || '';
                    const scrapedTitle = (response.data.metadata && response.data.metadata.title) || url;

                    const scrapedBookData = {
                        title: scrapedTitle,
                        content: null, // Content field no longer primary for URLs
                        raw_content: rawHtmlContent, // Store raw HTML
                        file_type: 'url',
                        // Metadata: Store both, default viewRawHtmlEnabled to false (show Markdown)
                        metadata: {
                            chapters: [{ title: 'Content', content: rawHtmlContent, markdownContent: markdownContent, startLine: 0, endLine: 1 }],
                            // preferHtmlView: true, // Removed
                            viewRawHtmlEnabled: false, // Default to Markdown view
                            sourceUrl: url // Store source URL in metadata
                        },
                        last_position: { chapter: 0, percentComplete: 0, scroll: 0, timestamp: new Date().getTime() }
                    };
                    await saveScrapedBook(scrapedBookData, state.bookData.currentListId);
                } catch (error) { console.error('Error scraping and saving link:', error); showToast(`Error scraping "${url}": ${error.message}`, 5000); }
            }

            async function saveScrapedBook(scrapedBookData, targetListId = null) {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) { console.error('Cannot save scraped book: User not logged in.'); showToast('Please sign in to save scraped content.', 4000); return false; }
                try {
                    const { error } = await supabase.from('ebooks').insert({
                        user_id: session.user.id, title: scrapedBookData.title, content: null, raw_content: scrapedBookData.raw_content, file_type: scrapedBookData.file_type, metadata: scrapedBookData.metadata, last_position: scrapedBookData.last_position, list_id: targetListId
                    });
                    if (error) { if (error.code === '23505') { console.warn(`Book with title "${scrapedBookData.title}" already exists. Skipping save.`); showToast(`Book "${scrapedBookData.title}" already in library.`, 3000); return true; } else { throw error; } }
                    console.log(`Successfully saved scraped book: "${scrapedBookData.title}"`);
                    showToast(`"${scrapedBookData.title}" saved to library!`, 3000);
                    if (DOM.welcomeScreen.style.display !== 'none') { loadUserLibrary(); }
                    return true;
                } catch (error) { console.error('Error saving scraped book to Supabase:', error); showToast(`Failed to save "${scrapedBookData.title}" to library. DB Error.`, 4000); return false; }
            }

            function showLinkActionConfirmation(url, linkText) {
                const existingToast = document.querySelector('.link-action-toast');
                if (existingToast) existingToast.remove();
                const toast = document.createElement('div');
                toast.className = 'link-action-toast';
                toast.innerHTML = `
                    <div class="link-action-header"><span>Action for Link:</span><button type="button" class="link-action-close-btn" aria-label="Close">×</button></div>
                    <div class="link-action-url" title="Clicked link text">${escapeHTML(linkText)}</div>
                    <div class="link-action-target-url" title="Target URL">URL: ${escapeHTML(url)}</div>
                    <div class="link-action-buttons"><button type="button" class="link-action-btn open">Open Link</button><button type="button" class="link-action-btn scrape">Scrape & Save</button></div>`;
                document.body.appendChild(toast);
                const closeBtn = toast.querySelector('.link-action-close-btn');
                const openBtn = toast.querySelector('.link-action-btn.open');
                const scrapeBtn = toast.querySelector('.link-action-btn.scrape');
                const removeToast = () => { toast.classList.remove('visible'); setTimeout(() => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, 300); };
                closeBtn.addEventListener('click', removeToast);
                openBtn.addEventListener('click', () => { window.open(url, '_blank', 'noopener noreferrer'); removeToast(); });
                scrapeBtn.addEventListener('click', () => { scrapeAndSaveLink(url); removeToast(); });
                requestAnimationFrame(() => { toast.classList.add('visible'); });
                setTimeout(removeToast, 15000);
            }

            function renderSuggestedQuestions(questions = []) {
                DOM.chatSuggestions.innerHTML = '';
                if (questions && questions.length > 0) {
                    DOM.chatSuggestions.style.display = 'flex';
                    questions.forEach(question => {
                        const chip = document.createElement('button');
                        chip.className = 'suggestion-chip';
                        chip.textContent = question;
                        chip.type = 'button';
                        DOM.chatSuggestions.appendChild(chip);
                    });
                } else {
                    DOM.chatSuggestions.style.display = 'none';
                }
            }

            function handleSuggestionClick(event) {
                const clickedChip = event.target.closest('.suggestion-chip');
                if (!clickedChip) return;
                sendSuggestedQuestion(clickedChip.textContent);
            }

            function sendSuggestedQuestion(question) {
                if (!state.userApiSettings || !state.userApiSettings.api_key) { displayChatMessage('assistant', 'Sorry, the Gemini API key is not configured. Please set it up in the main dashboard.'); return; }
                displayChatMessage('user', question);
                state.chatHistory.push({ role: 'user', parts: [{ text: question }] });
                const loadingElement = displayChatMessage('assistant', '', true);
                DOM.chatSendBtn.disabled = true;
                processAndSendChat(question, loadingElement);
            }

            function showBook() {
                DOM.welcomeScreen.style.display = 'none';
                displayCurrentChapter();
                DOM.navbar.classList.add('visible');
                clearTimeout(state.navbarHideTimer);
                state.navbarHideTimer = setTimeout(() => { DOM.navbar.classList.remove('visible'); }, 3000);
                populateToc();
                saveBookToLibrary();
            }

            function displayCurrentChapter() {
                const chapter = state.bookData.chapters[state.bookData.currentPosition];
                if (!chapter) return;
                DOM.contentArea.innerHTML = ''; // Clear previous content

                // Update chapter title in navbar, making it clickable if sourceUrl exists
                const chapterTitleText = `${state.bookData.title || 'Book'} - ${chapter.title}`;
                if (state.bookData.sourceUrl) { DOM.bookTitle.innerHTML = `<a href="${escapeHTML(state.bookData.sourceUrl)}" target="_blank" rel="noopener noreferrer" title="Open Source URL" style="color: var(--primary-color);
text-decoration: none;">${escapeHTML(chapterTitleText)}</a>`; DOM.bookTitle.style.cursor = 'pointer'; }
                else { DOM.bookTitle.innerHTML = escapeHTML(chapterTitleText); DOM.bookTitle.style.cursor = 'default'; }

                // Update check for renamed toggle and state property
                DOM.viewRawHtmlToggle.disabled = !state.bookData.rawContent;
                DOM.viewRawHtmlToggle.closest('.settings-row').title = !state.bookData.rawContent ? "Raw HTML view only available for books added via URL or EPUB." : "View the original scraped/extracted HTML content.";

                // Updated logic: Show raw HTML if toggle is checked AND raw content exists
                if (state.settings.viewRawHtmlEnabled && state.bookData.rawContent) {
                    const pre = document.createElement('pre');
                    pre.style.whiteSpace = 'pre-wrap'; // Keep existing style
                    pre.style.wordBreak = 'break-word'; // Use break-word for better readability
                    pre.textContent = state.bookData.rawContent;
                    DOM.contentArea.appendChild(pre);
                    DOM.contentArea.style.fontSize = 'inherit'; // Keep raw view unstyled by reader settings
                    DOM.contentArea.style.lineHeight = 'inherit'; // Keep raw view unstyled
                    DOM.contentArea.style.fontFamily = 'monospace'; // Use monospace for raw view

                } else if (typeof chapter.markdownContent === 'string' && chapter.markdownContent.trim() !== '') {
                    // Render Markdown if it exists and is not empty
                    DOM.contentArea.innerHTML = marked.parse(chapter.markdownContent);
                    DOM.contentArea.style.fontFamily = 'inherit'; // Reset font family for reader view
                    // Add data-p-index to paragraphs generated by marked.js for text anchor restoration
                    DOM.contentArea.querySelectorAll('p').forEach((p, index) => {
                        p.setAttribute('data-p-index', index);
                    });
                    // Apply reader styles AFTER content is set
                    DOM.contentArea.style.fontSize = `${state.settings.fontSize}%`;
                    DOM.contentArea.style.lineHeight = state.settings.lineHeight;
                } else if (typeof chapter.content === 'string' && chapter.content.trim() !== '') {
                     // Fallback: Render older HTML content if Markdown is missing
                     // Note: This might be less styled than Markdown
                     DOM.contentArea.innerHTML = chapter.content;
                     DOM.contentArea.style.fontFamily = 'inherit'; // Reset font family
                     // Apply reader styles
                     DOM.contentArea.style.fontSize = `${state.settings.fontSize}%`;
                     DOM.contentArea.style.lineHeight = state.settings.lineHeight;
                     console.warn("Displayed chapter using older 'content' field (HTML). Markdown was missing.");
                 } else {
                    // Ultimate fallback if no content available
                    DOM.contentArea.innerHTML = '<p>Content not available for this chapter.</p>';
                    DOM.contentArea.style.fontFamily = 'inherit'; // Reset font family
                    // Apply reader styles even for fallback
                    DOM.contentArea.style.fontSize = `${state.settings.fontSize}%`;
                    DOM.contentArea.style.lineHeight = state.settings.lineHeight;
                }

                DOM.contentArea.scrollTop = 0;
                updateNavigationButtonsState();
                updateProgressBar();

                if (state.bookData.sourceUrl) { DOM.sourceUrlContentLink.href = state.bookData.sourceUrl;
DOM.sourceUrlContentLink.textContent = state.bookData.sourceUrl; DOM.sourceUrlDisplay.style.display = 'block'; }
                else { DOM.sourceUrlDisplay.style.display = 'none'; }
            }

            function populateToc() {
                DOM.tocContent.innerHTML = '';
                state.bookData.chapters.forEach((chapter, index) => {
                    const item = document.createElement('div');
                    item.className = 'toc-item';
                    item.textContent = chapter.title;
                    item.setAttribute('data-index', index);
                    if (index === state.bookData.currentPosition) item.classList.add('toc-active');
                    item.addEventListener('click', () => { state.bookData.currentPosition = index;
displayCurrentChapter(); closeTocPanel(); saveBookToLibrary(); });
                    DOM.tocContent.appendChild(item);
                });
            }

            function updateNavigationButtonsState() {
                DOM.prevBtn.style.opacity = state.bookData.currentPosition <= 0 ? '0.5' : '1';
                DOM.prevBtn.style.pointerEvents = state.bookData.currentPosition <= 0 ? 'none' : 'auto';
                DOM.nextBtn.style.opacity = state.bookData.currentPosition >= state.bookData.chapters.length - 1 ? '0.5' : '1';
                DOM.nextBtn.style.pointerEvents = state.bookData.currentPosition >= state.bookData.chapters.length - 1 ? 'none' : 'auto';
            }

            function goToPrevious() { if (state.bookData.currentPosition > 0) { state.bookData.currentPosition--; displayCurrentChapter(); saveBookToLibrary(); } }
            function goToNext() { if (state.bookData.currentPosition < state.bookData.chapters.length - 1) { state.bookData.currentPosition++; displayCurrentChapter(); saveBookToLibrary(); } }

            function toggleNavbar() {
                DOM.navbar.classList.toggle('visible');
                if (DOM.navbar.classList.contains('visible')) { clearTimeout(state.navbarHideTimer);
state.navbarHideTimer = setTimeout(() => { DOM.navbar.classList.remove('visible'); }, 3000); }
            }

            function toggleTocPanel() {
                DOM.tocPanel.classList.toggle('visible');
                DOM.overlay.classList.toggle('visible');
                DOM.settingsPanel.classList.remove('visible');
                if (DOM.tocPanel.classList.contains('visible')) {
                    const activeItem = DOM.tocContent.querySelector(`.toc-item[data-index="${state.bookData.currentPosition}"]`);
                    if (activeItem) { setTimeout(() => { activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' }); }, 100); }
                }
            }
            function closeTocPanel() { DOM.tocPanel.classList.remove('visible'); DOM.overlay.classList.remove('visible'); }

            function toggleSettingsPanel() { DOM.settingsPanel.classList.toggle('visible'); DOM.overlay.classList.toggle('visible'); DOM.tocPanel.classList.remove('visible'); }
            function closeSettingsPanel() { DOM.settingsPanel.classList.remove('visible'); DOM.overlay.classList.remove('visible'); }

            function closeAllPanels() { DOM.tocPanel.classList.remove('visible'); DOM.settingsPanel.classList.remove('visible'); DOM.chatPanel.classList.remove('visible'); DOM.overlay.classList.remove('visible');
renderSuggestedQuestions([]); }

            function showAiCleanupModal() {
                if (!state.session) { showToast("Please sign in to use AI features.", 3000); return; }
                if (!state.userApiSettings || !state.userApiSettings.api_key) { showToast("Gemini API key needed for AI Cleanup. Configure in dashboard.", 4000); return; }
                DOM.aiCleanupList.innerHTML = '<p>Loading suggestions...</p>';
                DOM.aiCleanupModal.classList.add('visible');
                DOM.aiCleanupBackdrop.classList.add('visible');
                state.isAiCleanupModalOpen = true;
                DOM.aiCleanupConfirmBtn.disabled = true;
                DOM.aiCleanupConfirmBtn.classList.add('loading');
                fetchAllUserBooks()
                    .then(allBooks => {
                        if (!allBooks || allBooks.length === 0) { DOM.aiCleanupList.innerHTML = '<p>Your library is empty. Nothing to clean up!</p>'; DOM.aiCleanupConfirmBtn.disabled = true;
DOM.aiCleanupConfirmBtn.classList.remove('loading'); return; }
                        return generateCleanupSuggestions(allBooks);
                    })
                    .then(suggestedBooks => { if (suggestedBooks) populateAiCleanupModal(suggestedBooks); })
                    .catch(error => { console.error("Error during AI Cleanup:", error); DOM.aiCleanupList.innerHTML = `<p>Error generating suggestions: ${error.message}</p>`; DOM.aiCleanupConfirmBtn.disabled = true;
DOM.aiCleanupConfirmBtn.classList.remove('loading'); });
            }

            function hideAiCleanupModal() { DOM.aiCleanupModal.classList.remove('visible'); DOM.aiCleanupBackdrop.classList.remove('visible'); state.isAiCleanupModalOpen = false; }

            async function fetchAllUserBooks() {
                if (!state.session) return [];
                try {
                    const { data: books, error } = await supabase.from('ebooks').select('id, title, file_type, metadata, last_position, updated_at').eq('user_id', state.session.user.id).order('updated_at', { ascending: true });
                    if (error) throw error;
                    return books || [];
                } catch (error) { console.error("Error fetching all user books:", error); showToast("Could not fetch library for cleanup.", 3000); return []; }
            }

            async function generateCleanupSuggestions(books) {
                const today = new Date().toISOString().split('T')[0];
                const bookDataForPrompt = books.map(book => ({ id: book.id, title: book.title.substring(0, 80), progress: calculateOverallProgress(book), last_read: book.last_position?.timestamp ? new Date(book.last_position.timestamp).toISOString().split('T')[0] : new Date(book.updated_at).toISOString().split('T')[0] }));
                const maxBooksInPrompt = 150;
                const booksToSend = bookDataForPrompt.slice(0, maxBooksInPrompt);
                const prompt = `Analyze the following list of ebooks from a user's library. Identify books that are strong candidates for deletion based on these criteria:\n\nToday's date is: ${today}\n\n1.  **Old & Unread:** Books last read over 1 year ago (before ${today.substring(0, 4)}-${today.substring(5, 7)}-${today.substring(8)}) AND have less than 5% progress.\n2.  **Fully Read:** Books with 98% or more progress.\n3.  **Likely Test/Temporary Items:** Books with very short titles (e.g., "test", "untitled", "url", or just a raw URL) that haven't been read recently (e.g., last read > 3 months ago).\n4.  **Duplicates:** Books with identical or very similar titles where one has significantly less progress or hasn't been read for much longer. Prioritize keeping the one with more progress or more recent activity.\n5.  **Old News:** Books whose titles clearly indicate they are news articles (e.g., contain "News", "Daily", "Update") and were last read more than 1 week ago (before ${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}).\n\n**Constraint:** Do NOT suggest deleting items last read within the last 7 days (i.e., on or after ${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}), regardless of other criteria, unless they are clearly fully read (>=98% progress).\n\nHere is the list of books (id, title, progress percentage, last read date YYYY-MM-DD):\n---\n${JSON.stringify(booksToSend, null, 2)}\n---\n\nReturn ONLY a JSON array containing the integer IDs of the books you suggest for deletion based *strictly* on the criteria above. Do not include any explanations or other text. Ensure the constraint about recent items is respected.\n\nExample Output: [123, 456, 789]\n\nJSON Output:`;
                try {
                    const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, state.userApiSettings.model);
                    if (response.error) throw new Error(response.error.message);
                    const resultText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '[]';
                    let suggestedIds = [];
                    try {
                        const jsonMatch = resultText.match(/\[[\s\S]*\]/);
                        if (jsonMatch) { suggestedIds = JSON.parse(jsonMatch[0]).map(id => Number(id)).filter(id => !isNaN(id)); }
                        else { console.warn("AI did not return a valid JSON array for cleanup suggestions.", resultText); }
                    } catch (jsonError) { console.error('Error parsing cleanup suggestions JSON:', jsonError, resultText); throw new Error("AI returned invalid format for suggestions."); }
                    return books.filter(book => suggestedIds.includes(book.id));
                } catch (error) { console.error('Error generating cleanup suggestions:', error); throw error; }
            }

            function populateAiCleanupModal(suggestedBooks) {
                DOM.aiCleanupList.innerHTML = '';
                if (!suggestedBooks || suggestedBooks.length === 0) { DOM.aiCleanupList.innerHTML = '<p>AI didn\'t find any items matching the cleanup criteria. Your library looks tidy!</p>'; DOM.aiCleanupConfirmBtn.disabled = true; DOM.aiCleanupConfirmBtn.classList.remove('loading'); return; }
                const introText = document.createElement('p');
                introText.textContent = `AI suggests removing the following ${suggestedBooks.length} items. Uncheck any you want to keep:`;
                DOM.aiCleanupList.appendChild(introText);
                suggestedBooks.forEach(book => {
                    const itemDiv = document.createElement('div'); itemDiv.className = 'cleanup-item';
                    const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.checked = true; checkbox.value = book.id; checkbox.id = `cleanup-book-${book.id}`;
                    const detailsDiv = document.createElement('div'); detailsDiv.className = 'cleanup-item-details';
                    const titleDiv = document.createElement('div'); titleDiv.className = 'cleanup-item-title'; titleDiv.textContent = book.title; titleDiv.title = book.title;
                    const metaDiv = document.createElement('div'); metaDiv.className = 'cleanup-item-meta'; const progress = calculateOverallProgress(book); const lastRead = book.last_position?.timestamp ? `Last read: ${new Date(book.last_position.timestamp).toLocaleDateString()}` : `Added: ${new Date(book.updated_at).toLocaleDateString()}`; metaDiv.textContent = `Progress: ${progress}% • ${lastRead}`;
                    detailsDiv.appendChild(titleDiv); detailsDiv.appendChild(metaDiv);
                    const label = document.createElement('label'); label.htmlFor = checkbox.id; label.style.display = 'flex'; label.style.alignItems = 'center'; label.style.width = '100%'; label.style.cursor = 'pointer'; label.appendChild(checkbox); label.appendChild(detailsDiv);
                    itemDiv.appendChild(label); DOM.aiCleanupList.appendChild(itemDiv);
                });
                DOM.aiCleanupConfirmBtn.disabled = false;
                DOM.aiCleanupConfirmBtn.classList.remove('loading');
            }

            async function handleAiCleanupConfirm() {
                const checkboxes = DOM.aiCleanupList.querySelectorAll('input[type="checkbox"]:checked');
                const idsToDelete = Array.from(checkboxes).map(cb => parseInt(cb.value, 10));
                if (idsToDelete.length === 0) { showToast("No items selected for deletion.", 2000); hideAiCleanupModal(); return; }
                if (!confirm(`Are you sure you want to permanently delete ${idsToDelete.length} selected item(s)?`)) return;
                DOM.aiCleanupConfirmBtn.disabled = true;
                DOM.aiCleanupConfirmBtn.classList.add('loading');
                showToast(`Deleting ${idsToDelete.length} items...`, 3000);
                try {
                    const { error } = await supabase.from('ebooks').delete().in('id', idsToDelete);
                    if (error) throw error;
                    showToast(`Successfully deleted ${idsToDelete.length} items.`, 3000);
                    hideAiCleanupModal();
                    loadUserLibrary();
                } catch (error) { console.error("Error deleting books:", error); showToast(`Error deleting items: ${error.message}`, 4000); DOM.aiCleanupConfirmBtn.disabled = false; DOM.aiCleanupConfirmBtn.classList.remove('loading'); }
            }

            function toggleChatPanel() {
                const willBeVisible = !DOM.chatPanel.classList.contains('visible');
                DOM.chatPanel.classList.toggle('visible', willBeVisible);
                DOM.tocPanel.classList.remove('visible');
                DOM.settingsPanel.classList.remove('visible');
                DOM.overlay.classList.remove('visible');
                if (willBeVisible) { if (state.chatHistory.length <= 1) renderSuggestedQuestions(initialSuggestedQuestions); else renderSuggestedQuestions([]); }
                else { renderSuggestedQuestions([]); }
            }

            function closeChatPanel() { DOM.chatPanel.classList.remove('visible'); renderSuggestedQuestions([]); }

            function goToHome() {
                DOM.welcomeScreen.style.display = 'flex';
                DOM.navbar.classList.remove('visible');
                closeAllPanels();
                DOM.fileInput.value = '';
                DOM.textInput.value = '';
                DOM.textInputTitle.value = '';
                state.bookData = { title: '', content: '', chapters: [], currentPosition: 0, sourceUrl: null, rawContent: null };
                state.selectedListId = 'all';
                state.bookLists = [];
                DOM.sourceUrlDisplay.style.display = 'none';
                supabase.auth.getSession().then(({ data: { session } }) => {
                    if (session) { fetchBookLists().then(() => { loadUserLibrary(); }); }
                    else { renderListBadges(); }
                });
            }

            function handleContentClick(e) {
                // --- START: Intercept Link Clicks in Markdown View ---
                // Links should only be interactive when NOT in raw HTML view
                if (!state.settings.viewRawHtmlEnabled) {
                    const link = e.target.closest('a'); // Find the nearest ancestor anchor tag

                    if (link && link.href && DOM.contentArea.contains(link)) { // Ensure link is within content area
                        // It's a click on a link within the content area in Markdown mode
                        e.preventDefault(); // Stop the browser from following the link immediately
                        const url = link.href;

                        // Check if it's a scrapable URL (http/https)
                        if (url.startsWith('http://') || url.startsWith('https://')) {
                            // Show confirmation toast instead of automatically scraping
                            const linkText = link.textContent || url; // Use link text or URL as display
                            showLinkActionConfirmation(url, linkText);
                        } else {
                            // For non-http links (e.g., mailto:, javascript:, internal anchors #), open normally or ignore
                            console.warn(`Link is not directly scrapable or is internal: ${url}`);
                            // Optionally open non-http links in a new tab if desired
                            // window.open(url, '_blank', 'noopener noreferrer');
                            showToast(`Cannot scrape this type of link: ${url.substring(0, 30)}...`, 3000);
                        }
                        return; // We've handled this click, no need for further UI toggling logic
                    }
                }
                // --- END: Intercept Link Clicks ---
                const selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) return;
                const clickY = e.clientY;
                const viewportHeight = window.innerHeight;
                if (DOM.navbar.classList.contains('visible')) { if (!DOM.navbar.contains(e.target)) DOM.navbar.classList.remove('visible'); }
                else if (clickY <= viewportHeight * 0.15) { DOM.navbar.classList.add('visible'); clearTimeout(state.navbarHideTimer); state.navbarHideTimer = setTimeout(() => { DOM.navbar.classList.remove('visible'); }, 3000); }
                DOM.translationPopup.classList.remove('visible');
                setTimeout(() => { DOM.translationPopup.style.display = 'none'; }, 200);
            }

            function handleTextSelection() {
                const translationEnabled = DOM.translationToggle.checked;
                if (!translationEnabled) return;
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                if (!selectedText) { DOM.translationPopup.style.display = 'none'; clearTimeout(state.translationTimer); return; }
                if (selectedText.length > 1 && selectedText.length < 500) {
                    clearTimeout(state.translationTimer);
                    state.translationTimer = setTimeout(() => {
                        const range = selection.getRangeAt(0);
                        const rect = range.getBoundingClientRect();
                        state.lastSelectionRect = rect;
                        positionTranslationPopup(rect);
                        DOM.translationContent.textContent = 'Translating...';
                        DOM.translationLoading.style.display = 'flex';
                        if (state.settings.speakSelectionEnabled) speakText(selectedText);
                        translateText(selectedText);
                    }, 750);
                }
            }

            function positionTranslationPopup(rect) {
                const popup = DOM.translationPopup;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                popup.style.display = 'block';
                popup.classList.remove('visible');
                let leftPos = rect.left + window.scrollX;
                let topPos = rect.bottom + window.scrollY + 10;
                const popupWidth = popup.offsetWidth;
                const popupHeight = popup.offsetHeight;
                if (leftPos + popupWidth > viewportWidth - 10) leftPos = Math.max(10, viewportWidth - popupWidth - 10);
                if (topPos + popupHeight > viewportHeight + window.scrollY - 10) {
                    topPos = rect.top + window.scrollY - popupHeight - 10;
                    if (topPos < window.scrollY) { leftPos = rect.right + window.scrollX + 10; topPos = rect.top + window.scrollY; if (leftPos + popupWidth > viewportWidth - 10) leftPos = Math.max(10, rect.left + window.scrollX - popupWidth - 10); }
                }
                popup.style.left = `${leftPos}px`;
                popup.style.top = `${topPos}px`;
                requestAnimationFrame(() => { popup.classList.add('visible'); });
            }

            function decreaseFontSize() { if (state.settings.fontSize > 70) { state.settings.fontSize -= 10; updateFontSize(); } else { showToast('Minimum font size reached'); } }
            function increaseFontSize() { if (state.settings.fontSize < 200) { state.settings.fontSize += 10; updateFontSize(); } else { showToast('Maximum font size reached'); } }
            function updateFontSize() { DOM.contentArea.style.fontSize = `${state.settings.fontSize}%`; DOM.fontSizeValue.textContent = `${state.settings.fontSize}%`; localStorage.setItem('ebook-font-size', state.settings.fontSize); }
            function decreaseLineHeight() { if (state.settings.lineHeight > 1.2) { state.settings.lineHeight = Math.round((state.settings.lineHeight - 0.1) * 10) / 10; updateLineHeight(); } else { showToast('Minimum line height reached'); } }
            function increaseLineHeight() { if (state.settings.lineHeight < 2.4) { state.settings.lineHeight = Math.round((state.settings.lineHeight + 0.1) * 10) / 10; updateLineHeight(); } else { showToast('Maximum line height reached'); } }
            function updateLineHeight() {
                // Set the CSS variable on the content area element
                DOM.contentArea.style.setProperty('--reader-line-height', state.settings.lineHeight);
                DOM.lineHeightValue.textContent = state.settings.lineHeight;
                localStorage.setItem('ebook-line-height', state.settings.lineHeight);
            }
            function setTheme(theme) { document.body.classList.remove('light-theme', 'sepia-theme', 'dark-theme'); document.body.classList.add(`${theme}-theme`); DOM.themeOptions.forEach(option => { option.classList.remove('active'); if (option.getAttribute('data-theme') === theme) option.classList.add('active'); }); state.settings.theme = theme; localStorage.setItem('ebook-theme', theme); }

            function updateProgressBar() {
                if (!state.bookData.chapters.length) return;
                const scrollTop = DOM.contentArea.scrollTop;
                const scrollHeight = DOM.contentArea.scrollHeight;
                const clientHeight = DOM.contentArea.clientHeight;
                let chapterProgress = (scrollHeight > clientHeight) ? scrollTop / (scrollHeight - clientHeight) : 0;
                const chaptersProgress = state.bookData.currentPosition / Math.max(1, state.bookData.chapters.length - 1);
                const weightedChapterProgress = chapterProgress / state.bookData.chapters.length;
                const overallProgress = (chaptersProgress + weightedChapterProgress) * 100;
                DOM.progressBar.style.width = `${overallProgress}%`;
                debounce(saveReadingProgress, 1500)();
            }

            function saveReadingProgress() {
                const currentPosition = { chapter: state.bookData.currentPosition, percentComplete: calculatePercentageComplete(), scroll: DOM.contentArea.scrollTop || 0, viewportHeight: DOM.contentArea.clientHeight, contentHeight: DOM.contentArea.scrollHeight, timestamp: new Date().getTime(), textAnchor: findVisibleTextAnchor() };
                state.lastPosition = currentPosition;
                saveBookToLibrary();
            }

            function calculatePercentageComplete() {
                const scrollTop = DOM.contentArea.scrollTop;
                const scrollHeight = DOM.contentArea.scrollHeight;
                const clientHeight = DOM.contentArea.clientHeight;
                if (scrollHeight <= clientHeight) return 0;
                return scrollTop / (scrollHeight - clientHeight);
            }

            function findVisibleTextAnchor() {
                const paragraphs = DOM.contentArea.querySelectorAll('p');
                const scrollTop = DOM.contentArea.scrollTop;
                const viewportHeight = DOM.contentArea.clientHeight;
                if (!paragraphs[0]?.hasAttribute('data-p-index')) { paragraphs.forEach((p, index) => { p.setAttribute('data-p-index', index); }); }
                for (let i = 0; i < paragraphs.length; i++) {
                    const rect = paragraphs[i].getBoundingClientRect();
                    const paragraphTop = rect.top + scrollTop - DOM.contentArea.offsetTop;
                    if (paragraphTop + rect.height > scrollTop && paragraphTop < scrollTop + viewportHeight) {
                        const text = paragraphs[i].textContent?.substring(0, 50) || '';
                        const offset = (scrollTop - paragraphTop) / rect.height;
                        return { index: parseInt(paragraphs[i].getAttribute('data-p-index')), text: text, offset: Math.max(0, Math.min(1, offset)) };
                    }
                }
                return null;
            }

            function showLoading() { DOM.loading.classList.add('visible'); }
            function hideLoading() { DOM.loading.classList.remove('visible'); }
            function showToast(message, duration = 3000) { const toast = DOM.toast; toast.textContent = message; toast.classList.add('visible'); setTimeout(() => { toast.classList.remove('visible'); }, duration); }
            function debounce(func, delay) { const context = this; return function() { const args = arguments; const functionName = func.name || 'anonymous'; clearTimeout(state.debounceTimers[functionName]); state.debounceTimers[functionName] = setTimeout(() => { func.apply(context, args); delete state.debounceTimers[functionName]; }, delay); }; }

            async function checkAuthAndLoadApiSettings() {
                const { data: { session } } = await supabase.auth.getSession();
                state.session = session;
                if (!session) { window.location.href = 'index.html'; return; }
                else { DOM.loginBtn.classList.add('hidden'); DOM.authSection.innerHTML = `<p>Signed in as ${session.user.email}</p>`; DOM.librarySection.style.display = 'block'; fetchBookLists().then(() => { loadUserLibrary(); }); }

                state.userApiSettings = await getUserApiSettings();
                let apiStatusHtml = '<div id="api-status-container">';
                let canUseAi = false;
                let canUseFirecrawl = false;
                DOM.aiCleanupBtn.style.display = 'none';

                if (state.userApiSettings) {
                    if (state.userApiSettings.api_key && state.userApiSettings.model) {
                        apiStatusHtml += `<div class="api-status-item"><span class="status-icon">✅</span><span class="status-text">Gemini API configured (Model: ${escapeHTML(state.userApiSettings.model)})</span></div>`;
                        canUseAi = true;
                        DOM.summarizeChapterBtn.style.display = 'block'; // Show summarize button
                    } else {
                        apiStatusHtml += `<div class="api-status-item"><span class="status-icon">❌</span><span class="status-text">Gemini API not configured. <a href="index.html" target="_blank">Set up</a>.</span></div>`;
                        DOM.summarizeChapterBtn.style.display = 'none'; // Hide summarize button
                    }
                    if (state.userApiSettings.firecrawl_api_key) {
                        apiStatusHtml += `<div class="api-status-item"><span class="status-icon">✅</span><span class="status-text">Firecrawl API configured</span></div>`;
                        canUseFirecrawl = true;
                    } else {
                        apiStatusHtml += `<div class="api-status-item"><span class="status-icon">❌</span><span class="status-text">Firecrawl API not configured. <a href="index.html" target="_blank">Set up</a>.</span></div>`;
                    }
                } else {
                    apiStatusHtml += `<div class="api-status-item"><span class="status-icon">⚠️</span><span class="status-text">Sign in and <a href="index.html" target="_blank">configure API keys</a> in the dashboard to enable AI features.</span></div>`;
                    DOM.summarizeChapterBtn.style.display = 'none'; // Hide summarize button
                }
                apiStatusHtml += '</div>';

                if (DOM.aiSettingsContent) { DOM.aiSettingsContent.innerHTML = apiStatusHtml; }
                else { console.error("Error: Could not find the #ai-settings-content element in the DOM."); showToast("Error displaying AI status: UI element missing."); }

                DOM.translationToggle.disabled = !canUseAi;
                DOM.chatBtn.disabled = !canUseAi;
                DOM.processUrlBtn.disabled = !canUseFirecrawl;
                DOM.aiCleanupBtn.disabled = !canUseAi;

                if (!canUseAi) { DOM.chatBtn.style.opacity = "0.5"; DOM.chatBtn.style.cursor = "not-allowed"; DOM.chatBtn.title = "Gemini API key needed for chat. Set it up in the main dashboard."; DOM.translationToggle.closest('.settings-row').title = "Gemini API key needed for translation."; DOM.translationToggle.style.cursor = "not-allowed"; DOM.aiCleanupBtn.style.opacity = "0.5"; DOM.aiCleanupBtn.style.cursor = "not-allowed"; DOM.aiCleanupBtn.title = "Gemini API key needed for AI Cleanup. Set it up in the main dashboard."; }
                else { DOM.aiCleanupBtn.style.display = 'inline-flex'; DOM.aiCleanupBtn.disabled = false; DOM.aiCleanupBtn.style.opacity = "1"; DOM.aiCleanupBtn.style.cursor = "pointer"; DOM.aiCleanupBtn.title = "AI Library Cleanup"; DOM.chatBtn.style.opacity = "1"; DOM.chatBtn.style.cursor = "pointer"; DOM.chatBtn.title = "Chat with AI about this chapter"; DOM.translationToggle.closest('.settings-row').title = ""; DOM.translationToggle.style.cursor = "pointer"; }
                if (!canUseFirecrawl) { DOM.urlInputContainer.title = "Firecrawl API key needed. Set it up in the main dashboard."; DOM.processUrlBtn.style.opacity = "0.5"; DOM.processUrlBtn.style.cursor = "not-allowed"; }
                else { DOM.urlInputContainer.title = ""; DOM.processUrlBtn.style.opacity = "1"; DOM.processUrlBtn.style.cursor = "pointer"; }
            }

            async function getUserApiSettings() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return null;
                const { data, error } = await supabase.from('user_settings').select('api_key, model, firecrawl_api_key').eq('user_id', session.user.id).maybeSingle();
                if (error) { console.error('Error fetching API settings:', error); return null; }
                return data;
            }

            function toggleCreateListInput() {
                if (!state.isCreatingList) { DOM.newListNameInput.style.display = 'block'; DOM.newListNameInput.focus(); DOM.createListBtn.textContent = '✓'; state.isCreatingList = true; }
                else { handleCreateList(); }
            }

            function cancelListCreation() { DOM.newListNameInput.style.display = 'none'; DOM.newListNameInput.value = ''; DOM.createListBtn.textContent = '+'; state.isCreatingList = false; }

            async function loadUserLibrary() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                const libraryList = document.getElementById('library-list');
                libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Loading books...</div>';
                const listInfoMap = new Map(state.bookLists.map((list, index) => [list.id, { name: list.name, index: index }]));
                const badgeColors = 5;
                try {
                    let query = supabase.from('ebooks').select('*, raw_content').eq('user_id', session.user.id);
                    if (state.selectedListId === 'all') {}
                    else if (state.selectedListId) { query = query.eq('list_id', state.selectedListId); }
                    else { query = query.is('list_id', null); }
                    query = query.order('updated_at', { ascending: false });
                    const { data: books, error } = await query;
                    if (error) throw error;
                    if (!books || books.length === 0) { libraryList.innerHTML = `<div style="text-align: center; padding: 20px;">This list is empty</div>`; return; }
                    libraryList.innerHTML = '';
                    books.forEach(book => {
                        const date = new Date(book.updated_at).toLocaleDateString();
                        const progress = calculateOverallProgress(book);
                        const listInfo = book.list_id ? listInfoMap.get(book.list_id) : null;
                        const listName = listInfo ? listInfo.name : null;
                        let listBadgeHtml = '';
                        if (listName) { const colorIndex = (listInfo.index + 1) % badgeColors; listBadgeHtml = `<span class="library-item-list-badge" data-color-index="${colorIndex}" title="List: ${escapeHTML(listName)}">${escapeHTML(listName)}</span>`; }
                        else { listBadgeHtml = `<span class="library-item-list-badge" title="Unlisted">Unlisted</span>`; }
                        const item = document.createElement('div'); item.className = 'library-item';
                        item.innerHTML = `<div class="library-item-details"><div class="library-item-title-container"><div class="library-item-title">${escapeHTML(book.title)}</div>${listBadgeHtml}</div><div class="library-item-meta">${book.file_type.toUpperCase()} • Last read: ${date} • ${progress}% complete</div></div><div class="library-item-actions" style="position: relative;"><button class="library-item-move" data-id="${book.id}" data-current-list-id="${book.list_id || ''}" style="display: none;">Move</button><div class="move-list-dropdown"></div><button class="library-item-delete" data-id="${book.id}">×</button></div>`;
                        const progressBarContainer = document.createElement('div'); progressBarContainer.className = 'progress-bar-container'; progressBarContainer.innerHTML = `<div class="progress-bar" style="width: ${progress}%"></div>`; item.querySelector('.library-item-details').appendChild(progressBarContainer);
                        item.addEventListener('click', (event) => { if (event.target.closest('.library-item-delete, .library-item-move, .library-item-list-badge')) return; loadBookFromLibrary(book); });
                        libraryList.appendChild(item);
                        const moveButton = item.querySelector('.library-item-move');
                        const dropdownContainer = item.querySelector('.move-list-dropdown');
                        if (moveButton && dropdownContainer && state.bookLists.length > 0) {
                            moveButton.style.display = 'inline-block';
                            moveButton.addEventListener('click', (event) => {
                                event.stopPropagation();
                                document.querySelectorAll('.move-list-dropdown.visible').forEach(dd => { if (dd !== dropdownContainer) dd.classList.remove('visible'); });
                                const isVisible = dropdownContainer.classList.toggle('visible');
                                if (isVisible) { const bookId = moveButton.getAttribute('data-id'); const currentListId = moveButton.getAttribute('data-current-list-id') || null; renderMoveToListDropdown(dropdownContainer, bookId, currentListId); }
                            });
                        }
                    });
                    document.querySelectorAll('.library-item-delete').forEach(button => { button.addEventListener('click', async (event) => { event.stopPropagation(); const bookId = button.getAttribute('data-id'); if (confirm('Remove this book from your library?')) await deleteBookFromLibrary(bookId); }); });
                } catch (error) { console.error('Error loading library:', error); libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Error loading library</div>'; }
            }

            async function fetchBookLists() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                try {
                    const { data, error } = await supabase.from('book_lists').select('id, name').eq('user_id', session.user.id).order('name', { ascending: true });
                    if (error) throw error;
                    state.bookLists = data || [];
                    renderListBadges();
                } catch (error) { console.error('Error fetching book lists:', error); showToast('Could not load book lists'); state.bookLists = []; renderListBadges(); }
            }

            function renderListBadges() {
                DOM.listBadgeContainer.innerHTML = '';
                const badgeColors = 5;
                const createBadge = (text, listId, isSpecial = false, colorIndex = -1) => {
                    const badge = document.createElement('div'); badge.className = 'list-badge'; badge.textContent = text; badge.setAttribute('data-list-id', listId === null ? '' : listId);
                    const currentIdStr = state.selectedListId === null ? '' : String(state.selectedListId); const badgeIdStr = listId === null ? '' : String(listId);
                    if (currentIdStr === badgeIdStr) badge.classList.add('active');
                    if (!isSpecial && colorIndex >= 0) badge.setAttribute('data-color-index', colorIndex % badgeColors);
                    return badge;
                };
                DOM.listBadgeContainer.appendChild(createBadge('All', 'all', false, 0));
                DOM.listBadgeContainer.appendChild(createBadge('Unlisted', null, true));
                state.bookLists.forEach((list, index) => { DOM.listBadgeContainer.appendChild(createBadge(list.name, list.id, false, index + 1)); });
            }

            function handleListBadgeClick(event) {
                const clickedBadge = event.target.closest('.list-badge');
                if (!clickedBadge || clickedBadge.classList.contains('active')) return;
                const selectedValue = clickedBadge.getAttribute('data-list-id');
                state.selectedListId = selectedValue === "" ? null : selectedValue;
                DOM.listBadgeContainer.querySelectorAll('.list-badge').forEach(badge => badge.classList.remove('active'));
                clickedBadge.classList.add('active');
                loadUserLibrary();
            }

            async function handleCreateList() {
                const listName = DOM.newListNameInput.value.trim();
                if (!listName) { showToast('Please enter a name for the new list.'); DOM.newListNameInput.focus(); return; }
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) { showToast('Please sign in to create lists.'); return; }
                DOM.createListBtn.disabled = true; DOM.createListBtn.classList.add('loading'); DOM.createListBtn.textContent = '...';
                try {
                    const { data, error } = await supabase.from('book_lists').insert({ user_id: session.user.id, name: listName }).select().single();
                    if (error) { if (error.code === '23505') throw new Error(`List "${listName}" already exists.`); else throw error; }
                    showToast(`List "${listName}" created.`);
                    cancelListCreation();
                    await fetchBookLists();
                } catch (error) { console.error('Error creating list:', error); showToast(`Error: ${error.message}`); DOM.createListBtn.disabled = false; DOM.createListBtn.classList.remove('loading'); DOM.createListBtn.textContent = '✓'; DOM.newListNameInput.focus(); }
            }

            function renderMoveToListDropdown(dropdownElement, bookId, currentListIdStr) {
                dropdownElement.innerHTML = '';
                const currentListId = currentListIdStr === '' ? null : parseInt(currentListIdStr, 10);
                const unlistedOption = document.createElement('div'); unlistedOption.className = 'move-list-option'; unlistedOption.textContent = 'Unlisted'; unlistedOption.setAttribute('data-target-list-id', '');
                if (currentListId === null) { unlistedOption.classList.add('disabled'); unlistedOption.title = 'Already in this list'; }
                else { unlistedOption.addEventListener('click', (e) => { e.stopPropagation(); moveBookToList(bookId, null); dropdownElement.classList.remove('visible'); }); }
                dropdownElement.appendChild(unlistedOption);
                const separator = document.createElement('hr'); separator.style.margin = '2px 0'; separator.style.borderColor = 'var(--border-color)'; dropdownElement.appendChild(separator);
                state.bookLists.forEach(list => {
                    const option = document.createElement('div'); option.className = 'move-list-option'; option.textContent = list.name; option.setAttribute('data-target-list-id', list.id);
                    if (list.id === currentListId) { option.classList.add('disabled'); option.title = 'Already in this list'; }
                    else { option.addEventListener('click', (e) => { e.stopPropagation(); moveBookToList(bookId, list.id); dropdownElement.classList.remove('visible'); }); }
                    dropdownElement.appendChild(option);
                });
            }

            async function moveBookToList(bookId, targetListId) {
                showLoading();
                try {
                    const { error } = await supabase.from('ebooks').update({ list_id: targetListId, updated_at: new Date() }).eq('id', bookId);
                    if (error) throw error;
                    showToast("Book moved successfully.");
                    loadUserLibrary();
                } catch (error) { console.error('Error moving book:', error); showToast("Error moving book."); }
                finally { hideLoading(); }
            }

            function escapeHTML(str) { return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;'); }

            async function deleteBookFromLibrary(bookId) {
                try {
                    const { error } = await supabase.from('ebooks').delete().eq('id', bookId);
                    if (error) throw error;
                    loadUserLibrary();
                    showToast('Book removed from library');
                } catch (error) { console.error('Error deleting book:', error); showToast('Could not delete the book'); }
            }

            async function saveBookToLibrary() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session || !state.bookData.title) return false;
                try {
                    let fileType = state.bookData.title.includes('.') ? state.bookData.title.split('.').pop().toLowerCase() : (state.bookData.sourceUrl ? 'url' : 'txt');
                    const bookContent = null; // Don't save large content directly
                    const metadata = {
                        chapters: state.bookData.chapters.map(chapter => ({
                            title: chapter.title,
                            startLine: chapter.startLine,
                            endLine: chapter.endLine,
                            content: chapter.content, // Store HTML content if available
                            markdownContent: chapter.markdownContent // Store Markdown content if available
                        })),
                        // preferHtmlView: state.settings.preferHtmlView, // Removed
                        viewRawHtmlEnabled: state.settings.viewRawHtmlEnabled, // Save the raw view setting
                        sourceUrl: state.bookData.sourceUrl
                    };
                    const lastPosition = state.lastPosition || { chapter: state.bookData.currentPosition, scroll: DOM.contentArea.scrollTop || 0, percentComplete: calculatePercentageComplete(), timestamp: new Date().getTime() };
                    let existingBookQuery = supabase.from('ebooks').select('id').eq('title', state.bookData.title).eq('user_id', session.user.id);
                    if (state.bookData.currentListId === null) { existingBookQuery = existingBookQuery.is('list_id', null); }
                    else { existingBookQuery = existingBookQuery.eq('list_id', state.bookData.currentListId); }
                    const { data: existingBook, error: existingBookError } = await existingBookQuery.maybeSingle();
                    if (existingBookError) { console.error("Error checking for existing book:", existingBookError); throw existingBookError; }
                    if (existingBook && existingBook.id) { const { error: updateError } = await supabase.from('ebooks').update({ metadata: metadata, last_position: lastPosition, updated_at: new Date() }).eq('id', existingBook.id); if (updateError) throw updateError; }
                    else { const { error: insertError } = await supabase.from('ebooks').insert({ user_id: session.user.id, title: state.bookData.title, content: bookContent, file_type: fileType, metadata: metadata, last_position: lastPosition, list_id: state.bookData.currentListId || null }); if (insertError) throw insertError; }
                    return true;
                } catch (error) { console.error('Error saving book:', error); return false; }
            }

            async function loadBookFromLibrary(book) {
                showLoading();
                try {
                    state.bookData.title = book.title;
                    state.bookData.currentListId = book.list_id || null;
                    state.bookData.rawContent = book.raw_content || null;
                    DOM.bookTitle.textContent = book.title;
                    if (book.metadata && book.metadata.chapters && book.metadata.chapters.length > 0) {
                        // Load both content types if available in metadata
                        state.bookData.chapters = book.metadata.chapters.map(chapter => ({
                            title: chapter.title,
                            content: chapter.content || null, // HTML content (potentially older format)
                            markdownContent: chapter.markdownContent || null, // Markdown content (preferred for URLs)
                            startLine: chapter.startLine,
                            endLine: chapter.endLine
                        }));
                        state.bookData.sourceUrl = book.metadata.sourceUrl || null;
                    } else {
                        // Fallback if metadata structure is old or missing
                        state.bookData.chapters = [{ title: book.title, markdownContent: "Content not available", content: null, startLine: 0, endLine: 1 }];
                        state.bookData.sourceUrl = null;
                        console.warn("Book metadata missing or incomplete for:", book.title);
                    }

                    // Load raw view setting from metadata if present, otherwise default to false
                    state.settings.viewRawHtmlEnabled = (book.metadata && book.metadata.viewRawHtmlEnabled !== undefined) ? book.metadata.viewRawHtmlEnabled : false;
                    DOM.viewRawHtmlToggle.checked = state.settings.viewRawHtmlEnabled;

                    const lastPosition = book.last_position || {};
                    state.bookData.currentPosition = lastPosition.chapter !== undefined ? lastPosition.chapter : 0;
                    showBook();
                    restoreReadingPosition(lastPosition);
                    hideLoading();
                } catch (error) { console.error('Error loading book:', error); hideLoading(); showToast('Error loading book: ' + error.message); }
            }

            function restoreReadingPosition(lastPosition) {
                if (!lastPosition) return;
                showToast('Restoring reading position...', 1500);

                // Use requestAnimationFrame to wait for rendering after chapter display
                requestAnimationFrame(() => {
                    // Give it another frame just in case layout is still settling
                    requestAnimationFrame(() => {
                        let restored = false;
                        const isPositionRecent = lastPosition.timestamp && (Date.now() - lastPosition.timestamp < 90 * 24 * 60 * 60 * 1000); // ~3 months

                        // 1. Try restoring by text anchor (most reliable if content hasn't changed drastically)
                        if (isPositionRecent && lastPosition.textAnchor) {
                            restored = restoreByTextAnchor(lastPosition.textAnchor);
                            if (restored) {
                                console.log("Restored position using text anchor.");
                                return;
                            } else {
                                console.warn("Failed to restore using text anchor, trying percentage.");
                            }
                        }

                        // 2. Try restoring by percentage complete (good fallback)
                        if (lastPosition.percentComplete !== undefined && lastPosition.percentComplete >= 0 && lastPosition.percentComplete <= 1) {
                            const scrollHeight = DOM.contentArea.scrollHeight;
                            const clientHeight = DOM.contentArea.clientHeight;
                            if (scrollHeight > clientHeight) {
                                const targetPosition = lastPosition.percentComplete * (scrollHeight - clientHeight);
                                DOM.contentArea.scrollTo({ top: targetPosition, behavior: 'auto' }); // Use 'auto' for instant jump
                                console.log(`Restored position using percentage: ${Math.round(lastPosition.percentComplete * 100)}%`);
                                restored = true;
                                return;
                            }
                        }

                        // 3. As a last resort, use the raw scroll value (least reliable)
                        if (lastPosition.scroll !== undefined && lastPosition.scroll >= 0) {
                            DOM.contentArea.scrollTo({ top: lastPosition.scroll, behavior: 'auto' }); // Use 'auto' for instant jump
                            console.warn("Restored position using raw scroll value (fallback).");
                            restored = true;
                            return;
                        }

                        if (!restored) {
                            console.warn("Could not restore reading position from saved data.");
                            DOM.contentArea.scrollTo({ top: 0, behavior: 'auto' }); // Go to top if nothing worked
                        }
                    });
                });
            }


            function restoreByTextAnchor(textAnchor) {
                if (!textAnchor || textAnchor.index === undefined || textAnchor.index < 0) return false;

                const paragraphs = DOM.contentArea.querySelectorAll('p[data-p-index]');
                let targetParagraph = DOM.contentArea.querySelector(`p[data-p-index="${textAnchor.index}"]`);

                // If the exact index isn't found, or the text doesn't match reasonably, try searching nearby
                if (!targetParagraph || (textAnchor.text && !isTextSimilar(targetParagraph.textContent, textAnchor.text))) {
                    console.warn(`Paragraph at index ${textAnchor.index} not found or text mismatch. Searching...`);
                    if (textAnchor.text) {
                        for (let i = 0; i < paragraphs.length; i++) {
                            if (isTextSimilar(paragraphs[i].textContent, textAnchor.text)) {
                                targetParagraph = paragraphs[i];
                                console.log(`Found similar text in paragraph index ${paragraphs[i].getAttribute('data-p-index')}`);
                                break; // Found a likely match
                            }
                        }
                    }
                }

                if (!targetParagraph) {
                    console.error("Could not find target paragraph for text anchor restoration.");
                    return false; // Still couldn't find it
                }

                // Calculate scroll position based on the found paragraph
                const contentAreaRect = DOM.contentArea.getBoundingClientRect();
                const paragraphRect = targetParagraph.getBoundingClientRect();

                // Calculate the paragraph's top position relative to the contentArea's top
                const paragraphTopRelativeToContentArea = paragraphRect.top - contentAreaRect.top;

                // Calculate the target scroll position within the contentArea
                const offset = textAnchor.offset || 0; // Offset within the paragraph (0 to 1)
                const scrollTarget = DOM.contentArea.scrollTop + paragraphTopRelativeToContentArea + (offset * paragraphRect.height);

                // Scroll slightly above the target for better context visibility
                const finalScrollTarget = Math.max(0, scrollTarget - 50);

                DOM.contentArea.scrollTo({ top: finalScrollTarget, behavior: 'auto' }); // Use 'auto' for instant jump
                return true;
            }

            // Helper function for text similarity check
            function isTextSimilar(text1, text2) {
                if (!text1 || !text2) return false;
                const t1 = text1.substring(0, 50).trim();
                const t2 = text2.substring(0, 50).trim();
                if (t1 === t2) return true;
                // Allow for minor differences, e.g., first 10 characters match
                if (t1.length > 10 && t2.length > 10 && t1.slice(0, 10) === t2.slice(0, 10)) return true;
                return false;
            }

            function displayChatMessage(sender, message, isLoading = false) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message', sender);
                if (sender === 'assistant') { let processedMessage = escapeHTML(message); processedMessage = processedMessage.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); processedMessage = processedMessage.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'); processedMessage = processedMessage.replace(/\n/g, '<br>'); messageElement.innerHTML = processedMessage; }
                else { messageElement.textContent = message; }
                if (isLoading) messageElement.classList.add('loading');
                DOM.chatMessages.appendChild(messageElement);
                DOM.chatMessages.scrollTop = DOM.chatMessages.scrollHeight;
                return messageElement;
            }

            function clearChat() {
                state.chatHistory = [];
                DOM.chatMessages.innerHTML = '';
                const initialGreeting = state.chatUseFullDocument ? "Chat cleared. Ask me anything about the full document." : "Chat cleared. Ask me anything about the current chapter.";
                displayChatMessage('assistant', initialGreeting);
                renderSuggestedQuestions(initialSuggestedQuestions);
            }

            async function handleSendMessage() {
                const userMessage = DOM.chatInput.value.trim();
                if (!userMessage) return;
                if (!state.userApiSettings || !state.userApiSettings.api_key) { displayChatMessage('assistant', 'Sorry, the Gemini API key is not configured. Please set it up in the main dashboard.'); return; }
                displayChatMessage('user', userMessage);
                state.chatHistory.push({ role: 'user', parts: [{ text: userMessage }] });
                DOM.chatInput.value = '';
                const loadingElement = displayChatMessage('assistant', '', true);
                DOM.chatSendBtn.disabled = true;
                renderSuggestedQuestions([]);
                processAndSendChat(userMessage, loadingElement);
            }

            async function processAndSendChat(userMessage, loadingElement) {
                try {
                    let contextContent = ""; let contextSource = "";
                    if (state.chatUseFullDocument) { contextSource = "the full document"; contextContent = state.bookData.chapters.map(ch => ch.content).join("\n\n---\n\n"); }
                    else { contextSource = "the current chapter"; const currentChapter = state.bookData.chapters[state.bookData.currentPosition]; contextContent = currentChapter ? currentChapter.content : "No chapter content available."; }
                    const maxContextLength = 15000;
                    const fullContext = contextContent.length > maxContextLength ? contextContent.substring(0, maxContextLength) + "\n... [Context Truncated]" : contextContent;
                    const historyToSend = state.chatHistory.slice(-10);
                    const language = localStorage.getItem('speech-language') || 'en-US';
                    const languageName = language.startsWith('fr') ? 'French' : 'English';
                    const systemPrompt = `You are a helpful AI assistant integrated into an ebook reader. The user is reading a book and will provide context (either the current chapter or the full document).\nYour primary goal is to help the user **explore and understand** the provided text. Answer questions, summarize, explain concepts, and identify key points based *strictly* on the context.\nBe concise and accurate. \nUse Markdown for formatting (like **bold**). Use new lines for paragraphs, bullet points, if applicable to make it easier to read.\nRemember the user might be learning ${languageName}, so explain complex ideas simply if appropriate.\n\n**IMPORTANT - Follow-up Questions:**\nAt the VERY END of your response, provide **up to 3 concrete, specific follow-up questions** (max 7-10 words each) that directly relate to the content just discussed or the provided context. These questions should encourage deeper exploration of the text.\nFormat these questions EXACTLY like this, with no extra text before or after the block:\n[SUGGESTIONS]\n1. Explore the next section\n2. What is the main argument in section X?\n3. Can you explain the term Y mentioned earlier?\n[/SUGGESTIONS]`;
                    const requestPayload = { contents: [ { role: 'user', parts: [{ text: systemPrompt }] }, { role: 'model', parts: [{ text: "Understood. I will focus on exploring and explaining the provided text and suggest concrete follow-up questions based on the content." }] }, ...historyToSend.slice(0, -1), { role: 'user', parts: [{ text: `Here is the full context from ${contextSource}:\n\n---\n${fullContext}\n---\n\nNow, please answer my question:` }] }, { role: 'model', parts: [{ text: "Okay, I have the context. What is your question?" }] }, historyToSend[historyToSend.length - 1] ] };
                    const response = await geminiChatRequest(state.userApiSettings.api_key, requestPayload.contents, state.userApiSettings.model);
                    loadingElement.remove();
                    let assistantResponseText = 'Sorry, I could not generate a response.';
                    let extractedSuggestions = [];
                    if (response.error) { assistantResponseText = `Sorry, there was an error: ${response.error.message}`; }
                    else {
                        const rawResponse = response?.candidates?.[0]?.content?.parts?.[0]?.text || '';
                        const suggestionBlockRegex = /^\s*\[SUGGESTIONS\]([\s\S]*?)\[\/SUGGESTIONS\]\s*$/m;
                        const match = rawResponse.match(suggestionBlockRegex);
                        if (match && match[1]) { const questionsText = match[1].trim(); extractedSuggestions = questionsText.split('\n').map(q => q.trim().replace(/^\d+\.\s*/, '')).filter(q => q.length > 0); assistantResponseText = rawResponse.replace(suggestionBlockRegex, '').trim(); }
                        else { assistantResponseText = rawResponse.trim(); }
                        if (!assistantResponseText) assistantResponseText = "Okay, I've processed that. What would you like to explore next?";
                    }
                    displayChatMessage('assistant', assistantResponseText);
                    state.chatHistory.push({ role: 'assistant', parts: [{ text: assistantResponseText }] });
                    renderSuggestedQuestions(extractedSuggestions);
                } catch (error) { console.error('Error handling chat message:', error); loadingElement.remove(); displayChatMessage('assistant', 'An unexpected error occurred while processing your request.'); state.chatHistory.push({ role: 'model', parts: [{ text: `Unexpected Error: ${error.message}` }] }); }
                finally { DOM.chatSendBtn.disabled = false; if (state.chatHistory.length > 20) state.chatHistory = state.chatHistory.slice(-20); }
            }

            const getApiUrl = (model) =>
`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=`;

            async function geminiSingleRequest(apiKey, promptText, model) {
                try {
                    const res = await fetch(`${getApiUrl(model)}${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] }) });
                    if (!res.ok) { const errorData = await res.json(); throw new Error(errorData.error?.message || 'API request failed'); }
                    return res.json();
                } catch (error) { console.error('Error calling Gemini API (single request):', error); return { error: { message: error.message || 'Failed to connect to Gemini API' } }; }
            }
            async function geminiChatRequest(apiKey, contents, model) {
                 try {
                    const res = await fetch(`${getApiUrl(model)}${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: contents }) });
                    if (!res.ok) { const errorData = await res.json(); throw new Error(errorData.error?.message || 'API request failed'); }
                    return res.json();
                } catch (error) { console.error('Error calling Gemini API:', error); return { error: { message: error.message || 'Failed to connect to Gemini API' } }; }
            }

            async function translateText(text) {
                if (!state.userApiSettings) { DOM.translationContent.textContent = 'Please configure API key in settings to use translation.'; return; }
                DOM.translationContent.textContent = ''; DOM.translationLoading.style.display = 'flex';
                try {
                    const prompt = `Translate the following English text to Vietnamese. Only return the translation without any explanation or additional text.\n\nText: "${text}"`;
                    const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, state.userApiSettings.model);
                    DOM.translationLoading.style.display = 'none';
                    if (response.error) { DOM.translationContent.textContent = `Error: ${response.error.message}`; return; }
                    const translation = response?.candidates?.[0]?.content?.parts?.[0]?.text || 'Translation failed.';
                    DOM.translationContent.textContent = translation;
                    generateFlashcard(text);
                } catch (error) { console.error('Error translating text:', error); DOM.translationLoading.style.display = 'none'; DOM.translationContent.textContent = 'An error occurred during translation.'; }
            }

            async function generateFlashcard(text) {
                if (!state.userApiSettings) return;
                try {
                    const prompt = `Extract a single useful vocabulary word or phrase from this text that would be good for a language learner. If the text is long, choose the most difficult or interesting word/phrase.\n\nText: "${text}"\n\nReturn in this JSON format without any additional text:\n{\n    "word": "the extracted word or short phrase",\n    "phrase": "A sentence showing the word in context, with the <b>word</b> in bold",\n    "translation_answer": "vietnamese translation\\nBrief definition in English"\n}`;
                    const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, state.userApiSettings.model);
                    if (response.error) { console.error('Error generating flashcard:', response.error); return; }
                    const flashcardText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '';
                    try { const jsonMatch = flashcardText.match(/\{[\s\S]*\}/); if (jsonMatch) { const flashcardData = JSON.parse(jsonMatch[0]); showFlashcardToast(flashcardData); } }
                    catch (jsonError) { console.error('Error parsing flashcard JSON:', jsonError, flashcardText); }
                } catch (error) { console.error('Error generating flashcard:', error); }
            }

            function formatTranslation(translation) {
                const parts = translation.split('\n');
                if (parts.length > 1) return `<b>${escapeHTML(parts[0])}</b><br><i>${escapeHTML(parts.slice(1).join('\n'))}</i>`;
                return escapeHTML(translation);
            }

            function showFlashcardToast(flashcardData) {
                const existingToast = document.querySelector('.flashcard-toast');
                if (existingToast) existingToast.remove();
                const toast = document.createElement('div'); toast.className = 'flashcard-toast visible';
                if (state.lastSelectionRect) { let left = state.lastSelectionRect.left; let top = state.lastSelectionRect.bottom + 10; const flashcardWidth = 240; if (left + flashcardWidth > window.innerWidth) left = window.innerWidth - flashcardWidth - 10; toast.style.left = `${left}px`; toast.style.top = `${top}px`; toast.style.bottom = 'auto'; toast.style.right = 'auto'; }
                else { toast.style.bottom = "20px"; toast.style.right = "20px"; }
                toast.innerHTML = `<div class="flashcard-header"><div class="flashcard-word">${escapeHTML(flashcardData.word)}</div><button type="button" class="flashcard-close-btn" aria-label="Close">×</button></div><div class="flashcard-translation">${formatTranslation(flashcardData.translation_answer)}</div><div class="flashcard-actions"><button type="button" class="flashcard-speak-btn" aria-label="Speak">🔊</button><button type="button" class="flashcard-save-btn">Save</button></div>`;
                document.body.appendChild(toast);
                toast.querySelector('.flashcard-close-btn').addEventListener('click', () => {
toast.classList.add('fade-out'); setTimeout(() => { toast.remove(); }, 500); });
                toast.querySelector('.flashcard-speak-btn').addEventListener('click', () => {
speakText(flashcardData.word); });
                const autoSpeakEnabled = localStorage.getItem('auto-speak-enabled') !== 'false';
                const speakSelectionEnabled = state.settings.speakSelectionEnabled;
                if (autoSpeakEnabled && !speakSelectionEnabled) setTimeout(() => speakText(flashcardData.word), 300);
                toast.querySelector('.flashcard-save-btn').addEventListener('click', async () => {
                    const saveButton = toast.querySelector('.flashcard-save-btn'); saveButton.textContent = 'Saving...'; saveButton.disabled = true;
                    const { data: { session } } = await supabase.auth.getSession();
                    if (!session) { showToast('Please sign in to save flashcards'); saveButton.textContent = 'Save'; saveButton.disabled = false; return; }
                    try {
                        const { error } = await supabase.from('flashcards').insert({ user_id: session.user.id, word: flashcardData.word, phrase: flashcardData.phrase, translation_answer: flashcardData.translation_answer, state: "new", due: new Date().toISOString(), stability: 0.5, difficulty: 5, elapsed_days: 0, scheduled_days: 0, reps: 0, lapses: 0 });
                        if (error) throw error;
                        saveButton.textContent = 'Saved!'; saveButton.disabled = true;
                        setTimeout(() => { toast.classList.add('fade-out'); setTimeout(() => { if (document.body.contains(toast)) toast.remove(); }, 500); }, 1000);
                    } catch (error) {
                        console.error('Error saving flashcard:', error);
                        saveButton.textContent = 'Failed';
                        setTimeout(() => {
                            saveButton.textContent = 'Retry';
                            saveButton.disabled = false;
                        }, 1500);
                    }
                });
                setTimeout(() => {
                    if (document.body.contains(toast)) {
                        toast.classList.add('fade-out');
                        setTimeout(() => toast.remove(), 500);
                    }
                }, 20000);
                if (state.lastSelectionRect) {
                    const toastRect = toast.getBoundingClientRect();
                    const selRect = state.lastSelectionRect;
                    const viewportHeight = window.innerHeight;
                    const viewportWidth = window.innerWidth;
                    const margin = 10;
                    let transRect = null;
                    if (DOM.translationPopup.classList.contains('visible')) {
                        transRect = DOM.translationPopup.getBoundingClientRect();
                    }
                    const positions = {
                        below: { top: selRect.bottom + margin, left: Math.max(viewportWidth - toastRect.width - margin, Math.min(selRect.left, viewportWidth - toastRect.width - margin)) },
                        above: { top: selRect.top - toastRect.height - margin, left: Math.max(viewportWidth - toastRect.width - margin, Math.min(selRect.left, viewportWidth - toastRect.width - margin)) },
                        right: { top: Math.min(selRect.top, viewportHeight - toastRect.height - margin), left: Math.max(viewportWidth - toastRect.width - margin, selRect.right + margin) },
                        left: { top: Math.min(selRect.top, viewportHeight - toastRect.height - margin), left: Math.max(viewportWidth - toastRect.width - margin, selRect.left - toastRect.width - margin) }
                    };
                    if (transRect) {
                        positions.belowTranslation = { top: transRect.bottom + margin, left: Math.max(viewportWidth - toastRect.width - margin, Math.min(transRect.left, viewportWidth - toastRect.width - margin)) };
                    }
                    const wouldOverlap = (pos, rect) => {
                        if (!rect) return false;
                        const posRight = pos.left + toastRect.width;
                        const posBottom = pos.top + toastRect.height;
                        return !(posBottom < rect.top || pos.top > rect.bottom || posRight < rect.left || pos.left > rect.right);
                    };
                    const isOnScreen = (pos) => {
                        return pos.top >= 0 && pos.left >= 0 && pos.left + toastRect.width <= viewportWidth && pos.top + toastRect.height <= viewportHeight;
                    };
                    const positionOrder = transRect ? ['belowTranslation', 'below', 'right', 'left', 'above'] : ['below', 'right', 'left', 'above'];
                    let bestPosition = null;
                    for (const posName of positionOrder) {
                        const pos = positions[posName];
                        if (!pos || !isOnScreen(pos)) continue;
                        const overlapsSelection = wouldOverlap(pos, selRect);
                        const overlapsTranslation = wouldOverlap(pos, transRect);
                        if (!overlapsSelection && !overlapsTranslation) { bestPosition = pos; break; }
                        if (!bestPosition && !overlapsTranslation) { bestPosition = pos; }
                    }
                    if (!bestPosition) {
                        bestPosition = { top: viewportHeight - toastRect.height - margin, left: viewportWidth - toastRect.width - margin };
                    }
                    toast.style.top = `${bestPosition.top}px`;
                    toast.style.left = `${bestPosition.left}px`;
                    toast.style.bottom = 'auto';
                    toast.style.right = 'auto';
                }
            }

            function speakText(text) {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    const language = localStorage.getItem('speech-language') || 'en-US';
                    utterance.lang = language;
                    const voices = window.speechSynthesis.getVoices();
                    const languageVoices = voices.filter(voice => voice.lang.startsWith(language.split('-')[0] + '-'));
                    if (languageVoices.length > 0) {
                        const femaleVoice = languageVoices.find(voice => voice.name.includes('female') || voice.name.includes('Female'));
                        utterance.voice = femaleVoice || languageVoices[0];
                    }
                    utterance.rate = 0.9;
                    utterance.pitch = 1.0;
                    window.speechSynthesis.speak(utterance);
                } else {
                    console.error('Text-to-speech not supported in this browser');
                    showToast('Text-to-speech not supported in this browser');
                }
            }

            async function saveUserPreferences() {
                const preferences = {
                    fontSize: state.settings.fontSize,
                    lineHeight: state.settings.lineHeight,
                    theme: state.settings.theme,
                    // preferHtmlView: state.settings.preferHtmlView, // Removed
                    viewRawHtmlEnabled: state.settings.viewRawHtmlEnabled, // Renamed
                    translationEnabled: DOM.translationToggle.checked,
                    autoSpeakEnabled: DOM.autoSpeakToggle.checked,
                    speakSelectionEnabled: state.settings.speakSelectionEnabled,
                    speechLanguage: DOM.speechLanguage.value
                };
                localStorage.setItem('ebook-font-size', preferences.fontSize);
                localStorage.setItem('ebook-line-height', preferences.lineHeight);
                localStorage.setItem('ebook-theme', preferences.theme);
                // localStorage.setItem('prefer-html-view-enabled', preferences.preferHtmlView); // Removed
                localStorage.setItem('view-raw-html-enabled', preferences.viewRawHtmlEnabled); // Renamed
                localStorage.setItem('translation-enabled', preferences.translationEnabled);
                localStorage.setItem('auto-speak-enabled', preferences.autoSpeakEnabled);
                localStorage.setItem('speak-selection-enabled', preferences.speakSelectionEnabled);
                localStorage.setItem('speech-language', preferences.speechLanguage);
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                try {
                    const { data, error } = await supabase.from('user_settings').select('*').eq('user_id', session.user.id).maybeSingle();
                    if (error) throw error;
                    if (!data) return;
                    const updatedSettings = { ...data, preferences: preferences };
                    const { error: updateError } = await supabase.from('user_settings').update(updatedSettings).eq('user_id', session.user.id);
                    if (updateError) throw updateError;
                } catch (error) {
                    console.error('Error saving user preferences:', error);
                }
            }

            async function loadUserPreferences() {
                const fontSizeFromStorage = parseInt(localStorage.getItem('ebook-font-size')) || 100;
                const lineHeightFromStorage = parseFloat(localStorage.getItem('ebook-line-height')) || 1.6;
                const themeFromStorage = localStorage.getItem('ebook-theme') || 'dark';
                state.settings.fontSize = fontSizeFromStorage;
                state.settings.lineHeight = lineHeightFromStorage;
                state.settings.theme = themeFromStorage;
                updateFontSize();
                updateLineHeight();
                setTheme(state.settings.theme);
                DOM.translationToggle.checked = localStorage.getItem('translation-enabled') !== 'false';
                DOM.autoSpeakToggle.checked = localStorage.getItem('auto-speak-enabled') !== 'false';
                const speechLanguage = localStorage.getItem('speech-language') || 'en-US';
                DOM.speechLanguage.value = speechLanguage;
                // const preferHtmlViewEnabled = localStorage.getItem('prefer-html-view-enabled') === 'true'; // Removed
                // state.settings.preferHtmlView = preferHtmlViewEnabled; // Removed
                // DOM.preferHtmlViewToggle.checked = preferHtmlViewEnabled; // Removed
                const viewRawHtmlEnabled = localStorage.getItem('view-raw-html-enabled') === 'true'; // Renamed
                state.settings.viewRawHtmlEnabled = viewRawHtmlEnabled; // Renamed
                DOM.viewRawHtmlToggle.checked = viewRawHtmlEnabled; // Renamed
                const speakSelectionEnabled = localStorage.getItem('speak-selection-enabled') === 'true';
                state.settings.speakSelectionEnabled = speakSelectionEnabled;
                DOM.speakSelectionToggle.checked = speakSelectionEnabled;
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                try {
                    const { data, error } = await supabase.from('user_settings').select('preferences').eq('user_id', session.user.id).maybeSingle();
                    if (error || !data || !data.preferences) return;
                    const prefs = data.preferences;
                    if (prefs.fontSize) { state.settings.fontSize = prefs.fontSize; updateFontSize(); }
                    if (prefs.lineHeight) { state.settings.lineHeight = prefs.lineHeight; updateLineHeight(); }
                    if (prefs.theme) { setTheme(prefs.theme); }
                    if (prefs.translationEnabled !== undefined) { DOM.translationToggle.checked = prefs.translationEnabled; localStorage.setItem('translation-enabled', prefs.translationEnabled); }
                    if (prefs.autoSpeakEnabled !== undefined) { DOM.autoSpeakToggle.checked = prefs.autoSpeakEnabled; localStorage.setItem('auto-speak-enabled', prefs.autoSpeakEnabled); }
                    if (prefs.speechLanguage) { DOM.speechLanguage.value = prefs.speechLanguage; localStorage.setItem('speech-language', prefs.speechLanguage); }
                    // if (prefs.preferHtmlView !== undefined) { state.settings.preferHtmlView = prefs.preferHtmlView; DOM.preferHtmlViewToggle.checked = prefs.preferHtmlView; localStorage.setItem('prefer-html-view-enabled', prefs.preferHtmlView); } // Removed
                    if (prefs.viewRawHtmlEnabled !== undefined) { state.settings.viewRawHtmlEnabled = prefs.viewRawHtmlEnabled; DOM.viewRawHtmlToggle.checked = prefs.viewRawHtmlEnabled; localStorage.setItem('view-raw-html-enabled', prefs.viewRawHtmlEnabled); } // Renamed
                    if (prefs.speakSelectionEnabled !== undefined) { state.settings.speakSelectionEnabled = prefs.speakSelectionEnabled; DOM.speakSelectionToggle.checked = prefs.speakSelectionEnabled; localStorage.setItem('speak-selection-enabled', prefs.speakSelectionEnabled); }
                } catch (error) {
                    console.error('Error loading user preferences:', error);
                }
            }

            async function generateTitleAndCategory(content, modelName) {
                if (!state.userApiSettings || !state.userApiSettings.api_key) { console.warn("Gemini API key not available for title/category generation."); return { generatedTitle: null, listId: null }; }
                if (!state.bookLists || state.bookLists.length === 0) { console.warn("No book lists available for categorization."); }
                const maxContentLength = 5000;
                const truncatedContent = content.length > maxContentLength ? content.substring(0, maxContentLength) + "..." : content;
                const listOptions = state.bookLists && state.bookLists.length > 0 ? state.bookLists.map(list => `- ${list.name} (ID: ${list.id})`).join('\n') : "No lists available.";
                const prompt = `Analyze the following text content scraped from a webpage.\n\nContent Snippet:\n---\n${truncatedContent}\n---\n\nBased on the content, perform the following tasks:\n1.  **Generate a concise and relevant title** for this content (max 10 words).\n2.  **Categorize the content** into ONE of the following existing lists. Choose the list that best fits the topic. If none fit well, choose null.\n\nAvailable Lists:\n${listOptions}\n- Unlisted (ID: null)\n\nReturn the result ONLY in this exact JSON format. The value for "list_id" MUST be either the numeric ID of the chosen list (e.g., 6) or the string "null". Do not include the list name in the "list_id" field.\n\nExample Output:\n{\n  "title": "Example Title About AI",\n  "list_id": 6 \n}\n\nAnother Example Output (if no list fits):\n{\n  "title": "Example Title About Something Else",\n  "list_id": null\n}\n\nActual Output JSON:\n{\n  "title": "Generated Title",\n  "list_id": chosen_list_id_or_null \n}`;
                const modelToUse = modelName || 'gemini-2.0-flash';
                try {
                    const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);
                    console.log("list options", listOptions);
                    if (response.error) throw new Error(response.error.message);
                    const resultText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
                    let parsedResult = {};
                    try { const jsonMatch = resultText.match(/\{[\s\S]*\}/); if (jsonMatch) parsedResult = JSON.parse(jsonMatch[0]); else { console.warn("AI did not return valid JSON for title/category.", resultText); parsedResult = { title: null, list_id: null }; } }
                    catch (jsonError) { console.error('Error parsing title/category JSON:', jsonError, resultText); parsedResult = { title: null, list_id: null }; }
                    let listId = parsedResult.list_id;
                    if (listId === 'null' || listId === null) listId = null;
                    else if (typeof listId === 'string' && !isNaN(parseInt(listId))) listId = parseInt(listId);
                    else if (typeof listId !== 'number') { console.warn(`Received unexpected list_id type: ${typeof listId}, value: ${listId}. Defaulting to null.`); listId = null; }
                    console.log("parsedResult", parsedResult);
                    console.log("got listId", listId);
                    return { generatedTitle: parsedResult.title || null, listId: listId };
                } catch (error) {
                    console.error('Error generating title and category:', error);
                    showToast(`AI title/category generation failed: ${error.message}`, 4000);
                    return { generatedTitle: null, listId: null };
                }
            }

            // Function to handle downloading the example book (restored)
            function downloadExampleBook() {
                // This function is intentionally simple.
                // The link itself handles the download via the href attribute.
                // We might add tracking or other logic here in the future if needed.
                console.log('Example book link clicked.');
                // No need to prevent default as it's a standard link.
            }

            // firecrawlScrapeRequest defined earlier, no need for duplicate

            // AI feature: Summarize Chapter (adapted from old.html)
            async function summarizeCurrentChapter() {
                if (!state.userApiSettings) {
                    showToast("Gemini API key needed for summarization. Configure in dashboard.", 4000);
                    checkAuthAndLoadApiSettings(); // Re-check in case it was just configured
                    return;
                }

                const chapter = state.bookData.chapters[state.bookData.currentPosition];
                if (!chapter) {
                    showToast("No chapter loaded to summarize.", 2000);
                    return;
                }

                const contentToSummarize = chapter.markdownContent || chapter.content || '';
                if (!contentToSummarize.trim()) {
                    showToast("Chapter content is empty, cannot summarize.", 2000);
                    return;
                }

                DOM.aiResponseArea.style.display = 'block';
                DOM.aiResponseArea.textContent = 'Generating summary...';
                DOM.summarizeChapterBtn.disabled = true;
                DOM.summarizeChapterBtn.classList.add('loading'); // Assuming loading style exists

                try {
                    // Limit content length for API
                    const maxContentLength = 15000;
                    const truncatedContent = contentToSummarize.length > maxContentLength
                        ? contentToSummarize.substring(0, maxContentLength) + "\n... [Content Truncated]"
                        : contentToSummarize;

                    const prompt = `Summarize the following text from a book chapter titled "${chapter.title}":\n\n---\n${truncatedContent}\n---\n\nProvide a concise summary (about 3-5 sentences). Focus on the key points and main ideas presented in the text.`;

                    const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, state.userApiSettings.model);

                    if (response.error) {
                        throw new Error(response.error.message);
                    }

                    const summary = response?.candidates?.[0]?.content?.parts?.[0]?.text || 'Failed to generate summary.';
                    DOM.aiResponseArea.innerHTML = marked.parse(summary); // Use marked to render potential markdown in summary

                } catch (error) {
                    console.error('Error generating summary:', error);
                    DOM.aiResponseArea.textContent = `An error occurred while generating the summary: ${error.message}`;
                } finally {
                    DOM.summarizeChapterBtn.disabled = false;
                    DOM.summarizeChapterBtn.classList.remove('loading');
                    // Scroll the settings panel to show the response area if needed
                    DOM.settingsPanel.scrollTop = DOM.settingsPanel.scrollHeight;
                }
            }


            return { init };
        })();

        document.addEventListener('DOMContentLoaded', function() {
            EbookApp.init();
        });

        function calculateOverallProgress(book) {
            if (!book.last_position) return 0;
            if (book.metadata && book.metadata.chapters && book.metadata.chapters.length > 0) {
                const chaptersLength = book.metadata.chapters.length;
                const currentChapter = book.last_position.chapter || 0;
                const chapterProgress = book.last_position.percentComplete || 0;
                const chaptersProgress = currentChapter / Math.max(1, chaptersLength - 1);
                const weightedChapterProgress = chapterProgress / chaptersLength;
                return Math.round((chaptersProgress + weightedChapterProgress) * 100);
            }
            return Math.round((book.last_position.percentComplete || 0) * 100);
        }
    </script>
</body>
</html>
