<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flashcards App</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Supabase JS library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <!-- Removed FSRS library inclusion; it is now implemented from scratch -->
    <style>
      /* Simple custom styling can be added here if needed */
      /* Add dark mode styles */
      body.dark {
        background-color: #121212;
        color: #e0e0e0;
      }

      body.dark .bg-white,
      body.dark .bg-gray-50 {
        background-color: #1e1e1e;
      }

      body.dark .text-gray-700 {
        color: #e0e0e0;
      }

      body.dark .text-gray-500,
      body.dark .text-sm.text-gray-700 {
        color: #a0a0a0;
      }

      body.dark .border {
        border-color: #333;
      }

      body.dark #app-title {
        color: #66aaff;
      }

      body.dark input,
      body.dark textarea,
      body.dark select {
        background-color: #1e1e1e;
        color: #e0e0e0;
        border-color: #333;
      }

      body.dark .bg-gray-200 {
        background-color: #333;
      }

      body.dark .bg-gray-50 {
        background-color: #1e1e1e;
      }

      body.dark .bg-blue-50 {
        background-color: #1a365d;
      }

      body.dark .modal {
        background-color: rgba(0, 0, 0, 0.8);
      }

      /* Theme toggle button */
      .theme-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #3b82f6;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 2px 8px;
        font-size: 14px;
        cursor: pointer;
        z-index: 40;
        min-width: 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
      }
      
      .theme-toggle:hover {
        transform: translateY(-1px);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
      }

      .fixed-bottom-container {
        position: fixed;
        bottom: 20px;
        left: 20px;
        right: 20px;
        z-index: 10;
        max-width: 500px;
        margin: 0 auto;
      }
      
      /* Fix to ensure review section is completely hidden when in review mode */
      #review-section.hidden {
        display: none !important;
      }
      
      @media (min-width: 768px) {
        .fixed-bottom-container {
          position: static;
          max-width: none;
          margin-bottom: 1rem;
        }
      }
      
      /* Add space at the bottom to prevent content from being hidden behind fixed buttons on mobile */
      #active-review {
        padding-bottom: 100px;
      }
      
      @media (min-width: 768px) {
        #active-review {
          padding-bottom: 1rem;
        }
      }

      /* Progress bar dark mode styles */
      body.dark .bg-gray-200 {
        background-color: #333;
      }

      body.dark #progress-bar {
        background-color: #3b82f6;
      }

      /* Add these styles to the existing <style> block */
      .line-clamp-1 {
        display: -webkit-box;
        -webkit-line-clamp: 1;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      @media (max-width: 640px) {
        #browse-cards-btn, #start-review-btn {
          display: block;
          width: 100%;
          margin-bottom: 0.5rem;
        }
        
        #browse-cards-btn {
          margin-right: 0;
        }
        
        #review-section {
          display: flex;
          flex-direction: column;
        }
      }

      #cards-container {
        max-height: 70vh;
        overflow-y: auto;
      }
      
      /* Add these styles for the drag and drop functionality */
      .word-item {
        display: inline-block;
        margin: 0.25rem;
        transition: all 0.2s ease;
      }
      
      .word-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      
      .word-item.used {
        opacity: 0.5;
        text-decoration: line-through;
      }
      
      .blank-input.drag-over {
        border-color: #3b82f6;
        background-color: #eff6ff;
      }
      
      body.dark .blank-input.drag-over {
        border-color: #3b82f6;
        background-color: #1e3a8a;
      }
      
      /* Improve word list appearance */
      #word-list {
        padding: 0.5rem;
        min-height: 3rem;
        border-radius: 0.375rem;
      }
      
      /* Make the exercise text larger and more readable */
      #exercise-text {
        font-size: 1.1rem;
        line-height: 1.7;
        padding: 1rem;
        background-color: #f9fafb;
        border-radius: 0.375rem;
      }
      
      body.dark #exercise-text {
        background-color: #1f2937;
      }

      /* Add these styles to your existing <style> block */
      @media (max-width: 640px) {
        #exercise-container {
          margin: 0;
          padding: 0.5rem;
          border-width: 0;
          border-radius: 0;
          box-shadow: none;
        }
        
        #exercise-words {
          padding: 0.5rem;
          margin-bottom: 0.5rem;
        }
        
        #exercise-text {
          padding: 0.5rem;
          margin-bottom: 0.5rem;
          font-size: 1rem;
          line-height: 1.5;
        }
        
        #word-list {
          padding: 0.25rem;
          min-height: 2.5rem;
        }
        
        .word-item {
          margin: 0.15rem;
          padding: 0.15rem 0.5rem;
        }
        
        #exercise-container .flex.justify-between {
          gap: 0.25rem;
        }
        
        #exercise-container button {
          padding: 0.5rem 0.75rem;
          font-size: 0.875rem;
        }
        
        #exercise-container h2, 
        #exercise-container h3 {
          font-size: 0.875rem;
          margin-bottom: 0.25rem;
        }
        
        #exercise-feedback {
          margin-top: 0.5rem;
          padding: 0.5rem;
        }
      }
      
      /* Add styles for tag buttons */
      .tag-button {
        transition: all 0.2s ease;
        cursor: pointer;
      }
      
      .tag-button.active {
        background-color: #3b82f6;
        color: white;
        border-color: #3b82f6;
      }
      
      body.dark .tag-button {
        border-color: #4b5563;
      }
      
      body.dark .tag-button.active {
        background-color: #3b82f6;
        color: white;
        border-color: #3b82f6;
      }
      
      body.dark .tag-button:not(.active):hover {
        background-color: #374151;
      }
      
      .tag-button:not(.active):hover {
        background-color: #f3f4f6;
      }
    </style>
  </head>
  <body class="bg-gray-50">
    <div class="max-w-4xl mx-auto p-6">
      <h1 id="app-title" class="text-3xl font-bold mb-6">Flashcards App</h1>
      <button id="theme-toggle" class="theme-toggle">☀️</button>

      <!-- Upload Section -->
      <section id="upload-section" class="mb-6 border p-4 rounded shadow bg-white">
        <h2 class="text-xl font-semibold mb-2">Upload Flashcards</h2>
        <input type="file" id="flashcards-file" accept=".json, .jsonl" class="mb-2 border p-2 rounded" />
        <br />
        <button id="upload-btn" class="bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600">
          Upload
        </button>
        <div id="upload-message" class="mt-2 text-sm text-gray-700"></div>
      </section>

      <!-- Statistics Section -->
      <section id="stats-section" class="mb-6 border p-4 rounded shadow bg-white">
        <h2 class="text-xl font-semibold mb-2">Statistics</h2>
        <p>Total Flashcards: <span id="total-count">0</span></p>
        <p>To Review: <span id="to-review-count">0</span></p>
        <p>Mastered: <span id="mastered-count">0</span></p>
        <p>Reviewed Today: <span id="reviewed-today-count">0</span></p>
      </section>

      <!-- Review Section (Start Review button) -->
      <section id="review-section" class="mb-6">
        <button id="start-review-btn" class="bg-green-500 text-white py-2 px-4 rounded hover:bg-green-600 mr-2">
          Start Review
        </button>
        <button id="browse-cards-btn" class="bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600">
          Browse Cards
        </button>
      </section>

      <!-- Update the exercise section to add configuration options -->
      <section id="exercise-section" class="mb-6">
        <button id="start-exercise-btn" class="bg-purple-500 text-white py-2 px-4 rounded hover:bg-purple-600">
          Fill-in-the-Blank Exercise
        </button>
      </section>

      <!-- Update the exercise container section to use responsive classes -->
      <section id="exercise-container" class="hidden mb-6 sm:border sm:p-4 p-1 sm:rounded sm:shadow bg-white">
        <div class="flex justify-between items-center mb-2 sm:mb-4">
          <h2 class="text-lg sm:text-xl font-semibold">Fill-in-the-Blank Exercise</h2>
          <button id="exit-exercise-btn" class="text-xs bg-gray-200 text-black py-1 px-2 rounded hover:bg-gray-300">
            Exit
          </button>
        </div>
        
        <div id="exercise-words" class="mb-2 sm:mb-4 p-2 sm:p-3 bg-gray-50 dark:bg-gray-800 rounded">
          <div id="word-list" class="flex flex-wrap gap-1 sm:gap-2">
            <!-- Other word items will be added here dynamically -->
          </div>
        </div>
        
        <div id="exercise-text" class="mb-2 sm:mb-4 p-2 sm:p-3"></div>
        
        <!-- Update the exercise control buttons to add a help button -->
        <div class="flex justify-between items-center gap-1 sm:gap-0">
          <button id="check-answers-btn" class="bg-green-500 text-white py-1 sm:py-2 px-2 sm:px-4 text-sm sm:text-base rounded hover:bg-green-600">
            Check Answers
          </button>
          <button id="help-btn" class="bg-yellow-500 text-white py-1 sm:py-2 px-2 sm:px-4 text-sm sm:text-base rounded hover:bg-yellow-600">
            Help
          </button>
          <button id="reset-exercise-btn" class="bg-gray-300 text-gray-800 py-1 sm:py-2 px-2 sm:px-4 text-sm sm:text-base rounded hover:bg-gray-400">
            Reset
          </button>
          <button id="show-answers-btn" class="bg-blue-500 text-white py-1 sm:py-2 px-2 sm:px-4 text-sm sm:text-base rounded hover:bg-blue-600">
            Show Answers
          </button>
        </div>
      </section>

      <!-- Add a new section for browsing cards between "review-section" and "progress-container" -->
      <section id="browse-cards-section" class="hidden mb-6 border p-4 rounded shadow bg-white">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-semibold">Browse Flashcards</h2>
          <button id="close-browse-btn" class="text-sm bg-gray-200 text-black py-1 px-2 rounded hover:bg-gray-300">
            Close
          </button>
        </div>
        
        <div id="cards-container" class="space-y-4">
          <!-- Cards will be inserted here -->
        </div>
        
        <div class="flex justify-between items-center mt-4">
          <button id="prev-page-btn" class="bg-gray-200 text-black py-1 px-3 rounded hover:bg-gray-300 disabled:opacity-50">
            Previous
          </button>
          <span id="page-info">Page 1</span>
          <button id="next-page-btn" class="bg-gray-200 text-black py-1 px-3 rounded hover:bg-gray-300">
            Next
          </button>
        </div>
      </section>

      <!-- Move progress bar outside and above the active review section -->
      <div id="progress-container" class="hidden mb-1">
        <div class="w-full bg-gray-200 rounded-full h-1 dark:bg-gray-700">
          <div id="progress-bar" class="bg-blue-600 h-1 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
      </div>

      <!-- Active Review UI -->
      <section id="active-review" class="hidden border p-4 rounded shadow bg-white relative">
        <button id="exit-review-btn" class="absolute top-2 right-2 text-sm bg-gray-200 text-black py-1 px-2 rounded hover:bg-gray-300">
          Exit Review
        </button>
        
        <!-- Card action buttons - positioned at the top-left corner -->
        <div class="absolute top-2 left-2 flex gap-2">
          <button id="edit-card-btn" class="text-sm bg-blue-100 text-blue-700 py-1 px-2 rounded hover:bg-blue-200">
            Edit
          </button>
          <button id="delete-card-btn" class="text-sm bg-red-100 text-red-700 py-1 px-2 rounded hover:bg-red-200">
            Delete
          </button>
        </div>
        
        <div id="card-container" class="mb-4 mt-8">
          <!-- Question card -->
          <div class="bg-gray-50 p-6 rounded-lg mb-4 min-h-[200px] flex flex-col justify-center">
            <div id="card-question" class="text-xl text-center"></div>
          </div>
          
          <!-- Answer card (initially hidden) -->
          <div id="answer-container" class="hidden">
            <div class="bg-blue-50 p-6 rounded-lg mb-4 min-h-[200px] flex flex-col justify-center">
              <div id="card-answer" class="text-xl text-center"></div>
            </div>
          </div>

          <!-- Fixed position for show answer and feedback buttons -->
          <div class="fixed-bottom-container">
            <button id="show-answer-btn" class="bg-blue-500 text-white py-3 px-4 rounded hover:bg-blue-600 w-full mb-2">
              Show Answer
            </button>
            
            <div id="feedback-buttons" class="hidden w-full">
              <div class="flex gap-2">
                <button id="again-btn" class="bg-red-500 text-white py-3 px-4 rounded hover:bg-red-600 flex-1">
                  Again
                </button>
                <button id="good-btn" class="bg-green-500 text-white py-3 px-4 rounded hover:bg-green-600 flex-1">
                  Good
                </button>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <!-- Edit Card Modal -->
    <div id="edit-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal">
      <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4">Edit Flashcard</h3>
        <form id="edit-card-form">
          <div class="mb-4">
            <label for="edit-word" class="block text-sm font-medium mb-1">Word</label>
            <input type="text" id="edit-word" class="w-full p-2 border rounded" required>
          </div>
          <div class="mb-4">
            <label for="edit-phrase" class="block text-sm font-medium mb-1">Phrase (Question)</label>
            <textarea id="edit-phrase" class="w-full p-2 border rounded" rows="3" required></textarea>
          </div>
          <div class="mb-4">
            <label for="edit-translation" class="block text-sm font-medium mb-1">Translation (Answer)</label>
            <textarea id="edit-translation" class="w-full p-2 border rounded" rows="3" required></textarea>
          </div>
          <div class="mb-4">
            <label for="edit-ipa" class="block text-sm font-medium mb-1">IPA Pronunciation (Optional)</label>
            <input type="text" id="edit-ipa" class="w-full p-2 border rounded">
          </div>
          <div class="flex justify-end gap-2 mt-6">
            <button type="button" id="cancel-edit-btn" class="bg-gray-300 text-gray-800 py-2 px-4 rounded hover:bg-gray-400">
              Cancel
            </button>
            <button type="submit" class="bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600">
              Save Changes
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal">
      <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 w-full max-w-md">
        <h3 class="text-xl font-bold mb-4">Delete Flashcard</h3>
        <p class="mb-6">Are you sure you want to delete this flashcard? This action cannot be undone.</p>
        <div class="flex justify-end gap-2">
          <button id="cancel-delete-btn" class="bg-gray-300 text-gray-800 py-2 px-4 rounded hover:bg-gray-400">
            Cancel
          </button>
          <button id="confirm-delete-btn" class="bg-red-500 text-white py-2 px-4 rounded hover:bg-red-600">
            Delete
          </button>
        </div>
      </div>
    </div>

    <!-- Add the Exercise Configuration Modal -->
    <div id="exercise-config-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4 modal">
      <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 w-full max-w-md">
        <h3 class="text-xl font-bold mb-4">Configure Exercise</h3>
        <div class="mb-4">
          <label for="modal-exercise-model-select" class="block text-sm font-medium mb-1">Model</label>
          <select id="modal-exercise-model-select" class="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
            <option value="gemini-2.0-pro-exp-02-05">Gemini Pro (Default)</option>
            <option value="gemini-2.0-flash">Gemini Flash</option>
            <option value="gemini-2.0-flash-lite-preview-02-05">Gemini Flash Lite</option>
            <option value="gemini-2.0-flash-thinking-exp-01-21">Gemini Flash Thinking</option>
          </select>
        </div>
        <div class="mb-4">
          <label for="modal-exercise-cards-count" class="block text-sm font-medium mb-1">Number of Cards</label>
          <input type="number" id="modal-exercise-cards-count" min="5" max="15" value="5" class="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600">
        </div>
        <!-- Add the new section for content style tags -->
        <div class="mb-6">
          <label class="block text-sm font-medium mb-2">Content Style</label>
          <div id="exercise-tags-container" class="flex flex-wrap gap-2">
            <button class="tag-button px-2 py-1 text-xs rounded border active" data-tag="easy-to-read">easy-to-read</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="extremely-short">extremely-short</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="advanced">advanced</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="knowledge">knowledge</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="fact">fact</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="story">story</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="humor">humor</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="love-advice">love-advice</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="life">life</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="inspirational">inspirational</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="business">business</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="travel">travel</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="food">food</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="technology">technology</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="fantasy">fantasy</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="cultural">cultural</button>
            <button class="tag-button px-2 py-1 text-xs rounded border" data-tag="slang">slang</button>
          </div>
        </div>
        <div class="flex justify-end gap-2">
          <button id="cancel-exercise-btn" class="bg-gray-300 text-gray-800 py-2 px-4 rounded hover:bg-gray-400">
            Cancel
          </button>
          <button id="confirm-exercise-btn" class="bg-purple-500 text-white py-2 px-4 rounded hover:bg-purple-600">
            Start Exercise
          </button>
        </div>
      </div>
    </div>

    <script type="module">
      // --- FSRS Implementation (from scratch) ---
      // Remove external FSRS import and implement internally based on the provided tutorial

      // FSRS parameters
      const W = [
        0.40255, 1.18385, 3.173, 15.69105,
        7.1949, 0.5345, 1.4604, 0.0046,
        1.54575, 0.1192, 1.01925, 1.9395,
        0.11, 0.29605, 2.2698, 0.2315,
        2.9898, 0.51655, 0.6621
      ];

      const F = 19.0 / 81.0;
      const C = -0.5;

      // Grade enumeration
      const Grade = {
        Forgot: 1,
        Hard: 2,
        Good: 3,
        Easy: 4
      };

      function retrievability(t, s) {
        return Math.pow(1 + F * (t / s), C);
      }

      function interval(r_d, s) {
        return (s / F) * (Math.pow(r_d, 1 / C) - 1);
      }

      function s0(grade) {
        if (grade === Grade.Forgot) return W[0];
        if (grade === Grade.Hard) return W[1];
        if (grade === Grade.Good) return W[2];
        if (grade === Grade.Easy) return W[3];
      }

      function s_success(d, s, r, grade) {
        let t_d = 11.0 - d;
        let t_s = Math.pow(s, -W[9]);
        let t_r = Math.exp(W[10] * (1.0 - r)) - 1.0;
        let h = (grade === Grade.Hard) ? W[15] : 1.0;
        let b = (grade === Grade.Easy) ? W[16] : 1.0;
        let c_val = Math.exp(W[8]);
        let alpha = 1.0 + t_d * t_s * t_r * h * b * c_val;
        return s * alpha;
      }

      function s_fail(d, s, r) {
        let d_f = Math.pow(d, -W[12]);
        let s_f_val = Math.pow(s + 1.0, W[13]) - 1.0;
        let r_f = Math.exp(W[14] * (1.0 - r));
        let c_f = W[11];
        const new_s = d_f * s_f_val * r_f * c_f;
        return Math.min(new_s, s);
      }

      function updated_stability(d, s, r, grade) {
        return (grade === Grade.Forgot)
          ? s_fail(d, s, r)
          : s_success(d, s, r, grade);
      }

      function clamp_d(d_val) {
        return Math.max(1.0, Math.min(d_val, 10.0));
      }

      function d0(grade) {
        return clamp_d(W[4] - Math.exp(W[5] * (grade - 1)) + 1.0);
      }

      function delta_d(grade) {
        return -W[6] * (grade - 3);
      }

      function updated_difficulty(d, grade) {
        const d0_easy = d0(Grade.Easy);
        const new_d = W[7] * d0_easy + (1 - W[7]) * (d + delta_d(grade) * ((10 - d) / 9));
        return clamp_d(new_d);
      }

      // FSRS repeat function: updates card state given a review grade
      const fsrs = {
        repeat: function(card, grade, now) {
          const r_d = 0.9; // desired retention
          const interval_before = Math.max(Math.round(interval(r_d, card.stability)), 1);
          const r = retrievability(interval_before, card.stability);
          const newStability = updated_stability(card.difficulty, card.stability, r, grade);
          const newDifficulty = updated_difficulty(card.difficulty, grade);
          let newInterval = Math.max(Math.round(interval(r_d, newStability)), 1);
          
          // If the card is marked as "Again" (Grade.Forgot), reduce the interval further.
          if (grade === Grade.Forgot) {
            const penaltyFactor = 0.5;  // Adjust this value to penalize more or less.
            newInterval = Math.max(Math.round(newInterval * penaltyFactor), 1);
          }
          
          const newDue = new Date(now.getTime() + newInterval * 24 * 60 * 60 * 1000).toISOString();
          let newReps = card.reps;
          let newLapses = card.lapses;
          if (grade === Grade.Forgot) {
            newLapses = card.lapses + 1;
          } else {
            newReps = card.reps + 1;
          }
          return {
            state: "reviewed",
            due: newDue,
            stability: newStability,
            difficulty: newDifficulty,
            reps: newReps,
            lapses: newLapses,
            scheduled_days: newInterval,
            elapsed_days: interval_before
          };
        }
      };

      // --- End FSRS Implementation ---

      // Initialize Supabase client (replace with your project's credentials)
      const supabaseUrl = 'https://iioxqphxakvhhtyvdhrh.supabase.co';
      const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpb3hxcGh4YWt2aGh0eXZkaHJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg4MzQ5MjAsImV4cCI6MjA1NDQxMDkyMH0.7I2CaBH1DyiRYEtzunIM5-l3GaWYT15Mly39jW-ga5Q';
      const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);

      // Global variables to store user info, flashcards and review session data
      let userId;
      let flashcards = []; // loaded flashcards from DB
      let reviewQueue = []; // queue for cards due for review
      const masteryThreshold = 3; // flashcard is "mastered" after 3 correct reviews

      // Add a new global variable to track total cards in review session
      let initialReviewCount = 0;
      let cardsCompleted = 0;

      // Add these globals for card browsing pagination
      let currentPage = 1;
      const cardsPerPage = 10;
      let totalCards = 0;
      let totalPages = 0;

      // DOM Elements
      const uploadFileInput = document.getElementById('flashcards-file');
      const uploadBtn = document.getElementById('upload-btn');
      const uploadMessage = document.getElementById('upload-message');
      const totalCountSpan = document.getElementById('total-count');
      const toReviewCountSpan = document.getElementById('to-review-count');
      const masteredCountSpan = document.getElementById('mastered-count');
      const startReviewBtn = document.getElementById('start-review-btn');
      const activeReviewSection = document.getElementById('active-review');
      const cardContent = document.getElementById('card-content');
      const showAnswerBtn = document.getElementById('show-answer-btn');
      const feedbackButtons = document.getElementById('feedback-buttons');

      // Global variable for the current card being reviewed
      let currentCard = null;

      // Edit and Delete functionality
      const editCardBtn = document.getElementById('edit-card-btn');
      const deleteCardBtn = document.getElementById('delete-card-btn');
      const editModal = document.getElementById('edit-modal');
      const deleteModal = document.getElementById('delete-modal');
      const editForm = document.getElementById('edit-card-form');
      const cancelEditBtn = document.getElementById('cancel-edit-btn');
      const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
      const confirmDeleteBtn = document.getElementById('confirm-delete-btn');

      // Function to play audio from base64 string
      function playAudio(base64AudioData) {
        if (!base64AudioData) {
          console.log("No audio data available");
          return;
        }
        
        try {
          // Create audio element
          const audio = new Audio(`data:audio/mp3;base64,${base64AudioData}`);
          audio.play().catch(error => {
            console.error("Error playing audio:", error);
          });
        } catch (error) {
          console.error("Error setting up audio:", error);
        }
      }

      // Check authentication on page load
      async function checkAuth() {
        const { data: { session } } = await supabase.auth.getSession();
        if (!session) {
          // Redirect back to login/dashboard if no session
          window.location.href = 'index.html';
          return;
        }
        userId = session.user.id;
        // After auth, load the current flashcards
        await loadFlashcards();
      }

      // Load flashcards for the current user from Supabase
      async function loadFlashcards() {
        const { data, error } = await supabase
          .from('flashcards')
          .select('*')
          .eq('user_id', userId);
        if (error) {
          console.error("Error loading flashcards:", error);
          return;
        }
        flashcards = data || [];
        // Initialize FSRS state for cards that don't have it
        flashcards = flashcards.map(card => ({
          ...card,
          state: card.state || "new",
          due: card.due || new Date().toISOString(),
          stability: card.stability || s0(Grade.Good),
          difficulty: card.difficulty || d0(Grade.Good),
          elapsed_days: card.elapsed_days || 0,
          scheduled_days: card.scheduled_days || 0,
          reps: card.reps || 0,
          lapses: card.lapses || 0,
        }));
        updateStats();
        
        // Update the exercise card count based on available due cards
        updateExerciseCardCount();
      }

      // Update the statistics display based on flashcards loaded
      function updateStats() {
        const total = flashcards.length;
        const now = new Date();
        const toReview = flashcards.filter(card => new Date(card.due) <= now).length;
        const mastered = flashcards.filter(card => card.reps >= masteryThreshold).length;
        
        // Calculate how many flashcards were reviewed today
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const reviewedToday = flashcards.filter(card => {
          if (!card.last_reviewed) return false;
          const lastReviewed = new Date(card.last_reviewed);
          return lastReviewed >= todayStart;
        }).length;
        
        totalCountSpan.textContent = total;
        toReviewCountSpan.textContent = toReview;
        masteredCountSpan.textContent = mastered;
        document.getElementById('reviewed-today-count').textContent = reviewedToday;
      }

      // Event handler: Upload flashcards from JSON or JSONL file
      uploadBtn.addEventListener('click', async () => {
        const file = uploadFileInput.files[0];
        if (!file) {
          uploadMessage.textContent = 'Please select a JSON or JSONL file to upload.';
          return;
        }
        try {
          const text = await file.text();
          let uploadedCards = [];
          // If file content starts with '[', assume a JSON array; otherwise use JSONL processing.
          if (text.trim().startsWith('[')) {
            uploadedCards = JSON.parse(text);
          } else {
            // Process JSONL: split by newline and parse each line
            uploadedCards = text
              .trim()
              .split(/\r?\n/)
              .filter(line => line.trim() !== '')
              .map(line => JSON.parse(line));
          }
          if (!Array.isArray(uploadedCards)) {
            uploadMessage.textContent = 'Invalid format: JSON must be an array or JSONL format.';
            return;
          }
          // Get existing words to check for duplication
          const existingWords = flashcards.map(card => card.word);
          const newCards = [];
          uploadedCards.forEach(card => {
            // Support both "translation_answer" (from jsonl) and "translationAnswer" keys.
            if (!existingWords.includes(card.word)) {
              newCards.push({
                user_id: userId,
                word: card.word, // e.g: "endeavor"
                phrase: card.phrase, // e.g: "To <b>endeavor</b> is to try hard to do or achieve something."
                translation_answer: card.translation_answer || card.translationAnswer, // e.g: "nỗ lực\nTry hard to do or achieve something."
                reps: 0,
                lapses: 0,
                last_reviewed: null,
                ipa: card.ipa || null,
                word_audio: card.wordAudio || null,
                phrase_audio: card.phraseAudio || null
              });
            }
          });
          if (newCards.length === 0) {
            uploadMessage.textContent = 'No new flashcards to add (all duplicates).';
          } else {
            const { error } = await supabase
              .from('flashcards')
              .insert(newCards);
            if (error) {
              uploadMessage.textContent = 'Error uploading flashcards: ' + error.message;
              return;
            }
            uploadMessage.textContent = `Successfully uploaded ${newCards.length} flashcards.`;
            // Clear the file input
            uploadFileInput.value = '';
            // Reload flashcards after insertion
            await loadFlashcards();
          }
        } catch (err) {
          console.error(err);
          uploadMessage.textContent = 'Error processing the file.';
        }
      });

      // Event handler: Start review session.
      startReviewBtn.addEventListener('click', async () => {
        // Reload flashcards first
        await loadFlashcards();
        
        // Build the review queue (cards that are due for review)
        const now = new Date();
        reviewQueue = flashcards.filter(card => 
          new Date(card.due) <= now && card.reps < masteryThreshold
        );
        
        if (reviewQueue.length === 0) {
          alert("No cards due for review!");
          return;
        }
        
        // Shuffle the review queue using Fisher-Yates algorithm
        for (let i = reviewQueue.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [reviewQueue[i], reviewQueue[j]] = [reviewQueue[j], reviewQueue[i]];
        }
        
        // Limit queue to maximum 20 cards per session
        if (reviewQueue.length > 20) {
          reviewQueue = reviewQueue.slice(0, 20);
        }
        
        // Reset progress tracking counters
        cardsCompleted = 0;
        initialReviewCount = reviewQueue.length;
        
        // Hide upload / stats sections during review
        document.getElementById('app-title').classList.add('hidden');
        document.getElementById('upload-section').classList.add('hidden');
        document.getElementById('stats-section').classList.add('hidden');
        document.getElementById('review-section').classList.add('hidden');
        
        // Make sure any browse cards UI is hidden too
        document.getElementById('browse-cards-section').classList.add('hidden');
        
        // Show the review interface and progress bar
        document.getElementById('progress-container').classList.remove('hidden');
        activeReviewSection.classList.remove('hidden');
        
        showNextCard();
      });

      // Show the next card from the reviewQueue
      function showNextCard() {
        if (reviewQueue.length === 0) {
          document.getElementById('card-question').innerHTML = "Review session completed!";
          document.getElementById('answer-container').classList.add('hidden');
          showAnswerBtn.classList.add('hidden');
          feedbackButtons.classList.add('hidden');
          editCardBtn.classList.add('hidden');
          deleteCardBtn.classList.add('hidden');
          
          // Update progress bar to 100%
          document.getElementById('progress-bar').style.width = "100%";
          
          // Return to main view after 3 seconds
          setTimeout(() => {
            // Show all main sections again
            document.getElementById('app-title').classList.remove('hidden');
            document.getElementById('upload-section').classList.remove('hidden');
            document.getElementById('stats-section').classList.remove('hidden');
            document.getElementById('review-section').classList.remove('hidden');
            // Hide the review interface
            activeReviewSection.classList.add('hidden');
            // Reset button visibility
            editCardBtn.classList.remove('hidden');
            deleteCardBtn.classList.remove('hidden');
            
            // Also hide progress container
            document.getElementById('progress-container').classList.add('hidden');
          }, 3000);
          
          return;
        }

        // Make sure edit/delete buttons are visible
        editCardBtn.classList.remove('hidden');
        deleteCardBtn.classList.remove('hidden');

        // We already filtered for due cards when building the queue, no need to filter again
        const card = reviewQueue.shift();
        currentCard = card;
        
        // Display the prompt and handle HTML rendering
        document.getElementById('card-question').innerHTML = card.phrase;
        
        // Play phrase audio if available
        if (card.phrase_audio) {
          playAudio(card.phrase_audio);
        }
        
        // Reset the answer container
        document.getElementById('answer-container').classList.add('hidden');
        
        // Format the answer with first line in bold
        const answerLines = card.translation_answer.split('\n');
        let formattedAnswer = `<strong class="text-2xl block mb-4">${answerLines[0]}</strong>` + 
          (answerLines.slice(1).join('\n'));
        
        // Add IPA if available
        if (card.ipa) {
          formattedAnswer = `<div class="text-xl block mb-2 text-gray-500">[${card.ipa}]</div>` + formattedAnswer;
        }
        
        document.getElementById('card-answer').innerHTML = formattedAnswer;
        // Reset the UI
        showAnswerBtn.classList.remove('hidden');
        feedbackButtons.classList.add('hidden');
      }

      // Event handler: Reveal the answer
      showAnswerBtn.addEventListener('click', () => {
        if (!currentCard) return;
        
        document.getElementById('answer-container').classList.remove('hidden');
        showAnswerBtn.classList.add('hidden');
        feedbackButtons.classList.remove('hidden');
        
        // Play word audio when showing the answer
        if (currentCard.word_audio) {
          playAudio(currentCard.word_audio);
        } else {
          // If no audio file exists, use speech synthesis to speak the word
          const utterance = new SpeechSynthesisUtterance(currentCard.word);
          // Optional: You can set language, rate, pitch, etc.
          // utterance.lang = 'en-US';
          // utterance.rate = 0.9;
          window.speechSynthesis.speak(utterance);
        }
      });

      // Event handler for "good" button (treat as Grade.Good)
      document.getElementById('good-btn').addEventListener('click', async () => {
        if (!currentCard) return;
        
        const now = new Date();
        const card = {
          state: currentCard.state || "new",
          due: currentCard.due,
          stability: currentCard.stability || s0(Grade.Good),
          difficulty: currentCard.difficulty || d0(Grade.Good),
          elapsed_days: currentCard.elapsed_days || 0,
          scheduled_days: currentCard.scheduled_days || 0,
          reps: currentCard.reps || 0,
          lapses: currentCard.lapses || 0,
        };

        try {
          // Update using our FSRS implementation with Grade.Good
          const result = fsrs.repeat(card, Grade.Good, now);

          // Update local copy immediately and update stats
          Object.assign(currentCard, result);
          currentCard.last_reviewed = now.toISOString();
          
          // Update the database
          const { error } = await supabase
            .from('flashcards')
            .update({
              state: result.state,
              due: result.due,
              stability: result.stability,
              difficulty: result.difficulty,
              elapsed_days: result.elapsed_days,
              scheduled_days: result.scheduled_days,
              reps: result.reps,
              lapses: result.lapses,
              last_reviewed: now.toISOString()
            })
            .eq('id', currentCard.id);
            
          if (error) {
            console.error("Error updating flashcard:", error);
            setTimeout(() => {
              updateProgressBar();
            }, 2000);
          }
          
          // Increment the count of completed cards on a correct review
          cardsCompleted++;
          
          updateStats();
          showNextCard();
          updateProgressBar();
          
        } catch (err) {
          console.error("Error in review process:", err);
        }
      });

      // Event handler for "again" button (treat as Grade.Forgot)
      document.getElementById('again-btn').addEventListener('click', async () => {
        if (!currentCard) return;

        const now = new Date();
        const card = {
          state: currentCard.state || "new",
          due: currentCard.due,
          stability: currentCard.stability || s0(Grade.Good),
          difficulty: currentCard.difficulty || d0(Grade.Good),
          elapsed_days: currentCard.elapsed_days || 0,
          scheduled_days: currentCard.scheduled_days || 0,
          reps: currentCard.reps || 0,
          lapses: currentCard.lapses || 0,
        };

        try {
          // Update using our FSRS implementation with Grade.Forgot
          const result = fsrs.repeat(card, Grade.Forgot, now);

          // Update local copy immediately
          Object.assign(currentCard, result);
          currentCard.last_reviewed = now.toISOString();
          
          // Place the card back in the review queue for another try
          reviewQueue.push(currentCard);
          
          // Update the database
          const { error } = await supabase
            .from('flashcards')
            .update({
              state: result.state,
              due: result.due,
              stability: result.stability,
              difficulty: result.difficulty,
              elapsed_days: result.elapsed_days,
              scheduled_days: result.scheduled_days,
              reps: result.reps,
              lapses: result.lapses,
              last_reviewed: now.toISOString()
            })
            .eq('id', currentCard.id);
            
          if (error) {
            console.error("Error updating flashcard:", error);
          }
          
          updateStats();
          showNextCard();
          
        } catch (err) {
          console.error("Error in review process:", err);
        }
      });

      // Event handler: Exit Review Session
      document.getElementById('exit-review-btn').addEventListener('click', () => {
        // Show main sections again
        document.getElementById('app-title').classList.remove('hidden');
        document.getElementById('upload-section').classList.remove('hidden');
        document.getElementById('stats-section').classList.remove('hidden');
        document.getElementById('review-section').classList.remove('hidden');
        // Hide the review interface
        activeReviewSection.classList.add('hidden');
        // Clear the remaining review queue
        reviewQueue = [];
        // Update statistics in case any changes occurred during the session
        updateStats();
        
        // Hide the progress container too
        document.getElementById('progress-container').classList.add('hidden');
        
        // Reset progress bar when exiting
        document.getElementById('progress-bar').style.width = "0%";
      });

      // Event handler: Open edit modal
      editCardBtn.addEventListener('click', () => {
        if (!currentCard) return;
        
        // Fill form with current card details
        document.getElementById('edit-word').value = currentCard.word || '';
        document.getElementById('edit-phrase').value = currentCard.phrase || '';
        document.getElementById('edit-translation').value = currentCard.translation_answer || '';
        document.getElementById('edit-ipa').value = currentCard.ipa || '';
        
        // Show the modal
        editModal.classList.remove('hidden');
      });

      // Event handler: Cancel edit
      cancelEditBtn.addEventListener('click', () => {
        editModal.classList.add('hidden');
      });

      // Event handler: Submit edit form
      editForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        if (!currentCard) {
          editModal.classList.add('hidden');
          return;
        }
        
        // Get updated values
        const updatedCard = {
          word: document.getElementById('edit-word').value.trim(),
          phrase: document.getElementById('edit-phrase').value.trim(),
          translation_answer: document.getElementById('edit-translation').value.trim(),
          ipa: document.getElementById('edit-ipa').value.trim() || null
        };
        
        try {
          // Update the database
          const { error } = await supabase
            .from('flashcards')
            .update(updatedCard)
            .eq('id', currentCard.id);
            
          if (error) {
            console.error("Error updating flashcard:", error);
            alert("Error updating flashcard. Please try again.");
            return;
          }
          
          // Update the current card in memory
          Object.assign(currentCard, updatedCard);
          
          // If we're currently showing the card, update the display
          document.getElementById('card-question').innerHTML = currentCard.phrase;
          
          // If the answer is visible, update it too
          if (!document.getElementById('answer-container').classList.contains('hidden')) {
            // Format the answer with first line in bold
            const answerLines = currentCard.translation_answer.split('\n');
            let formattedAnswer = `<strong class="text-2xl block mb-4">${answerLines[0]}</strong>` + 
              (answerLines.slice(1).join('\n'));
            
            // Add IPA if available
            if (currentCard.ipa) {
              formattedAnswer = `<div class="text-xl block mb-2 text-gray-500">[${currentCard.ipa}]</div>` + formattedAnswer;
            }
            
            document.getElementById('card-answer').innerHTML = formattedAnswer;
          }
          
          // Close the modal
          editModal.classList.add('hidden');
          
        } catch (err) {
          console.error("Error in card update process:", err);
          alert("An error occurred. Please try again.");
        }
      });

      // Event handler: Open delete confirmation
      deleteCardBtn.addEventListener('click', () => {
        if (!currentCard) return;
        deleteModal.classList.remove('hidden');
      });

      // Event handler: Cancel delete
      cancelDeleteBtn.addEventListener('click', () => {
        deleteModal.classList.add('hidden');
      });

      // Event handler: Confirm delete
      confirmDeleteBtn.addEventListener('click', async () => {
        if (!currentCard) {
          deleteModal.classList.add('hidden');
          return;
        }
        
        try {
          // Delete from the database
          const { error } = await supabase
            .from('flashcards')
            .delete()
            .eq('id', currentCard.id);
            
          if (error) {
            console.error("Error deleting flashcard:", error);
            alert("Error deleting flashcard. Please try again.");
            return;
          }
          
          // Remove the card from the flashcards array
          const deletedCardIndex = flashcards.findIndex(card => card.id === currentCard.id);
          if (deletedCardIndex !== -1) {
            flashcards.splice(deletedCardIndex, 1);
          }
          
          // Close the modal
          deleteModal.classList.add('hidden');
          
          // Update stats display
          updateStats();
          
          // Show next card or end review if queue is empty
          if (reviewQueue.length === 0) {
            document.getElementById('card-question').innerHTML = "Review session completed!";
            document.getElementById('answer-container').classList.add('hidden');
            showAnswerBtn.classList.add('hidden');
            feedbackButtons.classList.add('hidden');
            editCardBtn.classList.add('hidden');
            deleteCardBtn.classList.add('hidden');
            
            // Return to main view after 3 seconds
            setTimeout(() => {
              // Show all main sections again
              document.getElementById('app-title').classList.remove('hidden');
              document.getElementById('upload-section').classList.remove('hidden');
              document.getElementById('stats-section').classList.remove('hidden');
              document.getElementById('review-section').classList.remove('hidden');
              // Hide the review interface
              activeReviewSection.classList.add('hidden');
              // Reset button visibility
              editCardBtn.classList.remove('hidden');
              deleteCardBtn.classList.remove('hidden');
            }, 3000);
          } else {
            showNextCard();
          }
        } catch (err) {
          console.error("Error in delete process:", err);
          alert("An error occurred. Please try again.");
        }
      });

      // Theme handling
      document.addEventListener('DOMContentLoaded', () => {
        const theme = localStorage.getItem('theme') || 'dark';
        document.body.classList.add(theme);
        
        const themeToggle = document.getElementById('theme-toggle');
        // Set initial button content based on theme
        themeToggle.textContent = document.body.classList.contains('dark') ? '☀️' : '🌙';
        
        themeToggle.addEventListener('click', () => {
          if (document.body.classList.contains('dark')) {
            document.body.classList.remove('dark');
            document.body.classList.add('light');
            localStorage.setItem('theme', 'light');
            themeToggle.textContent = '🌙';
          } else {
            document.body.classList.remove('light');
            document.body.classList.add('dark');
            localStorage.setItem('theme', 'dark');
            themeToggle.textContent = '☀️';
          }
        });

        // Close modals when clicking outside of them
        window.addEventListener('click', (event) => {
          if (event.target === editModal) {
            editModal.classList.add('hidden');
          }
          if (event.target === deleteModal) {
            deleteModal.classList.add('hidden');
          }
        });
      });

      // Check for authentication on page load
      checkAuth();

      // Event handler: Browse cards button
      document.getElementById('browse-cards-btn').addEventListener('click', async () => {
        // Reset pagination
        currentPage = 1;
        
        // Hide the main sections
        document.getElementById('app-title').classList.add('hidden');
        document.getElementById('upload-section').classList.add('hidden');
        document.getElementById('stats-section').classList.add('hidden');
        document.getElementById('review-section').classList.add('hidden');
        
        // Show the browse cards section
        document.getElementById('browse-cards-section').classList.remove('hidden');
        
        // Load the first page of cards
        await loadCardsPage();
      });

      // Event handler: Close browse section
      document.getElementById('close-browse-btn').addEventListener('click', () => {
        // Hide browse section
        document.getElementById('browse-cards-section').classList.add('hidden');
        
        // Show main sections again
        document.getElementById('app-title').classList.remove('hidden');
        document.getElementById('upload-section').classList.remove('hidden');
        document.getElementById('stats-section').classList.remove('hidden');
        document.getElementById('review-section').classList.remove('hidden');
      });

      // Event handler: Previous page
      document.getElementById('prev-page-btn').addEventListener('click', async () => {
        if (currentPage > 1) {
          currentPage--;
          await loadCardsPage();
        }
      });

      // Event handler: Next page
      document.getElementById('next-page-btn').addEventListener('click', async () => {
        if (currentPage < totalPages) {
          currentPage++;
          await loadCardsPage();
        }
      });

      // Function to load a page of cards
      async function loadCardsPage() {
        try {
          // First, get the total count of cards
          const { count, error: countError } = await supabase
            .from('flashcards')
            .select('*', { count: 'exact', head: true })
            .eq('user_id', userId);
            
          if (countError) {
            console.error("Error counting flashcards:", countError);
            return;
          }
          
          totalCards = count || 0;
          totalPages = Math.ceil(totalCards / cardsPerPage);
          
          // Update pagination display
          document.getElementById('page-info').textContent = `Page ${currentPage} of ${totalPages || 1}`;
          
          // Disable/enable pagination buttons
          document.getElementById('prev-page-btn').disabled = (currentPage <= 1);
          document.getElementById('next-page-btn').disabled = (currentPage >= totalPages);
          
          // Calculate range for the current page
          const from = (currentPage - 1) * cardsPerPage;
          const to = from + cardsPerPage - 1;
          
          // Fetch cards for current page, ordered by due date (overdue cards first)
          const { data, error } = await supabase
            .from('flashcards')
            .select('*')
            .eq('user_id', userId)
            .range(from, to)
            .order('due', { ascending: true })
            .order('word', { ascending: true });
            
          if (error) {
            console.error("Error loading flashcards page:", error);
            return;
          }
          
          // Clear the container
          const cardsContainer = document.getElementById('cards-container');
          cardsContainer.innerHTML = '';
          
          // If no cards, show a message
          if (!data || data.length === 0) {
            cardsContainer.innerHTML = '<p class="text-center py-4">No flashcards found.</p>';
            return;
          }
          
          // Render each card
          data.forEach(card => {
            // Format the due date
            const dueDate = new Date(card.due);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Calculate days until due
            const diffTime = dueDate - today;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            let dueText;
            if (diffDays < 0) {
              dueText = 'Overdue';
            } else if (diffDays === 0) {
              dueText = 'Due today';
            } else {
              dueText = `Due in ${diffDays} day${diffDays !== 1 ? 's' : ''}`;
            }
            
            // Create card element
            const cardElement = document.createElement('div');
            cardElement.className = 'border rounded-lg p-4 hover:bg-gray-50 dark:hover:bg-gray-800';
            cardElement.innerHTML = `
              <div class="flex flex-col md:flex-row justify-between">
                <div class="flex-grow mb-2 md:mb-0">
                  <h3 class="text-lg font-medium">${card.word}</h3>
                  <p class="text-sm ${diffDays < 0 ? 'text-red-500' : 'text-gray-500'}">${dueText}</p>
                </div>
                <div class="flex gap-2">
                  <button class="edit-browse-card text-xs bg-blue-100 text-blue-700 py-1 px-2 rounded hover:bg-blue-200" 
                    data-card-id="${card.id}">
                    Edit
                  </button>
                  <button class="delete-browse-card text-xs bg-red-100 text-red-700 py-1 px-2 rounded hover:bg-red-200"
                    data-card-id="${card.id}">
                    Delete
                  </button>
                </div>
              </div>
              <p class="text-sm text-gray-700 mt-2 line-clamp-1">${card.phrase}</p>
            `;
            
            cardsContainer.appendChild(cardElement);
          });
          
          // Add event listeners for edit and delete buttons
          document.querySelectorAll('.edit-browse-card').forEach(button => {
            button.addEventListener('click', async () => {
              const cardId = button.getAttribute('data-card-id');
              await openEditCardModal(cardId);
            });
          });
          
          document.querySelectorAll('.delete-browse-card').forEach(button => {
            button.addEventListener('click', async () => {
              const cardId = button.getAttribute('data-card-id');
              await openDeleteCardModal(cardId);
            });
          });
          
        } catch (err) {
          console.error("Error browsing cards:", err);
        }
      }

      // Function to open edit modal for a specific card
      async function openEditCardModal(cardId) {
        try {
          // Fetch the card details
          const { data, error } = await supabase
            .from('flashcards')
            .select('*')
            .eq('id', cardId)
            .single();
            
          if (error) {
            console.error("Error fetching card:", error);
            return;
          }
          
          // Set current card for editing
          currentCard = data;
          
          // Fill form with current card details
          document.getElementById('edit-word').value = currentCard.word || '';
          document.getElementById('edit-phrase').value = currentCard.phrase || '';
          document.getElementById('edit-translation').value = currentCard.translation_answer || '';
          document.getElementById('edit-ipa').value = currentCard.ipa || '';
          
          // Show the modal
          editModal.classList.remove('hidden');
          
          // We'll reuse the existing edit form submission handler that already updates the card
          
        } catch (err) {
          console.error("Error opening edit modal:", err);
        }
      }

      // Function to open delete modal for a specific card
      async function openDeleteCardModal(cardId) {
        try {
          // Fetch the card details
          const { data, error } = await supabase
            .from('flashcards')
            .select('*')
            .eq('id', cardId)
            .single();
            
          if (error) {
            console.error("Error fetching card:", error);
            return;
          }
          
          // Set current card for deletion
          currentCard = data;
          
          // Show the modal
          deleteModal.classList.remove('hidden');
          
          // Update the existing confirmDeleteBtn handler to refresh the browse view after deletion
          const originalHandler = confirmDeleteBtn.onclick;
          confirmDeleteBtn.onclick = async () => {
            await originalHandler();
            
            // After successful deletion, reload the current page of cards
            if (document.getElementById('browse-cards-section').classList.contains('hidden')) {
              // If browse section is hidden, we don't need to reload
              return;
            }
            
            // Reload cards after a short delay
            setTimeout(async () => {
              await loadCardsPage();
            }, 500);
          };
          
        } catch (err) {
          console.error("Error opening delete modal:", err);
        }
      }

      // Update the edit form submit handler to refresh the browse view after saving
      const originalSubmitHandler = editForm.onsubmit;
      editForm.onsubmit = async (e) => {
        e.preventDefault();
        
        // Call original handler (or re-implement if needed)
        if (originalSubmitHandler) {
          await originalHandler(e);
        } else {
          // If there's no handler, implement the edit functionality here
          // (same code as the existing edit form handler)
          // ...
        }
        
        // After successful edit, reload the current page of cards if the browse section is visible
        if (!document.getElementById('browse-cards-section').classList.contains('hidden')) {
          setTimeout(async () => {
            await loadCardsPage();
          }, 500);
        }
      };

      function updateProgressBar() {
        if (initialReviewCount === 0) return;
        
        const progressPercentage = Math.round((cardsCompleted / initialReviewCount) * 100);
        
        // Update progress bar width
        document.getElementById('progress-bar').style.width = `${progressPercentage}%`;
      }

      // Add these variables to your global variables section
      let selectedWords = [];
      let exerciseData = null;
      let selectedTags = ['easy-to-read']; // Default to easy-to-read

      // Add this event listener after the DOM content loaded event
      document.addEventListener('DOMContentLoaded', function() {
        // Add tag button event listeners
        document.querySelectorAll('.tag-button').forEach(button => {
          button.addEventListener('click', function() {
            const tag = this.getAttribute('data-tag');
            if (this.classList.contains('active')) {
              // Don't allow deselecting if it's the only active tag
              const activeTags = document.querySelectorAll('.tag-button.active').length;
              if (activeTags > 1) {
                this.classList.remove('active');
                selectedTags = selectedTags.filter(t => t !== tag);
              }
            } else {
              this.classList.add('active');
              selectedTags.push(tag);
            }
          });
        });
      });

      // Updated event listener for the start exercise button
      document.getElementById('start-exercise-btn').addEventListener('click', () => {
        // Get the current values from the model selection and card count
        const exerciseModelSelect = document.getElementById('modal-exercise-model-select');
        const exerciseCardsCount = document.getElementById('modal-exercise-cards-count');
        
        // Update the modal with due card count information
        updateExerciseCardCount();
        
        // Show the modal
        document.getElementById('exercise-config-modal').classList.remove('hidden');
      });

      // Event listener for cancel button
      document.getElementById('cancel-exercise-btn').addEventListener('click', () => {
        document.getElementById('exercise-config-modal').classList.add('hidden');
      });

      // Event listener for confirm/start exercise button
      document.getElementById('confirm-exercise-btn').addEventListener('click', async () => {
        try {
          const exerciseBtn = document.getElementById('confirm-exercise-btn');
          const originalText = exerciseBtn.textContent;
          exerciseBtn.textContent = "Preparing...";
          exerciseBtn.disabled = true;
          
          // Load flashcards to filter for due ones
          await loadFlashcards();
          const now = new Date();
          const dueCards = flashcards.filter(card => new Date(card.due) <= now);
          const requestedCardCount = parseInt(document.getElementById('modal-exercise-cards-count').value) || 10;
          
          if (dueCards.length < 1) {
            alert(`You need at least 1 card due for review to create an exercise. You currently have ${dueCards.length} cards due.`);
            exerciseBtn.textContent = originalText;
            exerciseBtn.disabled = false;
            return;
          }
          
          // Hide the modal
          document.getElementById('exercise-config-modal').classList.add('hidden');
          
          // Shuffle cards and select the requested number
          const shuffledDueCards = [...dueCards];
          for (let i = shuffledDueCards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledDueCards[i], shuffledDueCards[j]] = [shuffledDueCards[j], shuffledDueCards[i]];
          }
          // Removed use of Math.min(...); now simply use the number provided by the user.
          const selectedCards = shuffledDueCards.slice(0, requestedCardCount);
          const wordList = selectedCards.map(card => card.word);
          
          // Create the LLM prompt
          const prompt = `Create a fill-in-the-blank exercise using these exact words: ${wordList.join(', ')}. 
          Write an interesting short paragraph.
          
          IMPORTANT INSTRUCTIONS:
          1. Use each word EXACTLY as provided - do not change the form, tense, plurality, etc.
          2. Mark EACH blank space as "[BLANK]" (not with brackets around the word or any other format)
          3. Make sure the number of [BLANK] tokens matches exactly the number of words provided
          4. Do not number the blanks - use the exact same token "[BLANK]" for each one
          
          Style: ${selectedTags.join(', ')}
          
          Format your response as a JSON object with these fields:
          1. "text": The complete text with blanks marked as "[BLANK]" (not with different formatting)
          2. "answers": An array containing each missing word in the EXACT order they appear in the text
          
          For example:
          {
            "text": "Yesterday, I [BLANK] to the store to [BLANK] some groceries. I was [BLANK] by how crowded it was.",
            "answers": ["went", "buy", "surprised"]
          }
          
          DO NOT use formats like "[WORD]" or "[OTHER_FORMAT]" - only use "[BLANK]".`;
          
          // Get Gemini API credentials from user settings
          const { data: { session } } = await supabase.auth.getSession();
          if (!session) {
            alert("Your session has expired. Please sign in again.");
            window.location.href = "index.html";
            return;
          }
          const { data: userSettings, error: settingsError } = await supabase
            .from('user_settings')
            .select('api_key, model')
            .eq('user_id', session.user.id)
            .single();
          
          if (settingsError || !userSettings) {
            alert("Please configure your Gemini API key in Settings first.");
            return;
          }
          
          const apiKey = userSettings.api_key;
          const selectedModel = document.getElementById('modal-exercise-model-select').value || userSettings.model;
          const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`;
          
          // Update UI to show generating message on main button
          document.getElementById('start-exercise-btn').textContent = "Generating exercise...";
          document.getElementById('start-exercise-btn').disabled = true;
          
          // Call the Gemini API and wait for the response
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{
                parts: [{ text: prompt }]
              }]
            })
          });
          
          const responseData = await response.json();
          const llmResponse = responseData?.candidates?.[0]?.content?.parts?.[0]?.text;
          console.log(llmResponse);
          
          if (!llmResponse) {
            throw new Error("Invalid response from LLM API");
          }
          
          // Extract the JSON portion from the response
          let jsonMatch = llmResponse.match(/```json\n([\s\S]*?)\n```/) ||
                          llmResponse.match(/```\n([\s\S]*?)\n```/) ||
                          llmResponse.match(/{[\s\S]*?}/);
          let jsonStr;
          if (jsonMatch) {
            jsonStr = jsonMatch[0].replace(/```json\n|```\n|```/g, '');
          } else {
            jsonStr = llmResponse;
          }
          exerciseData = JSON.parse(jsonStr);
          
          // Hide main sections after receiving the model response
          document.getElementById('app-title').classList.add('hidden');
          document.getElementById('upload-section').classList.add('hidden');
          document.getElementById('stats-section').classList.add('hidden');
          document.getElementById('review-section').classList.add('hidden');
          document.getElementById('exercise-section').classList.add('hidden');
          
          // Display the fill-in-the-blank exercise
          displayExercise(exerciseData);
          document.getElementById('exercise-container').classList.remove('hidden');
          
          // Reset the start exercise button state
          document.getElementById('start-exercise-btn').textContent = "Fill-in-the-Blank with these words";
          document.getElementById('start-exercise-btn').disabled = false;
          
        } catch (err) {
          console.error("Error generating exercise:", err);
          alert("Error generating exercise. Please try again after a minute or change model to Gemini Flash.");
          
          // Hide the modal if still open
          document.getElementById('exercise-config-modal').classList.add('hidden');
          
          // Reset button state
          document.getElementById('start-exercise-btn').textContent = "Fill-in-the-Blank Exercise";
          document.getElementById('start-exercise-btn').disabled = false;
        }
      });

      // Function to update the cards count input based on available due cards
      // Logic removed – the default value set in the HTML (value="5") is now used.
      function updateExerciseCardCount() {
        // Removed dynamic default value logic.
      }

      // Display the exercise (updated to use answers array instead of words field)
      function displayExercise(data) {
        // Display the shuffled words
        const wordListContainer = document.getElementById('word-list');
        wordListContainer.innerHTML = '';
        
        // Make a copy and shuffle the answers array for display
        const shuffledWords = [...data.answers];
        for (let i = shuffledWords.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffledWords[i], shuffledWords[j]] = [shuffledWords[j], shuffledWords[i]];
        }
        
        // Display the shuffled words - updated to make words draggable
        shuffledWords.forEach(word => {
          const wordSpan = document.createElement('span');
          wordSpan.className = 'px-2 py-1 bg-blue-100 dark:bg-blue-900 rounded cursor-pointer select-none word-item';
          wordSpan.textContent = word;
          wordSpan.draggable = true; // Make the word draggable
          
          // Update: Removed text-to-speech from the dragstart event
          wordSpan.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', word);
            wordSpan.classList.add('opacity-50');
            // Speak the word when it's dragged
            const utterance = new SpeechSynthesisUtterance(word);
            window.speechSynthesis.speak(utterance);
          });
          
          wordSpan.addEventListener('dragend', () => {
            wordSpan.classList.remove('opacity-50');
          });
          
          // Modify click-to-fill functionality:
          // Now clicking on the word both fills the blank and speaks the word out loud.
          wordSpan.addEventListener('click', () => {
            // Find the first empty input field
            const emptyInputs = Array.from(document.querySelectorAll('.blank-input')).filter(input => !input.value.trim());
    
            if (emptyInputs.length > 0) {
              emptyInputs[0].value = word;
    
              // Optional: Visually mark the word as used
              if (!wordSpan.classList.contains('used')) {
                wordSpan.classList.add('used');
              }
            }
            
            // Speak the word when it is clicked (selected)
            const utterance = new SpeechSynthesisUtterance(word);
            window.speechSynthesis.speak(utterance);
          });
          
          wordListContainer.appendChild(wordSpan);
        });
        
        // Create the exercise text with input fields
        const exerciseTextContainer = document.getElementById('exercise-text');
        
        // Split by [BLANK] tokens and create input fields between segments
        const segments = data.text.split('[BLANK]');
        let htmlText = '';
        
        segments.forEach((segment, i) => {
          htmlText += segment;
          if (i < segments.length - 1) { // Don't add input after the last segment
            htmlText += `<input type="text" class="blank-input w-24 px-2 py-1 border rounded mx-1 dark:bg-gray-700" data-index="${i}">`;
          }
        });
        
        exerciseTextContainer.innerHTML = htmlText;
        
        // Add drop events to all input fields
        document.querySelectorAll('.blank-input').forEach(input => {
          // Prevent default to allow drop
          input.addEventListener('dragover', (e) => {
            e.preventDefault();
            input.classList.add('border-blue-500', 'bg-blue-50', 'dark:bg-blue-900');
          });
          
          input.addEventListener('dragleave', () => {
            input.classList.remove('border-blue-500', 'bg-blue-50', 'dark:bg-blue-900');
          });
          
          input.addEventListener('drop', (e) => {
            e.preventDefault();
            input.classList.remove('border-blue-500', 'bg-blue-50', 'dark:bg-blue-900');
            const word = e.dataTransfer.getData('text/plain');
            input.value = word;
          });
        });
      }
      
      // Check answers (updated with Mark as Learned option)
      document.getElementById('check-answers-btn').addEventListener('click', () => {
        if (!exerciseData) return;
        
        const inputs = document.querySelectorAll('.blank-input');
        let allCorrect = true;
        
        inputs.forEach((input, index) => {
          const userAnswer = input.value.trim();
          const correctAnswer = exerciseData.answers[index];
          
          // First, remove all state classes to start fresh
          input.classList.remove(
            'border-green-500', 'bg-green-50', 'border-red-500', 'bg-red-50',
            'dark:bg-green-900', 'dark:bg-red-900', 'border-gray-300'
          );
          
          // Check if the answer is empty or incorrect
          if (userAnswer === '') {
            // Empty answer - mark as red with stronger styling
            input.classList.add('border-2', 'border-red-500');
            input.style.backgroundColor = 'rgba(254, 202, 202, 0.3)'; // Light red bg
            input.placeholder = "Empty";
            allCorrect = false;
          } else if (userAnswer === correctAnswer) {
            // Correct answer - mark as green with stronger styling
            input.classList.add('border-2', 'border-green-500');
            input.style.backgroundColor = 'rgba(187, 247, 208, 0.3)'; // Light green bg
            input.placeholder = "";
          } else {
            // Wrong answer - mark as red with stronger styling
            input.classList.add('border-2', 'border-red-500');
            input.style.backgroundColor = 'rgba(254, 202, 202, 0.3)'; // Light red bg
            input.placeholder = "";
            allCorrect = false;
          }
        });
        
        // Only show feedback if all answers are correct
        let feedbackEl = document.getElementById('exercise-feedback');
        
        if (allCorrect) {
          // Create the feedback element if it doesn't exist
          if (!feedbackEl) {
            feedbackEl = document.createElement('div');
            feedbackEl.id = 'exercise-feedback';
            document.getElementById('exercise-text').after(feedbackEl);
          }
          
          // Find the word meanings from flashcards array
          const wordMeanings = exerciseData.answers.map(word => {
            const card = flashcards.find(c => c.word.toLowerCase() === word.toLowerCase());
            if (card) {
              // Extract the first line of translation_answer as the meaning
              const meaning = card.translation_answer.split('\n')[0];
              return { word: word, meaning: meaning, ipa: card.ipa };
            }
            return { word: word, meaning: "No definition available", ipa: null };
          });
          
          // Create the word meanings HTML
          let wordMeaningsHTML = '<div class="mt-4 p-3 border rounded bg-blue-50 dark:bg-blue-900 dark:border-blue-800">';
          wordMeaningsHTML += '<h3 class="font-semibold mb-2">Word Meanings:</h3>';
          wordMeaningsHTML += '<ul class="space-y-2">';
          
          wordMeanings.forEach(item => {
            // Format each word with its meaning
            wordMeaningsHTML += `
              <li class="pb-2 border-b border-blue-200 dark:border-blue-800 last:border-0">
                <div class="font-medium">${item.word} ${item.ipa ? `<span class="text-sm text-gray-500">[${item.ipa}]</span>` : ''}</div>
                <div class="text-sm text-gray-700 dark:text-gray-300">${item.meaning}</div>
              </li>
            `;
          });
          
          wordMeaningsHTML += '</ul></div>';
          
          // Add success message with Mark as Learned button and word meanings
          feedbackEl.className = 'mt-4 p-3 rounded text-center bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-100 transition-all';
          feedbackEl.innerHTML = `
            <p class="mb-3">Great job! All answers are correct!</p>
            <button id="mark-learned-btn" class="bg-purple-500 text-white py-1 px-3 rounded hover:bg-purple-600 transition-all mb-4">
              Mark as Learned
            </button>
            ${wordMeaningsHTML}
          `;
          
          // Make the feedback message visible with a subtle animation
          feedbackEl.style.opacity = '0';
          setTimeout(() => {
            feedbackEl.style.opacity = '1';
          }, 10);
          
          // Add event listener to the Mark as Learned button
          document.getElementById('mark-learned-btn').addEventListener('click', async () => {
            try {
              // Get all words used in the exercise
              const exerciseWords = exerciseData.answers;
              
              // Find the card objects for each word
              const cardsToUpdate = [];
              
              for (const word of exerciseWords) {
                const card = flashcards.find(c => c.word.toLowerCase() === word.toLowerCase());
                if (card) {
                  cardsToUpdate.push(card);
                }
              }
              
              if (cardsToUpdate.length === 0) {
                alert("No matching flashcards found to update.");
                return;
              }
              
              // Update each card with FSRS
              const now = new Date();
              const updates = [];
              
              for (const card of cardsToUpdate) {
                const fsrsCard = {
                  state: card.state || "new",
                  due: card.due,
                  stability: card.stability || s0(Grade.Good),
                  difficulty: card.difficulty || d0(Grade.Good),
                  elapsed_days: card.elapsed_days || 0,
                  scheduled_days: card.scheduled_days || 0,
                  reps: card.reps || 0,
                  lapses: card.lapses || 0,
                };
                
                // Update using FSRS implementation with Grade.Good
                const result = fsrs.repeat(fsrsCard, Grade.Good, now);
                
                // Update local copy
                Object.assign(card, result);
                card.last_reviewed = now.toISOString();
                
                // Prepare database update
                updates.push({
                  id: card.id,
                  state: result.state,
                  due: result.due,
                  stability: result.stability,
                  difficulty: result.difficulty,
                  elapsed_days: result.elapsed_days,
                  scheduled_days: result.scheduled_days,
                  reps: result.reps,
                  lapses: result.lapses,
                  last_reviewed: now.toISOString()
                });
              }
              
              // Update the button to show progress
              const markLearnedBtn = document.getElementById('mark-learned-btn');
              markLearnedBtn.textContent = "Updating...";
              markLearnedBtn.disabled = true;
              
              // Update database records (one by one to avoid batch limitations)
              for (const update of updates) {
                const { error } = await supabase
                  .from('flashcards')
                  .update({
                    state: update.state,
                    due: update.due,
                    stability: update.stability,
                    difficulty: update.difficulty,
                    elapsed_days: update.elapsed_days,
                    scheduled_days: update.scheduled_days,
                    reps: update.reps,
                    lapses: update.lapses,
                    last_reviewed: update.last_reviewed
                  })
                  .eq('id', update.id);
                  
                if (error) {
                  console.error("Error updating flashcard:", error);
                }
              }
              
              // Update the UI
              markLearnedBtn.textContent = "✓ Marked as Learned";
              markLearnedBtn.className = "bg-green-600 text-white py-1 px-3 rounded cursor-default";
              
              // Update stats
              updateStats();
              
              // Automatically exit the exercise after a short delay (1.5 seconds)
              setTimeout(() => {
                // Hide exercise container
                document.getElementById('exercise-container').classList.add('hidden');
                
                // Show main sections again
                document.getElementById('app-title').classList.remove('hidden');
                document.getElementById('upload-section').classList.remove('hidden');
                document.getElementById('stats-section').classList.remove('hidden');
                document.getElementById('review-section').classList.remove('hidden');
                document.getElementById('exercise-section').classList.remove('hidden');
                
                // Reset exercise data
                exerciseData = null;
              }, 1500);
              
            } catch (err) {
              console.error("Error marking cards as learned:", err);
              alert("An error occurred while updating cards. Please try again.");
            }
          });
        } else {
          // Remove the feedback element if it exists
          if (feedbackEl) {
            feedbackEl.remove();
          }
        }
      });
      
      // Show answers (updated for the new format)
      document.getElementById('show-answers-btn').addEventListener('click', () => {
        if (!exerciseData) return;
        
        const inputs = document.querySelectorAll('.blank-input');
        
        inputs.forEach((input, index) => {
          const correctAnswer = exerciseData.answers[index];
          input.value = correctAnswer;
          
          // Apply the same styling as in the check answers function
          input.classList.remove(
            'border-green-500', 'bg-green-50', 'border-red-500', 'bg-red-50',
            'dark:bg-green-900', 'dark:bg-red-900', 'border-gray-300'
          );
          input.classList.add('border-2', 'border-green-500');
          input.style.backgroundColor = 'rgba(187, 247, 208, 0.3)';
        });
        
        // Show a feedback message that answers are revealed
        let feedbackEl = document.getElementById('exercise-feedback');
        if (!feedbackEl) {
          feedbackEl = document.createElement('div');
          feedbackEl.id = 'exercise-feedback';
          document.getElementById('exercise-text').after(feedbackEl);
        }
        
        feedbackEl.className = 'mt-4 p-3 rounded text-center bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-100 transition-all duration-300';
        feedbackEl.textContent = "Here are the correct answers.";
        
        // Make the feedback message visible with a subtle animation
        feedbackEl.style.opacity = '0';
        setTimeout(() => {
          feedbackEl.style.opacity = '1';
        }, 10);
      });
      
      // Add event listener for exiting exercise
      document.getElementById('exit-exercise-btn').addEventListener('click', () => {
        // Hide the exercise container.
        document.getElementById('exercise-container').classList.add('hidden');
        
        // Show the main sections again.
        document.getElementById('app-title').classList.remove('hidden');
        document.getElementById('upload-section').classList.remove('hidden');
        document.getElementById('stats-section').classList.remove('hidden');
        document.getElementById('review-section').classList.remove('hidden');
        document.getElementById('exercise-section').classList.remove('hidden');
        
        // Reset the exercise data.
        exerciseData = null;
        
        // --- New: Reset the start exercise button state ---
        const exerciseBtn = document.getElementById('start-exercise-btn');
        exerciseBtn.textContent = "Fill-in-the-Blank Exercise";
        exerciseBtn.disabled = false;
      });

      // Add Reset button to exercise UI
      document.querySelector('.flex.justify-between.items-center').innerHTML += `
        <button id="reset-exercise-btn" class="bg-gray-300 text-gray-800 py-2 px-4 rounded hover:bg-gray-400">
          Reset
        </button>
      `;
      
      // Add event listener for reset button
      document.getElementById('reset-exercise-btn').addEventListener('click', () => {
        // Clear all input fields
        document.querySelectorAll('.blank-input').forEach(input => {
          input.value = '';
          input.classList.remove(
            'border-green-500', 'bg-green-50', 'border-red-500', 'bg-red-50',
            'dark:bg-green-900', 'dark:bg-red-900', 'border-2'
          );
          input.style.backgroundColor = '';
        });
        
        // Reset all word items (remove 'used' class)
        document.querySelectorAll('.word-item').forEach(word => {
          word.classList.remove('used');
        });
        
        // Remove any feedback message
        const feedbackEl = document.getElementById('exercise-feedback');
        if (feedbackEl) {
          feedbackEl.remove();
        }
      });

      // DOM Elements
      const countInput = document.getElementById('modal-exercise-cards-count');
      // Mark the exercise count input as user-modified once changed
      countInput.addEventListener('input', function () {
        this.setAttribute('data-user-changed', 'true');
      });

      // Add event listener for the help button
      document.getElementById('help-btn').addEventListener('click', () => {
        if (!exerciseData) return;
        
        // Find the word meanings from flashcards array
        const wordMeanings = exerciseData.answers.map(word => {
          const card = flashcards.find(c => c.word.toLowerCase() === word.toLowerCase());
          if (card) {
            // Extract the first line of translation_answer as the meaning
            const meaning = card.translation_answer.split('\n')[0];
            return { word: word, meaning: meaning, ipa: card.ipa };
          }
          return { word: word, meaning: "No definition available", ipa: null };
        });
        
        // Create a more compact word meanings HTML
        let wordMeaningsHTML = '<div class="mt-4 p-3 border rounded bg-blue-50 dark:bg-blue-900 dark:border-blue-800">';
        wordMeaningsHTML += '<h3 class="font-semibold mb-2">Word Meanings:</h3>';
        wordMeaningsHTML += '<ul class="space-y-1">';
        
        wordMeanings.forEach(item => {
          // Format each word with its meaning on a single line
          wordMeaningsHTML += `
            <li class="py-1 border-b border-blue-200 dark:border-blue-800 last:border-0">
              <span class="font-medium">${item.word}</span>
              ${item.ipa ? `<span class="text-xs text-gray-500 ml-1">[${item.ipa}]</span>` : ''}
              <span class="mx-1">:</span>
              <span class="text-gray-700 dark:text-gray-300">${item.meaning}</span>
            </li>
          `;
        });
        
        wordMeaningsHTML += '</ul></div>';
        
        // Get or create the help panel element
        let helpPanelEl = document.getElementById('exercise-help');
        if (!helpPanelEl) {
          helpPanelEl = document.createElement('div');
          helpPanelEl.id = 'exercise-help';
          document.getElementById('exercise-text').after(helpPanelEl);
        }
        
        // Toggle visibility of help panel
        if (helpPanelEl.innerHTML === '') {
          // Show the help panel
          helpPanelEl.className = 'mt-4 p-3 rounded bg-yellow-50 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-100 transition-all';
          helpPanelEl.innerHTML = wordMeaningsHTML;
          // Make the help panel visible with a subtle animation
          helpPanelEl.style.opacity = '0';
          setTimeout(() => {
            helpPanelEl.style.opacity = '1';
          }, 10);
        } else {
          // Hide the help panel
          helpPanelEl.innerHTML = '';
          helpPanelEl.className = '';
        }
      });

      // Update reset button handler to also clear the help panel
      document.getElementById('reset-exercise-btn').addEventListener('click', () => {
        // ... existing reset code ...
        
        // Also clear any help panel
        const helpPanelEl = document.getElementById('exercise-help');
        if (helpPanelEl) {
          helpPanelEl.innerHTML = '';
          helpPanelEl.className = '';
        }
      });

      // Update exit exercise handler to also clear the help panel
      document.getElementById('exit-exercise-btn').addEventListener('click', () => {
        // ... existing exit code ...
        
        // Also clear any help panel
        const helpPanelEl = document.getElementById('exercise-help');
        if (helpPanelEl) {
          helpPanelEl.innerHTML = '';
          helpPanelEl.className = '';
        }
      });
    </script>
  </body>
</html> 
</rewritten_file>