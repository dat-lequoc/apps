<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Ebook Reader</title>
    <!-- Include external libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* CSS Reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        /* CSS Variables for theming */
        :root {
            /* Light theme variables */
            --light-bg: #f8f8f8;
            --light-text: #333;
            --light-panel-bg: #fff;
            --light-border: #eee;
            --light-panel-shadow: rgba(0,0,0,0.1);
            --light-highlight: rgba(66, 133, 244, 0.3);
            
            /* Sepia theme variables */
            --sepia-bg: #f8f1e3;
            --sepia-text: #5f4b32;
            --sepia-panel-bg: #f7f0e0;
            --sepia-border: rgba(95, 75, 50, 0.15);
            --sepia-panel-shadow: rgba(95, 75, 50, 0.15);
            --sepia-highlight: rgba(210, 180, 140, 0.3);
            
            /* Dark theme variables */
            --dark-bg: #222;
            --dark-text: #e0e0e0;
            --dark-panel-bg: #333;
            --dark-border: #444;
            --dark-panel-shadow: rgba(0,0,0,0.3);
            --dark-highlight: rgba(66, 133, 244, 0.4);
            
            /* Common UI colors */
            --primary-color: #4285f4;
            --success-color: #34a853;
            --danger-color: #d93025;
            --panel-radius: 12px;
            
            /* Default to dark theme */
            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
        }
        
        /* Theme classes */
        body.light-theme {
            --bg-color: var(--light-bg);
            --text-color: var(--light-text);
            --panel-bg: var(--light-panel-bg);
            --border-color: var(--light-border);
            --panel-shadow: var(--light-panel-shadow);
            --highlight-color: var(--light-highlight);
        }
        
        body.sepia-theme {
            --bg-color: var(--sepia-bg);
            --text-color: var(--sepia-text);
            --panel-bg: var(--sepia-panel-bg);
            --border-color: var(--sepia-border);
            --panel-shadow: var(--sepia-panel-shadow);
            --highlight-color: var(--sepia-highlight);
        }
        
        body.dark-theme {
            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
            --input-bg: rgba(255, 255, 255, 0.05); /* Added for input backgrounds */
            --text-muted: rgba(224, 224, 224, 0.7);
        }

        .hidden {
            display: none !important; /* Use important to override potential inline styles if needed */
        }

        #ai-response-area {
            display: none; /* Initially hidden, controlled by JS */
        }

        /* Base styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        /* Selection styling */
        ::selection {
            background-color: var(--highlight-color);
        }
        
        /* Responsive typography */
        html {
            font-size: 16px;
        }
        
        @media (max-width: 768px) {
            html {
                font-size: 14px;
            }
        }
        
        /* Main container */
        #app {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
        }
        
        /* Welcome screen */
        #welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Allow scrolling from top */
            background-color: var(--bg-color);
            z-index: 100;
            padding: 5vh 1rem; /* Add vertical padding */
            overflow-y: auto;
        }

        #welcome-screen h1 {
            margin-bottom: 1.5rem; /* Increased margin */
            text-align: center;
            font-size: 2.2rem; /* Slightly larger */
        }

        .welcome-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            padding: 1rem; /* Adjusted padding */
        }

        .welcome-actions { /* Renamed for clarity */
            display: flex;
            flex-direction: column; /* Stack actions vertically */
            gap: 1.5rem; /* Increased gap */
            margin-top: 1.5rem;
            width: 100%;
            align-items: center;
        }

        .main-actions { /* Group main buttons */
             display: flex;
             gap: 1rem;
             justify-content: center;
             flex-wrap: wrap; /* Allow wrapping on small screens */
             width: 100%;
        }

        #library-section {
            width: 100%;
            max-width: 600px;
            margin-top: 2.5rem;
            background-color: var(--panel-bg);
            border-radius: 8px;
            height: 100vh; /* Use fixed height */
            box-shadow: 0 2px 8px var(--panel-shadow);
            display: flex; /* Use flexbox */
            flex-direction: column; /* Stack header and list vertically */
            overflow: hidden; /* Ensure content respects max-height */
        }

        #list-management {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            gap: 1rem;
            flex-wrap: wrap; /* Allow wrapping */
        }

        #list-filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #list-filter {
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.9rem;
        }

        #create-list-group {
            display: flex;
            gap: 0.5rem;
            align-items: center; /* Align items vertically */
        }

        #new-list-name {
            display: none; /* Hide initially */
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.9rem;
            flex: 1; /* Take available space */
            margin-right: 0.5rem; /* Add some space before the button */
        }

        #create-list-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            min-width: 40px; /* Ensure minimum width */
            text-align: center;
        }

        /* New List Controls Wrapper */
        #list-controls-wrapper {
            display: flex;
            align-items: center; /* Vertically align badges and create group */
            gap: 1rem; /* Space between badge container and create group */
            margin-bottom: 1rem; /* Space below the whole control row */
            padding-bottom: 0.5rem; /* Padding below the controls */
            border-bottom: 1px solid var(--border-color); /* Separator */
            flex-wrap: wrap; /* Allow wrapping if needed on very small screens */
            flex-shrink: 0; /* Prevent header from shrinking */
            padding: 1.25rem 1.25rem 0.5rem; /* Add padding back to header */
        }

        /* List Badge Styling */
        #list-badge-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            flex-grow: 1; /* Allow badges to take available space */
            /* Removed margin-bottom, padding, border-bottom - handled by wrapper */
        }

        .list-badge {
            padding: 0.3rem 0.8rem;
            border-radius: 12px; /* Pill shape */
            font-size: 0.85rem;
            cursor: pointer;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg); /* Default background */
            color: var(--text-color); /* Use main text color for better default contrast */
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            white-space: nowrap;
        }

        .list-badge:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .list-badge.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            font-weight: 500;
        }

        /* Badge Colors (Example cycle) - Using darker text colors for better contrast */
        .list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.2); border-color: rgba(52, 168, 83, 0.4); color: #137333; } /* Darker Green */
        .list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.2); border-color: rgba(251, 188, 5, 0.4); color: #b06000; } /* Darker Yellow/Orange */
        .list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.2); border-color: rgba(234, 67, 53, 0.4); color: #a50e0e; } /* Darker Red */
        .list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.2); border-color: rgba(66, 133, 244, 0.4); color: #1a73e8; } /* Darker Blue */
        .list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.2); border-color: rgba(156, 39, 176, 0.4); color: #6a1b9a; } /* Darker Purple */

        /* Ensure sufficient contrast in light theme */
        body.light-theme .list-badge[data-color-index="0"] { color: #0d652d; }
        body.light-theme .list-badge[data-color-index="1"] { color: #995200; }
        body.light-theme .list-badge[data-color-index="2"] { color: #940a0a; }
        body.light-theme .list-badge[data-color-index="3"] { color: #0b57d0; }
        body.light-theme .list-badge[data-color-index="4"] { color: #58117a; }

        .list-badge.active[data-color-index="0"],
        .list-badge.active[data-color-index="1"],
        .list-badge.active[data-color-index="2"],
        .list-badge.active[data-color-index="3"],
        .list-badge.active[data-color-index="4"] {
             background-color: var(--primary-color); /* Keep active color consistent */
             border-color: var(--primary-color);
             color: white;
        }


        /* Adjust Create List Group for Flex Layout */
        #create-list-group {
            /* display: flex; */ /* Already flex */
            /* gap: 0.5rem; */ /* Already has gap */
            /* align-items: center; */ /* Already aligned */
            flex-shrink: 0; /* Prevent create group from shrinking */
        }

        #new-list-name {
            /* display: none; */ /* Already hidden */
            /* padding, border-radius, border, background-color, color, font-size */ /* Keep existing styles */
            /* flex: 1; */ /* Remove flex: 1 to prevent taking all space */
            width: 150px; /* Give it a fixed or max-width */
            /* margin-right: 0.5rem; */ /* Keep margin */
        }

        #create-list-btn {
            /* padding, font-size, min-width, text-align */ /* Keep existing styles */
        }

        /* Library List Styling */
        #library-list {
            flex: 1 1 auto; /* Use flex: 1 to take available space */
            overflow-y: scroll; /* Keep scroll */
            -webkit-overflow-scrolling: touch;
            padding: 0 1.25rem 1.25rem;
            min-height: 0; /* Keep this for Firefox compatibility */
            position: relative; /* Create a positioning context */
            max-height: calc(100% - 50px); /* Account for header height */
            /* Custom scrollbar styling */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent; /* Firefox */
        }
        
        /* WebKit/Blink browsers (Chrome, Safari, Edge) scrollbar styling */
        #library-list::-webkit-scrollbar {
            width: 8px; /* Width of the scrollbar */
        }
        
        #library-list::-webkit-scrollbar-track {
            background: transparent; /* Track background */
        }
        
        #library-list::-webkit-scrollbar-thumb {
            background-color: rgba(155, 155, 155, 0.5); /* Scrollbar color */
            border-radius: 4px; /* Rounded corners */
            border: 2px solid transparent; /* Creates padding around scrollbar thumb */
        }
        
        #library-list::-webkit-scrollbar-thumb:hover {
            background-color: rgba(155, 155, 155, 0.8); /* Darker on hover */
        }

        /* Input Group Styling */
        .input-group {
            /* width: 100%; */ /* Remove fixed width for general input groups if needed, or adjust */
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* Space between elements in the group */
        }

        .input-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .input-field { /* Common style for text/url inputs */
            flex: 1;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            font-size: 1rem;
        }

        #text-input { /* Specific textarea style */
            width: 100%;
            min-height: 120px; /* Slightly smaller default height */
            margin-bottom: 0; /* Remove bottom margin, handled by gap */
        }

        #toggle-text-input-container {
            text-align: center;
            margin-top: 0.5rem; /* Keep small margin */
        }

        #toggle-text-input {
            font-size: 0.9rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        #toggle-text-input:hover {
            text-decoration: underline;
        }

        #text-input-container {
            width: 100%;
            /* display: none; /* Controlled by JS */
        }

        .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .library-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .library-item-details {
            flex: 1;
            min-width: 0; /* Allow text truncation */
        }
        
        .library-item-title {
            font-weight: 500;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .library-item-meta {
            font-size: 0.75rem;
            color: rgba(var(--text-color), 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .library-item-move { /* Style for the move button */
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            margin-right: 0.5rem; /* Space before delete */
            transition: background-color 0.2s;
        }
        .library-item-move:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Dropdown for moving books */
        .move-list-dropdown {
            position: absolute;
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 2px 8px var(--panel-shadow);
            z-index: 10; /* Ensure it's above other items */
            min-width: 150px;
            max-height: 200px; /* Limit height and allow scrolling */
            overflow-y: auto;
            display: none; /* Hidden by default */
            margin-top: 2px; /* Small space below the button */
            right: 0; /* Align to the right of the actions container */
        }

        .move-list-dropdown.visible {
            display: block;
        }

        .move-list-option {
            padding: 0.5rem 0.8rem;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-bottom: 1px solid var(--border-color);
        }
        .move-list-option:last-child {
            border-bottom: none;
        }

        .move-list-option:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .move-list-option.disabled {
            color: var(--text-muted);
            cursor: default;
            background-color: transparent;
        }


        .progress-bar-container {
            height: 4px;
            background-color: rgba(var(--text-color), 0.1);
            border-radius: 2px;
            margin-top: 0.3rem;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .library-item-actions {
            display: flex;
            gap: 0.5rem;
            margin-left: 0.5rem;
            flex-shrink: 0; /* Prevent action buttons from shrinking */
        }
        
        .library-item-delete {
            color: var(--danger-color);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.125rem;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
        }
        
        .library-item-delete:hover {
            background-color: rgba(217, 48, 37, 0.1);
        }
        
        .auth-section {
            margin-top: 1.875rem;
            text-align: center;
        }
        
        .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transition: background-color 0.2s, transform 0.1s;
        }
        
        .button:hover {
            background-color: #3367d6;
        }
        
        .button:active {
            transform: translateY(1px);
        }

        /* Button loading state */
        .button.loading {
            position: relative;
            color: transparent !important; /* Hide text */
            pointer-events: none; /* Disable clicks */
        }

        .button.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1rem; /* Spinner size */
            height: 1rem; /* Spinner size */
            margin-top: -0.5rem; /* Center vertically */
            margin-left: -0.5rem; /* Center horizontally */
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: button-spin 0.8s linear infinite;
        }

        @keyframes button-spin {
            to { transform: rotate(360deg); }
        }
        
        .success-button {
            background-color: var(--success-color);
        }
        
        .success-button:hover {
            background-color: #2e9549;
        }
        
        /* Example book section */
        .example-book-section {
            margin-top: 1.875rem;
            text-align: center;
            padding: 1.25rem;
            background-color: rgba(66, 133, 244, 0.1);
            border-radius: 8px;
            margin-bottom: 1.25rem;
        }

        .example-book-section p {
            margin-bottom: 0.75rem; /* Add space below the paragraph */
        }
        
        /* Top navbar */
        #navbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3.5rem;
            background-color: var(--panel-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            z-index: 20;
        }
        
        #navbar.visible {
            transform: translateY(0);
        }
        
        #book-title {
            font-size: 1.125rem;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 40%;
        }
        
        #navbar-buttons {
            display: flex;
            gap: 1rem;
        }
        
        .navbar-btn {
            background-color: transparent;
            border: none;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
            font-size: 1.25rem;
            transition: background-color 0.2s;
        }
        
        .navbar-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Reader content */
        #reader-container {
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        
        #content-area {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
            padding-top: 2rem;
            -webkit-overflow-scrolling: touch;
            user-select: text;
            -webkit-user-select: text;
            transition: background-color 0.3s ease, color 0.3s ease;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        #content-area p {
            margin-bottom: 1rem;
            line-height: 1.7;
        }
        
        /* Settings panel */
        #settings-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--panel-bg);
            padding: 1.25rem;
            border-top-left-radius: var(--panel-radius);
            border-top-right-radius: var(--panel-radius);
            box-shadow: 0 -2px 10px var(--panel-shadow);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 30;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #settings-panel.visible {
            transform: translateY(0);
        }
        
        .settings-section {
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .settings-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
        }
        
        #ai-settings-content {
            margin-bottom: 1rem;
        }

        .settings-row.ai-toggle {
            margin-top: 0.75rem;
        }

        #ai-response-area {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            padding: 0.75rem;
            margin-top: 0.75rem;
            font-size: 0.875rem;
            max-height: 12.5rem;
            overflow-y: auto;
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .font-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
        }
        
        .theme-options {
            display: flex;
            gap: 1rem;
        }
        
        .theme-option {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }
        
        .theme-option.active {
            border-color: var(--primary-color);
        }
        
        .light-option {
            background-color: var(--light-bg);
            border: 1px solid var(--light-border);
        }
        
        .sepia-option {
            background-color: var(--sepia-bg);
        }
        
        .dark-option {
            background-color: var(--dark-bg);
        }
        
        /* Navigation controls */
        #nav-controls {
            position: fixed;
            bottom: 1.25rem;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 1.25rem;
            pointer-events: none;
            z-index: 15;
        }
        
        .nav-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background-color: var(--panel-bg);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transition: background-color 0.2s;
        }
        
        .nav-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Table of contents panel */
        #toc-panel {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 80%;
            max-width: 20rem;
            background-color: var(--panel-bg);
            z-index: 30;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px var(--panel-shadow);
        }
        
        #toc-panel.visible {
            transform: translateX(0);
        }
        
        #toc-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #toc-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .toc-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .toc-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .toc-item.toc-active {
            font-weight: bold;
            background-color: rgba(var(--primary-color), 0.1);
        }
        
        /* Overlay for panels */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.4);
            z-index: 25;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #overlay.visible {
            display: block;
            opacity: 1;
        }
        
        /* Progress indicator */
        #progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background-color: var(--primary-color);
            transition: width 0.2s ease;
            z-index: 10;
        }
        
        /* Loading indicator */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #loading.visible {
            display: flex;
            opacity: 1;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-left-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Translation popup */
        #translation-popup {
            position: fixed;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            padding: 16px;
            min-width: 220px;
            max-width: 320px;
            z-index: 100;
            display: none;
            border: 1px solid rgba(0,0,0,0.08);
            transform: translateY(10px);
            opacity: 0;
            transition: transform 0.2s ease, opacity 0.2s ease;
            font-style: italic;
            color: #4285f4;
        }
        
        #translation-popup.visible {
            transform: translateY(0);
            opacity: 1;
        }
        
        body.light-theme #translation-popup {
            background-color: #ffffff;
            color: #4285f4;
        }
        
        body.sepia-theme #translation-popup {
            background-color: #f7f0e0;
            color: #4285f4;
            border-color: rgba(95, 75, 50, 0.15);
        }
        
        body.dark-theme #translation-popup {
            background-color: #2d2d2d;
            color: #4285f4;
            border-color: rgba(255,255,255,0.1);
        }
        
        #translation-popup:before {
            content: '';
            position: absolute;
            top: -8px;
            left: 20px;
            width: 14px;
            height: 14px;
            background-color: inherit;
            border-top: 1px solid rgba(0,0,0,0.08);
            border-left: 1px solid rgba(0,0,0,0.08);
            transform: rotate(45deg);
        }
        
        body.dark-theme #translation-popup:before {
            border-color: rgba(255,255,255,0.1);
        }
        
        body.sepia-theme #translation-popup:before {
            border-color: rgba(95, 75, 50, 0.15);
        }
        
        #translation-content {
            margin-bottom: 10px;
            font-size: 15px;
            line-height: 1.5;
        }
        
        #translation-loading {
            display: none;
            align-items: center;
            justify-content: center;
            height: 30px;
        }
        
        #translation-loading .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-left-color: #4285f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        body.dark-theme #translation-loading .spinner {
            border-color: rgba(255,255,255,0.1);
            border-left-color: #4285f4;
        }
        
        /* Flashcard toast styles */
        .flashcard-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            padding: 8px 12px;
            width: 240px;
            z-index: 1000;
            font-size: 14px;
            opacity: 1;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        body.dark-theme .flashcard-toast {
            background-color: #333;
            color: #e0e0e0;
        }
        
        .flashcard-toast.visible {
            display: block;
        }
        
        .flashcard-toast.fade-out {
            opacity: 0;
            transform: translateY(10px);
        }
        
        .flashcard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .flashcard-close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #888;
            padding: 0;
            margin: 0;
        }
        
        .flashcard-word {
            font-weight: bold;
            font-size: 16px;
        }
        
        .flashcard-translation {
            margin-bottom: 8px;
            line-height: 1.3;
            font-size: 13px;
        }
        
        .flashcard-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .flashcard-speak-btn {
            background-color: #34a853;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 0 0 auto;
        }
        
        .flashcard-save-btn {
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 1;
        }
        
        .flashcard-save-btn:disabled {
            background-color: #a4c2f4;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #toc-panel {
                width: 100%;
                max-width: none;
            }
            
            .welcome-buttons {
                flex-direction: column;
                width: 100%;
            }
            
            .welcome-buttons .button {
                width: 100%;
                text-align: center;
            }
            
            #book-title {
                max-width: 60%;
            }
            
            #navbar-buttons {
                gap: 0.5rem;
            }
            
            .flashcard-toast {
                left: 1.25rem;
                right: 1.25rem;
                width: auto;
            }
        }
        
        /* Accessibility improvements */
        button, input[type="checkbox"] {
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
        }
        
        a {
            color: var(--primary-color);
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }

        /* Style links within the reader content area */
        #content-area a {
            text-decoration: underline;
            font-style: italic;
            /* Inherit color from parent, or set specific color */
            color: var(--primary-color); /* Or inherit */
        }

        #content-area a:hover {
            /* Optional: slightly different hover effect if needed */
            color: #3367d6; /* Example: darker blue on hover */
        }
        
        /* Toast notification */
        #toast {
            position: fixed;
            bottom: 1.25rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: var(--panel-bg);
            color: var(--text-color);
            padding: 0.75rem 1.25rem;
            border-radius: 4px;
            box-shadow: 0 4px 12px var(--panel-shadow);
            z-index: 1000;
            transition: transform 0.3s ease;
            text-align: center;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
        }

        /* Link Action Confirmation Toast */
        .link-action-toast {
            position: fixed;
            bottom: 1.25rem; /* Same as regular toast */
            left: 50%;
            transform: translateX(-50%) translateY(150px); /* Start off-screen */
            background-color: var(--panel-bg);
            color: var(--text-color);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--panel-shadow);
            z-index: 1001; /* Above regular toast */
            transition: transform 0.3s ease;
            width: 90%;
            max-width: 400px;
            text-align: left;
        }

        .link-action-toast.visible {
            transform: translateX(-50%) translateY(0);
        }

        .link-action-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .link-action-close-btn {
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            line-height: 1;
        }

        .link-action-url {
            font-size: 0.9rem;
            margin-bottom: 1rem;
            word-break: break-all; /* Wrap long URLs */
            color: var(--text-muted);
            max-height: 3.6em; /* Limit height to roughly 3 lines */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .link-action-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end; /* Align buttons to the right */
        }

        .link-action-btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: transparent;
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .link-action-btn.scrape {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .link-action-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .link-action-btn.scrape:hover {
            background-color: #3367d6; /* Darker blue on hover */
        }

        /* Line height control */
        .line-height-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
    
        /* Source URL display in content area */
        #source-url-display {
            display: none; /* Hidden by default */
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-muted); /* Use muted color for the "Source:" label */
        }
    
        #source-url-content-link {
            word-break: break-all;
            color: var(--primary-color); /* Link color */
            text-decoration: none;
        }
        #source-url-content-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body class="dark-theme">
    <div id="app">
        <!-- Welcome screen -->
        <div id="welcome-screen">
            <div class="welcome-content">
                <h1>Enhanced Ebook Reader</h1>
                <p>Open a local file, read from a URL, or paste text.</p>

                <div class="welcome-actions">
                    <!-- Main Actions: Open File / Sign In -->
                    <div class="main-actions">
                        <button type="button" id="open-file-btn" class="button">Open File</button>
                        <button type="button" id="login-btn" class="button hidden">Sign In</button> <!-- JS controlled -->
                    </div>

                    <!-- URL Input Group -->
                    <div class="input-group" id="url-input-container">
                        <div class="input-row">
                            <input id="url-input" type="url" placeholder="Or enter a URL to read" class="input-field">
                            <button type="button" id="process-url-btn" class="button">Read URL</button>
                        </div>
                    </div>
                    <div class="settings-row" style="justify-content: flex-start; gap: 0.5rem; margin-top: 0.5rem;">
                        <input type="checkbox" id="clean-url-content-toggle" checked>
                        <label for="clean-url-content-toggle" style="font-size: 0.9rem; color: var(--text-muted);">Clean & Extract Main Article (AI)</label>
                    </div>

                    <!-- Text Input Group (Initially hidden) -->
                    <div id="toggle-text-input-container">
                        <a href="#" id="toggle-text-input">or paste text directly</a>
                    </div>
                    <div class="input-group" id="text-input-container" style="display: none;"> <!-- JS controlled -->
                        <textarea id="text-input" class="input-field" placeholder="Paste your text here..."></textarea>
                        <div class="input-row">
                            <input id="text-input-title" type="text" placeholder="Enter a title (optional)" class="input-field">
                            <button type="button" id="process-text-btn" class="button">Read Text</button>
                        </div>
                    </div>

                    <!-- Example Ebook Section -->
                    <div class="example-book-section">
                        <p>Don't have an ebook? Try our example:</p>
                        <a id="example-book-btn" class="button success-button" href="https://raw.githubusercontent.com/dat-lequoc/apps/refs/heads/main/ebooks/Kundera%2C%20Milan%20-%20The%20Unbearable%20Lightness%20of%20Being%20(2017%2C%20Faber%20and%20Faber)%20-%20libgen.li.epub" target="_blank" rel="noopener">Download Sample Book</a>
                    </div>
                </div>

                <div class="auth-section" id="auth-section">
                    <!-- Content dynamically updated by JS -->
                    <p>Sign in to save books to your library.</p>
                </div>
                
                <!-- Library Section -->
                <div id="library-section" style="display: none;">
                    <!-- Removed list-management div -->
                    <div id="list-controls-wrapper"> <!-- New wrapper -->
                        <div id="list-badge-container">
                             <!-- Badges will be populated here by JS -->
                        </div>
                        <div id="create-list-group"> <!-- Moved here -->
                            <input type="text" id="new-list-name" placeholder="New list name..." />
                            <button type="button" id="create-list-btn" class="button">+</button>
                        </div>
                    </div>
                    <div id="library-list">
                        <!-- Library items will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Top navbar -->
        <div id="navbar">
            <div id="book-title">Ebook Title</div>
            <div id="navbar-buttons">
                <button type="button" class="navbar-btn" id="toc-btn" aria-label="Table of Contents">☰</button>
                <button type="button" class="navbar-btn" id="settings-btn" aria-label="Settings">⚙️</button>
                <button type="button" class="navbar-btn" id="home-btn" aria-label="Home">⌂</button>
            </div>
        </div>

        <!-- Main reader area -->
        <div id="reader-container">
            <div id="content-area">
                <!-- Placeholder for Source URL -->
                <div id="source-url-display" style="display: none; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); font-size: 0.9rem;">
                    Source: <a id="source-url-content-link" href="#" target="_blank" rel="noopener noreferrer" style="word-break: break-all; color: var(--primary-color);"></a>
                </div>
                <!-- Chapter content will be added here by JS -->
            </div>
            <div id="progress-bar"></div>
        </div>
        
        <!-- Navigation buttons -->
        <div id="nav-controls">
            <button type="button" class="nav-btn" id="prev-btn" aria-label="Previous Chapter">←</button>
            <button type="button" class="nav-btn" id="next-btn" aria-label="Next Chapter">→</button>
        </div>

        <!-- Table of contents panel -->
        <div id="toc-panel">
            <div id="toc-header">
                <h3>Table of Contents</h3>
                <button type="button" class="navbar-btn" id="close-toc-btn" aria-label="Close">✕</button>
            </div>
            <div id="toc-content"></div>
        </div>

        <!-- Settings panel -->
        <div id="settings-panel">
            <div class="settings-section">
                <div class="settings-title">Font Size</div>
                <div class="font-size-controls">
                    <button type="button" class="font-btn" id="font-decrease-btn" aria-label="Decrease Font Size">A-</button>
                    <span id="font-size-value">100%</span>
                    <button type="button" class="font-btn" id="font-increase-btn" aria-label="Increase Font Size">A+</button>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Line Height</div>
                <div class="line-height-controls">
                    <button type="button" class="font-btn" id="line-height-decrease-btn" aria-label="Decrease Line Height">-</button>
                    <span id="line-height-value">1.6</span>
                    <button type="button" class="font-btn" id="line-height-increase-btn" aria-label="Increase Line Height">+</button>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Theme</div>
                <div class="theme-options">
                    <div class="theme-option light-option" data-theme="light" title="Light Theme"></div>
                    <div class="theme-option sepia-option" data-theme="sepia" title="Sepia Theme"></div>
                    <div class="theme-option dark-option active" data-theme="dark" title="Dark Theme"></div>
                </div>
            </div>
            
            <div class="settings-section">
                <div class="settings-title">Display Mode</div>
                <div class="settings-row">
                    <label for="markdown-mode-toggle">Markdown Mode</label>
                    <input type="checkbox" id="markdown-mode-toggle">
                </div>
            </div>

            <!-- AI Features Section -->
            <div class="settings-section" id="ai-features-section">
                <div class="settings-title">AI Features</div>
                <div id="ai-settings-content">
                    <!-- This will be populated dynamically -->
                    <p>Loading AI settings...</p>
                </div>
                <div class="settings-row ai-toggle">
                    <label for="translation-toggle">Text Selection Translation</label>
                    <input type="checkbox" id="translation-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="auto-speak-toggle">Auto Speak Flashcard Words</label>
                    <input type="checkbox" id="auto-speak-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="speak-selection-toggle">Speak Full Selection (instead of just flashcard word)</label>
                    <input type="checkbox" id="speak-selection-toggle">
                </div>
                <div class="settings-row">
                    <label for="speech-language">Speech Language</label>
                    <select id="speech-language">
                        <option value="en-US">English</option>
                        <option value="fr-FR">French</option>
                    </select>
                </div>
                <!-- Summarize button and response area removed -->
            </div>
            <!-- Source URL Section removed from settings -->
        </div>
    
        <!-- Overlay for panels -->
        <div id="overlay"></div>
        
        <!-- Loading indicator -->
        <div id="loading">
            <div class="spinner"></div>
        </div>
        
        <!-- Translation popup -->
        <div id="translation-popup">
            <div id="translation-content"></div>
            <div id="translation-loading">
                <div class="spinner"></div>
            </div>
        </div>
        
        <!-- Toast notification -->
        <div id="toast"></div>

        <!-- File input (hidden) -->
        <input type="file" id="file-input" accept=".txt,.epub,.pdf" style="display: none;"> <!-- Standard practice -->
    </div>

    <script>
        // App Modules
        const EbookApp = (function() {
            // Supabase client initialization
            const supabaseUrl = 'https://iioxqphxakvhhtyvdhrh.supabase.co';
            const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpb3hxcGh4YWt2aGh0eXZkaHJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg4MzQ5MjAsImV4cCI6MjA1NDQxMDkyMH0.7I2CaBH1DyiRYEtzunIM5-l3GaWYT15Mly39jW-ga5Q';
            const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);
            
            // DOM Elements Cache
            const DOM = {
                app: document.getElementById('app'),
                welcomeScreen: document.getElementById('welcome-screen'),
                readerContainer: document.getElementById('reader-container'),
                contentArea: document.getElementById('content-area'),
                navbar: document.getElementById('navbar'),
                bookTitle: document.getElementById('book-title'),
                tocBtn: document.getElementById('toc-btn'),
                settingsBtn: document.getElementById('settings-btn'),
                homeBtn: document.getElementById('home-btn'),
                tocPanel: document.getElementById('toc-panel'),
                closeTocBtn: document.getElementById('close-toc-btn'),
                tocContent: document.getElementById('toc-content'),
                settingsPanel: document.getElementById('settings-panel'),
                overlay: document.getElementById('overlay'),
                fileInput: document.getElementById('file-input'),
                openFileBtn: document.getElementById('open-file-btn'),
                exampleBookBtn: document.getElementById('example-book-btn'),
                textInput: document.getElementById('text-input'),
                textInputTitle: document.getElementById('text-input-title'),
                processTextBtn: document.getElementById('process-text-btn'),
                toggleTextInput: document.getElementById('toggle-text-input'),
                textInputContainer: document.getElementById('text-input-container'),
                urlInputContainer: document.getElementById('url-input-container'),
                urlInput: document.getElementById('url-input'),
                processUrlBtn: document.getElementById('process-url-btn'),
                fontDecreaseBtn: document.getElementById('font-decrease-btn'),
                fontIncreaseBtn: document.getElementById('font-increase-btn'),
                fontSizeValue: document.getElementById('font-size-value'),
                lineHeightDecreaseBtn: document.getElementById('line-height-decrease-btn'),
                lineHeightIncreaseBtn: document.getElementById('line-height-increase-btn'),
                lineHeightValue: document.getElementById('line-height-value'),
                themeOptions: document.querySelectorAll('.theme-option'),
                progressBar: document.getElementById('progress-bar'),
                prevBtn: document.getElementById('prev-btn'),
                nextBtn: document.getElementById('next-btn'),
                loading: document.getElementById('loading'),
                toast: document.getElementById('toast'),
                loginBtn: document.getElementById('login-btn'),
                librarySection: document.getElementById('library-section'),
                authSection: document.getElementById('auth-section'),
                // summarizeBtn removed
                aiSettingsContent: document.getElementById('ai-settings-content'),
                translationToggle: document.getElementById('translation-toggle'),
                autoSpeakToggle: document.getElementById('auto-speak-toggle'),
                speakSelectionToggle: document.getElementById('speak-selection-toggle'), // Added Speak Selection toggle
                speechLanguage: document.getElementById('speech-language'),
                // aiResponseArea removed
                translationPopup: document.getElementById('translation-popup'),
                translationContent: document.getElementById('translation-content'),
                translationLoading: document.getElementById('translation-loading'),
                markdownModeToggle: document.getElementById('markdown-mode-toggle'), // Added Markdown toggle
                cleanUrlContentToggle: document.getElementById('clean-url-content-toggle'), // Added URL cleaning toggle
                sourceUrlDisplay: document.getElementById('source-url-display'),      // Added source URL display area in content
                sourceUrlContentLink: document.getElementById('source-url-content-link'), // Added source URL link in content area
                // listFilter: document.getElementById('list-filter'), // Removed list filter dropdown
                listBadgeContainer: document.getElementById('list-badge-container'), // Added badge container
                createListBtn: document.getElementById('create-list-btn'),       // Added create list button
                newListNameInput: document.getElementById('new-list-name'),     // Added new list name input
                createListGroup: document.getElementById('create-list-group') // Added create list group
            };

            // App state
            let state = {
                // Book data
                bookData: {
                    title: '',
                    content: '',
                    chapters: [],
                    currentPosition: 0,
                    sourceUrl: null, // Added to store the original URL
                    currentListId: null // Added to store the list_id of the currently open book
                },
                // User settings
                settings: {
                    fontSize: 100,
                    lineHeight: 1.6,
                    theme: 'dark',
                    markdownModeEnabled: false, // Added Markdown mode setting
                    speakSelectionEnabled: false // Added Speak Selection setting
                },

                // User data
                session: null,
                userApiSettings: null,
                
                // UI state
                translationTimer: null,
                navbarHideTimer: null,
                debounceTimers: {},
                bookLists: [], // Added for custom lists
                selectedListId: 'all', // Default to 'All' view
                isCreatingList: false, // Flag for list creation UI state

                // Event handling
                touchStartY: 0,
                touchEndY: 0,
                lastSelectionRect: null
            };

            // Initialize the app
            function init() {
                setupEventListeners();
                checkAuthAndLoadApiSettings();
                loadUserPreferences();
            }

            // Set up event listeners
            function setupEventListeners() {
                // File handling
                DOM.openFileBtn.addEventListener('click', () => DOM.fileInput.click());
                DOM.fileInput.addEventListener('change', handleFileSelected);
                DOM.processTextBtn.addEventListener('click', processInputText);
                DOM.exampleBookBtn.addEventListener('click', function() {
                    downloadExampleBook();
                });
                DOM.toggleTextInput.addEventListener('click', function(e) {
                    e.preventDefault();
                    DOM.textInputContainer.style.display = DOM.textInputContainer.style.display === 'none' ? 'block' : 'none';
                });
                DOM.processUrlBtn.addEventListener('click', processUrlInput);

                // Navigation
                DOM.tocBtn.addEventListener('click', toggleTocPanel);
                DOM.closeTocBtn.addEventListener('click', closeTocPanel);
                DOM.settingsBtn.addEventListener('click', toggleSettingsPanel);
                DOM.homeBtn.addEventListener('click', goToHome);
                DOM.overlay.addEventListener('click', closeAllPanels);
                DOM.prevBtn.addEventListener('click', goToPrevious);
                DOM.nextBtn.addEventListener('click', goToNext);
                
                // Content area interactions
                DOM.contentArea.addEventListener('click', handleContentClick);
                DOM.contentArea.addEventListener('scroll', debounce(updateProgressBar, 100));
                
                // Handle swipe gestures
                DOM.contentArea.addEventListener('touchstart', handleTouchStart);
                DOM.contentArea.addEventListener('touchend', handleTouchEnd);
                
                // Font size controls
                DOM.fontDecreaseBtn.addEventListener('click', () => {
                    decreaseFontSize();
                    saveUserPreferences();
                });
                DOM.fontIncreaseBtn.addEventListener('click', () => {
                    increaseFontSize();
                    saveUserPreferences();
                });
                
                // Line height controls
                DOM.lineHeightDecreaseBtn.addEventListener('click', () => {
                    decreaseLineHeight();
                    saveUserPreferences();
                });
                DOM.lineHeightIncreaseBtn.addEventListener('click', () => {
                    increaseLineHeight();
                    saveUserPreferences();
                });
                
                // Theme selection
                DOM.themeOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        setTheme(option.getAttribute('data-theme'));
                        saveUserPreferences();
                    });
                });

                // Markdown Mode Toggle
                DOM.markdownModeToggle.addEventListener('change', function() {
                    state.settings.markdownModeEnabled = this.checked;
                    displayCurrentChapter(); // Re-render content
                    saveUserPreferences();
                });
                
                // AI features
                // summarizeBtn listener removed
                DOM.translationToggle.addEventListener('change', function() {
                    localStorage.setItem('translation-enabled', this.checked);
                    saveUserPreferences();
                });
                DOM.autoSpeakToggle.addEventListener('change', function() {
                    localStorage.setItem('auto-speak-enabled', this.checked);
                    saveUserPreferences();
                });

                // Speak Selection Toggle
                DOM.speakSelectionToggle.addEventListener('change', function() {
                    state.settings.speakSelectionEnabled = this.checked;
                    localStorage.setItem('speak-selection-enabled', this.checked);
                    saveUserPreferences();
                });

                DOM.speechLanguage.addEventListener('change', function() {
                    localStorage.setItem('speech-language', this.value);
                    saveUserPreferences();
                });
                
                // Selection for translation
                document.addEventListener('selectionchange', handleTextSelection);
                
                // Login button
                DOM.loginBtn.addEventListener('click', () => {
                    window.open('index.html', '_blank');
                });

                // List management listeners
                // DOM.listFilter.addEventListener('change', handleListFilterChange); // Removed
                DOM.listBadgeContainer.addEventListener('click', handleListBadgeClick); // Added
                DOM.createListBtn.addEventListener('click', toggleCreateListInput); // Modified

                // Global document events
                document.addEventListener('keydown', handleKeyPress);
                document.addEventListener('selectionchange', debounce(handleTextSelection, 300));
                // Add listener to close dropdowns on outside click
                document.addEventListener('click', handleGlobalClick);
            }

            // Handle clicks outside of specific elements (like dropdowns)
            function handleGlobalClick(event) {
                // Close move-to-list dropdowns
                const openDropdowns = document.querySelectorAll('.move-list-dropdown.visible');
                openDropdowns.forEach(dropdown => {
                    // Check if the click was outside the dropdown and its corresponding button
                    const moveButton = dropdown.previousElementSibling; // Assumes button is right before dropdown
                    if (!dropdown.contains(event.target) && !moveButton.contains(event.target)) {
                        dropdown.classList.remove('visible');
                    }
                });

                // Cancel list creation if clicking outside the input/button
                // Check remains the same as DOM.createListGroup is the direct container
                if (state.isCreatingList && !DOM.createListGroup.contains(event.target)) {
                    cancelListCreation();
                }
            }

            // Handle keyboard shortcuts
            function handleKeyPress(e) {
                // Only handle shortcuts when not in input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                // Left arrow - previous chapter
                if (e.key === 'ArrowLeft' && e.altKey) {
                    goToPrevious();
                    e.preventDefault();
                }
                
                // Right arrow - next chapter
                if (e.key === 'ArrowRight' && e.altKey) {
                    goToNext();
                    e.preventDefault();
                }
                
                // Escape - close panels or cancel list creation
                if (e.key === 'Escape') {
                    if (state.isCreatingList) {
                        cancelListCreation();
                    } else {
                        closeAllPanels();
                    }
                    e.preventDefault();
                }

                // Enter key in new list input confirms creation
                if (e.key === 'Enter' && state.isCreatingList && e.target === DOM.newListNameInput) {
                    handleCreateList();
                    e.preventDefault();
                }

                // T - toggle table of contents
                if (e.key === 't' && !e.ctrlKey && !e.metaKey) {
                    toggleTocPanel();
                    e.preventDefault();
                }
                
                // S - toggle settings
                if (e.key === 's' && !e.ctrlKey && !e.metaKey) {
                    toggleSettingsPanel();
                    e.preventDefault();
                }
                
                // H - go home
                if (e.key === 'h' && !e.ctrlKey && !e.metaKey) {
                    goToHome();
                    e.preventDefault();
                }
                
                // + or = increase font size
                if ((e.key === '+' || e.key === '=') && (e.ctrlKey || e.metaKey)) {
                    increaseFontSize();
                    saveUserPreferences();
                    e.preventDefault();
                }
                
                // - decrease font size
                if (e.key === '-' && (e.ctrlKey || e.metaKey)) {
                    decreaseFontSize();
                    saveUserPreferences();
                    e.preventDefault();
                }
            }

            // Handle touch gestures
            function handleTouchStart(e) {
                state.touchStartY = e.touches[0].clientY;
            }
            
            function handleTouchEnd(e) {
                state.touchEndY = e.changedTouches[0].clientY;
                
                // Calculate the distance of the swipe
                const distance = state.touchStartY - state.touchEndY;
                
                // If the swipe distance is greater than 50px and we're at the top of the content
                if (distance < -50 && DOM.contentArea.scrollTop <= 0) {
                    toggleNavbar();
                }
            }
            
            // File handling
            function handleFileSelected() {
                const file = DOM.fileInput.files[0];
                if (!file) return;
                
                showLoading();
                
                // Update book title
                DOM.bookTitle.textContent = file.name;
                state.bookData.title = file.name;
                state.bookData.currentListId = null; // Reset list ID for file uploads

                // Process file based on extension
                const fileExtension = file.name.split('.').pop().toLowerCase();
                if (fileExtension === 'txt') {
                    processTextFile(file);
                } else if (fileExtension === 'epub') {
                    processEpubFile(file);
                } else if (fileExtension === 'pdf') {
                    processPdfFile(file);
                } else {
                    hideLoading();
                    showToast('Unsupported file format');
                }
            }
            
            function processInputText() {
                const text = DOM.textInput.value.trim();
                if (!text) {
                    showToast('Please enter some text');
                    return;
                }
                
                showLoading();
                
                // Update book title
                let customTitle = DOM.textInputTitle.value.trim();
                
                // If no title is given, use the first 30 characters of the text
                if (!customTitle) {
                    customTitle = text.substring(0, 20).trim();
                    // Add ellipsis if the text was truncated
                    if (text.length > 20) {
                        customTitle += '...';
                    }
                }

                DOM.bookTitle.textContent = customTitle;
                state.bookData.title = customTitle;
                state.bookData.currentListId = null; // Reset list ID for pasted text

                try {
                    state.bookData.content = text;
                    // Create a single chapter with all the text content
                    state.bookData.chapters = [{
                        title: customTitle,
                        content: text,
                        startLine: 0,
                        endLine: text.split('\n').length
                    }];
                    
                    showBook();
                } catch (error) {
                    console.error('Error processing input text:', error);
                    showToast('Error processing text');
                } finally {
                    hideLoading();
                }
            }
            
            function processTextFile(file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        state.bookData.content = text;
                        
                        // Simple chapter detection based on line breaks and possible chapter indicators
                        const lines = text.split('\n');
                        let chapters = [];
                        let chapterMarkers = [];
                        
                        // Find potential chapter breaks
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            
                            // Look for chapter indicators
                            if ((line === '' || i === 0) && i < lines.length - 1) {
                                const nextLine = lines[i+1].trim();
                                // Match chapter headings: Chapter X, CHAPTER X, Part X, Section X, or Roman numerals
                                if (nextLine.match(/^(Chapter|CHAPTER|\bPart\b|\bSection\b|[IVXLCDM]+\.?)/)) {
                                    chapterMarkers.push(i === 0 ? 0 : i+1);
                                }
                            }
                        }
                        
                        // If no chapters detected, create arbitrary chapters every 1000 lines
                        if (chapterMarkers.length <= 1) {
                            for (let i = 0; i < lines.length; i += 1000) {
                                chapterMarkers.push(i);
                            }
                        }
                        
                        // Create chapters
                        for (let i = 0; i < chapterMarkers.length; i++) {
                            const start = chapterMarkers[i];
                            const end = i < chapterMarkers.length - 1 ? chapterMarkers[i+1] : lines.length;
                            const chapterContent = lines.slice(start, end).join('\n');
                            
                            // Get a reasonable chapter title
                            let title = `Chapter ${i+1}`;
                            if (lines[start] && lines[start].trim()) {
                                title = lines[start].trim();
                                // If title is too long, truncate it
                                if (title.length > 50) {
                                    title = title.substring(0, 47) + '...';
                                }
                            }
                            
                            chapters.push({
                                title: title,
                                content: chapterContent,
                                startLine: start,
                                endLine: end
                            });
                        }
                        
                        state.bookData.chapters = chapters;
                        showBook();
                    } catch (error) {
                        console.error('Error processing text file:', error);
                        showToast('Error processing file');
                    } finally {
                        hideLoading();
                    }
                };
                
                reader.onerror = function(error) {
                    console.error('Error reading file:', error);
                    hideLoading();
                    showToast('Error reading file');
                };
                
                reader.readAsText(file);
            }
            
            function processEpubFile(file) {
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    try {
                        const arrayBuffer = e.target.result;
                        
                        // Check if JSZip is available
                        if (typeof JSZip === 'undefined') {
                            // Load JSZip dynamically if not available
                            await loadExternalScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
                        }
                        
                        await extractEpubContent(arrayBuffer);
                    } catch (error) {
                        console.error('Error processing EPUB:', error);
                        hideLoading();
                        showToast('Error processing EPUB file');
                    }
                };
                
                reader.onerror = function(error) {
                    console.error('Error reading EPUB file:', error);
                    hideLoading();
                    showToast('Error reading EPUB file');
                };
                
                reader.readAsArrayBuffer(file);
            }
            
            async function loadExternalScript(url) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = url;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
                    document.head.appendChild(script);
                });
            }
            
            async function extractEpubContent(arrayBuffer) {
                try {
                    const jszip = new JSZip();
                    const zip = await jszip.loadAsync(arrayBuffer);
                    
                    // Find the OPF file through container.xml
                    const containerXml = await zip.file('META-INF/container.xml').async('text');
                    const parser = new DOMParser();
                    const containerDoc = parser.parseFromString(containerXml, 'application/xml');
                    const rootFile = containerDoc.querySelector('rootfile');
                    
                    if (!rootFile) {
                        throw new Error('Invalid EPUB: container.xml doesn\'t contain a rootfile');
                    }
                    
                    const rootFilePath = rootFile.getAttribute('full-path');
                    const rootDir = rootFilePath.substring(0, rootFilePath.lastIndexOf('/') + 1) || '';
                    
                    // Get the OPF file
                    const opfContent = await zip.file(rootFilePath).async('text');
                    const opfDoc = parser.parseFromString(opfContent, 'application/xml');
                    
                    // Get metadata
                    const metadataElem = opfDoc.querySelector('metadata');
                    if (metadataElem) {
                        const titleElem = metadataElem.querySelector('dc\\:title, title');
                        if (titleElem && titleElem.textContent) {
                            state.bookData.title = titleElem.textContent.trim();
                            DOM.bookTitle.textContent = state.bookData.title;
                        }
                    }
                    
                    // Get the spine items (reading order)
                    const spine = opfDoc.querySelector('spine');
                    const manifest = opfDoc.querySelector('manifest');
                    
                    if (!spine || !manifest) {
                        throw new Error('Invalid EPUB: missing spine or manifest');
                    }
                    
                    // Map all manifest items
                    const manifestItems = {};
                    manifest.querySelectorAll('item').forEach(item => {
                        const id = item.getAttribute('id');
                        const href = item.getAttribute('href');
                        const mediaType = item.getAttribute('media-type');
                        
                        manifestItems[id] = { href, mediaType };
                    });
                    
                    // Get reading order from spine
                    const spineItems = [];
                    spine.querySelectorAll('itemref').forEach(itemref => {
                        const idref = itemref.getAttribute('idref');
                        if (manifestItems[idref] && manifestItems[idref].mediaType.includes('html')) {
                            spineItems.push({
                                id: idref,
                                href: manifestItems[idref].href
                            });
                        }
                    });
                    
                    // Load all HTML files from the spine
                    const contentPromises = spineItems.map(item => {
                        const fullPath = rootDir + item.href;
                        return zip.file(fullPath).async('text').then(content => {
                            return { id: item.id, content, href: item.href };
                        }).catch(error => {
                            console.error(`Error loading ${fullPath}:`, error);
                            return { id: item.id, content: `[Error loading content: ${error.message}]`, href: item.href };
                        });
                    });
                    
                    const chaptersContent = await Promise.all(contentPromises);
                    
                    // Process chapter content
                    state.bookData.chapters = [];
                    
                    chaptersContent.forEach((chapter, index) => {
                        // Extract text from HTML
                        const htmlDoc = parser.parseFromString(chapter.content, 'text/html');
                        
                        // Extract title
                        let title = `Chapter ${index + 1}`;
                        // Try to get title from headings
                        const headingElements = htmlDoc.querySelectorAll('h1, h2, h3, h4');
                        if (headingElements.length > 0) {
                            title = headingElements[0].textContent.trim();
                        } else {
                            // Try to get title from filename
                            const filename = chapter.href.split('/').pop().replace(/\.[^/.]+$/, "");
                            if (filename && !filename.startsWith('chapter') && !/^\d+$/.test(filename)) {
                                title = filename.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                            }
                        }
                        
                        // Extract text content with improved formatting
                        let textContent = '';
                        
                        // Process all content elements
                        const contentElements = htmlDoc.querySelectorAll('body *');
                        contentElements.forEach(element => {
                            // Skip script and style tags
                            if (element.tagName === 'SCRIPT' || element.tagName === 'STYLE') {
                                return;
                            }
                            
                            // Process by element type
                            if (element.tagName.match(/^H[1-6]$/)) {
                                if (element.textContent.trim()) {
                                    textContent += element.textContent.trim() + '\n\n';
                                }
                            } else if (element.tagName === 'P') {
                                if (element.textContent.trim()) {
                                    textContent += element.textContent.trim() + '\n\n';
                                }
                            } else if (element.tagName === 'BR') {
                                textContent += '\n';
                            } else if (element.tagName === 'HR') {
                                textContent += '\n* * *\n\n';
                            } else if (element.tagName === 'BLOCKQUOTE') {
                                if (element.textContent.trim()) {
                                    textContent += '> ' + element.textContent.trim().replace(/\n/g, '\n> ') + '\n\n';
                                }
                            } else if (element.tagName === 'UL' || element.tagName === 'OL') {
                                const listItems = element.querySelectorAll('li');
                                listItems.forEach((li, liIndex) => {
                                    const prefix = element.tagName === 'OL' ? `${liIndex + 1}. ` : '- ';
                                    if (li.textContent.trim()) {
                                        textContent += prefix + li.textContent.trim() + '\n';
                                    }
                                });
                                textContent += '\n';
                            } else if (element.tagName === 'DIV' && element.children.length === 0 && element.textContent.trim()) {
                                // Only add text from divs that don't have child elements and have text
                                textContent += element.textContent.trim() + '\n\n';
                            }
                        });
                        
                        // Fallback if no content was extracted
                        if (textContent.trim() === '') {
                            const body = htmlDoc.querySelector('body');
                            if (body) {
                                textContent = body.textContent.trim().replace(/\s+/g, ' ');
                                
                                // Add paragraph breaks
                                textContent = textContent.replace(/\.\s+/g, '.\n\n');
                            }
                        }
                        
                        // Remove excessive newlines
                        textContent = textContent.replace(/\n{3,}/g, '\n\n');
                        
                        state.bookData.chapters.push({
                            title: title,
                            content: textContent,
                            startLine: 0,
                            endLine: textContent.split('\n').length
                        });
                    });
                    
                    if (state.bookData.chapters.length === 0) {
                        // Create a fallback chapter if extraction failed
                        state.bookData.chapters.push({
                            title: state.bookData.title || 'Content',
                            content: "Could not extract readable content from this EPUB file.",
                            startLine: 0,
                            endLine: 1
                        });
                    }
                    
                    showBook();
                    hideLoading();
                } catch (error) {
                    console.error('Error extracting EPUB content:', error);
                    hideLoading();
                    showToast('Error processing EPUB file');
                }
            }
            
            function processPdfFile(file) {
                const reader = new FileReader();
                reader.onload = function() {
                    showToast('PDF support is limited. For a better experience, use a dedicated PDF reader app.');
                    
                    // Create a basic chapter with an explanation
                    state.bookData.chapters = [{
                        title: state.bookData.title || 'PDF Content',
                        content: "PDF content extraction is limited in this simple reader.\n\nFor a better experience with PDFs, consider using a dedicated PDF reader app.",
                        startLine: 0,
                        endLine: 2
                    }];
                    
                    showBook();
                    hideLoading();
                };
                reader.onerror = function(error) {
                    console.error('Error reading PDF file:', error);
                    hideLoading();
                    showToast('Error reading PDF file');
                };
                reader.readAsArrayBuffer(file);
            }

            // Firecrawl API helper
            async function firecrawlScrapeRequest(apiKey, url) {
                console.log('Attempting to scrape URL:', url); // Log the URL being sent
                try {
                    const response = await fetch('https://api.firecrawl.dev/v0/scrape', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({ url: url })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `Firecrawl API request failed with status ${response.status}`);
                    }
                    
                    return await response.json();
                } catch (error) {
                    console.error('Error calling Firecrawl API:', error);
                    // More detailed error logging
                    console.error('Error details during Firecrawl API call:', error);
                    return { error: { message: error.message || 'Failed to connect to Firecrawl API' } };
                }
            }

            // Process URL input using Firecrawl
            async function processUrlInput() {
                const url = DOM.urlInput.value.trim();
                if (!url) {
                    showToast('Please enter a valid URL');
                    return;
                }

                // Check for Firecrawl API key
                if (!state.userApiSettings || !state.userApiSettings.firecrawl_api_key) {
                    showToast('Firecrawl API key not configured. Please set it up in the main dashboard.');
                    // Optionally open the dashboard in a new tab
                    // window.open('index.html', '_blank'); 
                    return;
                }

                // Add loading state to button
                DOM.processUrlBtn.classList.add('loading');
                DOM.processUrlBtn.disabled = true;
                // Optionally show the main loading overlay as well
                // showLoading(); 

                DOM.bookTitle.textContent = `Reading: ${url}`; // Temporary title
                state.bookData.title = url; // Use URL as initial title
                state.bookData.currentListId = null; // Reset list ID for direct URL reading

                try {
                    const response = await firecrawlScrapeRequest(state.userApiSettings.firecrawl_api_key, url);

                    if (response.error) {
                        throw new Error(response.error.message);
                    }

                    if (!response.data || !response.data.markdown) {
                        throw new Error('No markdown content received from Firecrawl.');
                    }

                    let finalMarkdownContent = response.data.markdown;

                    // Step 2: Optionally clean content with AI
                    if (DOM.cleanUrlContentToggle.checked) {
                        showToast('Cleaning content with AI...', 3000);
                        // Ensure Gemini API is available
                        if (!state.userApiSettings || !state.userApiSettings.api_key) {
                            throw new Error('Gemini API key not configured. Cannot clean content.');
                        }
                        try {
                            finalMarkdownContent = await cleanMarkdownWithAI(finalMarkdownContent);
                            showToast('AI cleaning complete.', 2000);
                        } catch (aiError) {
                            console.error('AI Cleaning Error:', aiError);
                            showToast(`AI cleaning failed: ${aiError.message}. Using raw content.`);
                            // Fallback to raw content if AI cleaning fails
                        }
                    }

                    state.bookData.content = finalMarkdownContent; // Store final markdown (raw or cleaned)

                    // --- START: AI Title and Category Generation ---
                    showToast('Generating title and category with AI...', 3000);
                    const { generatedTitle, listId } = await generateTitleAndCategory(finalMarkdownContent);

                    if (generatedTitle) {
                        state.bookData.title = generatedTitle; // Use AI title
                        DOM.bookTitle.textContent = state.bookData.title;
                        showToast(`AI generated title: "${generatedTitle}"`, 3000);
                    } else {
                        // Fallback to Firecrawl title or URL if AI fails
                        if (response.data.metadata && response.data.metadata.title) {
                            state.bookData.title = response.data.metadata.title;
                            DOM.bookTitle.textContent = state.bookData.title;
                        }
                        // If still no title, the URL is already set as state.bookData.title
                        showToast('Could not generate AI title, using default.', 2000);
                    }

                    // Assign the determined list ID (will be null if categorization failed or no lists)
                    state.bookData.currentListId = listId;
                    if (listId !== null) {
                        const listName = state.bookLists.find(l => l.id === listId)?.name || 'Unknown List';
                        showToast(`Categorized into: "${listName}"`, 3000);
                        console.log("Categorized into: ", listName);
                    } else {
                         showToast('Categorized as Unlisted.', 2000);
                        console.log("Categorized as Unlisted: ", listId);
                    }
                    // --- END: AI Title and Category Generation ---


                    // Process markdown into chapters (simple split for now, could be improved)
                    // Treat major headings (##) as chapter breaks
                    const lines = finalMarkdownContent.split('\n');
                    let chapters = [];
                    let currentChapterContent = [];
                    let currentChapterTitle = state.bookData.title || 'Chapter 1';
                    let chapterIndex = 1;

                    lines.forEach((line, index) => {
                        const trimmedLine = line.trim();
                        if (trimmedLine.startsWith('## ') && currentChapterContent.length > 0) {
                            // Start new chapter
                            chapters.push({
                                title: currentChapterTitle,
                                content: currentChapterContent.join('\n'),
                                startLine: 0, // Adjust if needed
                                endLine: 0    // Adjust if needed
                            });
                            currentChapterTitle = trimmedLine.substring(3).trim() || `Chapter ${++chapterIndex}`;
                            currentChapterContent = [line]; // Include the heading in the new chapter
                        } else {
                            if (trimmedLine.startsWith('## ') && currentChapterContent.length === 0) {
                                // Set title for the first chapter
                                currentChapterTitle = trimmedLine.substring(3).trim() || `Chapter ${chapterIndex}`;
                            }
                            currentChapterContent.push(line);
                        }
                    });

                    // Add the last chapter
                    if (currentChapterContent.length > 0) {
                         chapters.push({
                            title: currentChapterTitle,
                            content: currentChapterContent.join('\n'),
                            startLine: 0, // Adjust if needed
                            endLine: 0    // Adjust if needed
                        });
                    }
                    
                    // If no chapters were created (e.g., no '##' headings), create one chapter
                    if (chapters.length === 0) {
                         chapters.push({
                            title: state.bookData.title || 'Content',
                            content: markdownContent,
                            startLine: 0,
                            endLine: lines.length
                        });
                    }

                    state.bookData.chapters = chapters;

                    // --- Auto-enable Markdown mode for URL content ---
                    state.settings.markdownModeEnabled = true;
                    DOM.markdownModeToggle.checked = true;
                    // --- End change ---

                    // Store the original URL
                    state.bookData.sourceUrl = url; 

                    showBook(); // This will now render with Markdown enabled

                } catch (error) {
                    console.error('Error processing URL:', error);
                    showToast(`Error reading URL: ${error.message}`);
                    goToHome(); // Go back to welcome screen on error
                } finally {
                    // Reset button state regardless of success or failure
                    DOM.processUrlBtn.classList.remove('loading');
                    DOM.processUrlBtn.disabled = false;
                    hideLoading();
                }
            }

            // Scrape a link and save it to the library
            async function scrapeAndSaveLink(url) {
                // 1. Check for necessary API keys
                if (!state.userApiSettings || !state.userApiSettings.firecrawl_api_key) {
                    showToast('Firecrawl API key needed to scrape. Configure in dashboard.', 4000);
                    // Optionally prompt user to configure or open dashboard
                    // if (confirm("Firecrawl API key missing. Open dashboard to configure?")) {
                    //     window.open('index.html', '_blank');
                    // }
                    return;
                }
                // Optional: Check for Gemini key if cleaning is desired
                const canClean = state.userApiSettings.api_key && DOM.cleanUrlContentToggle.checked;
                if (DOM.cleanUrlContentToggle.checked && !state.userApiSettings.api_key) {
                     showToast('Gemini API key needed for cleaning. Scraping raw content.', 3000);
                }

                // 2. Call Firecrawl API
                showToast(`Scraping "${url}"...`, 2000); // Notify user scraping has started
                try {
                    const response = await firecrawlScrapeRequest(state.userApiSettings.firecrawl_api_key, url);
                    if (response.error) {
                        throw new Error(response.error.message || 'Firecrawl request failed');
                    }

                    if (!response.data || !response.data.markdown) {
                        throw new Error('No markdown content received from Firecrawl.');
                    }

                    let finalMarkdownContent = response.data.markdown;
                    const scrapedTitle = (response.data.metadata && response.data.metadata.title) || url;

                    // 3. Optionally clean content with AI
                    if (canClean) {
                        showToast(`Cleaning content for "${scrapedTitle}"...`, 3000);
                        try {
                            finalMarkdownContent = await cleanMarkdownWithAI(finalMarkdownContent);
                            showToast('AI cleaning complete.', 2000);
                        } catch (aiError) {
                            console.error('AI Cleaning Error:', aiError);
                            showToast(`AI cleaning failed: ${aiError.message}. Saving raw content.`, 3000);
                        }
                    }

                    // 4. Prepare book data for saving
                    const scrapedBookData = {
                        title: scrapedTitle,
                        content: finalMarkdownContent, // Store the full markdown
                        file_type: 'url', // Indicate it came from a URL scrape
                        metadata: {
                            chapters: [{ // Create a single chapter
                                title: 'Content', // Use a generic title for the single chapter
                                content: finalMarkdownContent, // Include content here too
                                startLine: 0,
                                endLine: finalMarkdownContent.split('\n').length
                            }],
                            markdownModeEnabled: true // Always enable markdown for scraped content
                        },
                        last_position: { // Default starting position
                            chapter: 0,
                            percentComplete: 0,
                            scroll: 0,
                            timestamp: new Date().getTime()
                        }
                    };

                    // 5. Save the new book to the library, passing the current book's list ID
                    await saveScrapedBook(scrapedBookData, state.bookData.currentListId);

                } catch (error) {
                    console.error('Error scraping and saving link:', error);
                    showToast(`Error scraping "${url}": ${error.message}`, 5000);
                }
            }

            // Save a newly scraped book to the Supabase library
            async function saveScrapedBook(scrapedBookData, targetListId = null) {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) {
                    console.error('Cannot save scraped book: User not logged in.');
                    showToast('Please sign in to save scraped content.', 4000);
                    return false; // Indicate failure
                }

                try {
                    // Insert the new book data
                    const { error } = await supabase
                        .from('ebooks')
                        .insert({
                            user_id: session.user.id,
                            title: scrapedBookData.title,
                            // Avoid saving extremely large content directly if needed,
                            // but for now, let's assume metadata.chapters.content is sufficient
                            content: null, // Content is stored in metadata.chapters[0].content
                            file_type: scrapedBookData.file_type,
                            metadata: scrapedBookData.metadata,
                            last_position: scrapedBookData.last_position,
                            list_id: targetListId, // Assign to the target list
                            // created_at and updated_at will be set by default
                        });

                    if (error) {
                        // Handle potential duplicate titles or other DB errors
                        if (error.code === '23505') { // Unique constraint violation (likely title)
                             console.warn(`Book with title "${scrapedBookData.title}" already exists. Skipping save.`);
                             showToast(`Book "${scrapedBookData.title}" already in library.`, 3000);
                             return true; // Treat as success if already exists
                        } else {
                            throw error; // Re-throw other errors
                        }
                    }

                    console.log(`Successfully saved scraped book: "${scrapedBookData.title}"`);
                    showToast(`"${scrapedBookData.title}" saved to library!`, 3000); // Show success toast here
                    // Optionally refresh library view if welcome screen is active
                    if (DOM.welcomeScreen.style.display !== 'none') {
                        loadUserLibrary();
                    }
                    return true; // Indicate success

                } catch (error) {
                    console.error('Error saving scraped book to Supabase:', error);
                    showToast(`Failed to save "${scrapedBookData.title}" to library. DB Error.`, 4000);
                    return false; // Indicate failure
                }
            }

            // Show confirmation toast for link actions
            function showLinkActionConfirmation(url, linkText) {
                // Remove any existing confirmation toast
                const existingToast = document.querySelector('.link-action-toast');
                if (existingToast) {
                    existingToast.remove();
                }

                // Create the toast element
                const toast = document.createElement('div');
                toast.className = 'link-action-toast';
                toast.innerHTML = `
                    <div class="link-action-header">
                        <span>Action for Link:</span>
                        <button type="button" class="link-action-close-btn" aria-label="Close">×</button>
                    </div>
                    <div class="link-action-url" title="${escapeHTML(url)}">${escapeHTML(linkText)}</div>
                    <div class="link-action-buttons">
                        <button type="button" class="link-action-btn open">Open Link</button>
                        <button type="button" class="link-action-btn scrape">Scrape & Save</button>
                    </div>
                `;

                // Append to body
                document.body.appendChild(toast);

                // Add event listeners
                const closeBtn = toast.querySelector('.link-action-close-btn');
                const openBtn = toast.querySelector('.link-action-btn.open');
                const scrapeBtn = toast.querySelector('.link-action-btn.scrape');

                const removeToast = () => {
                    toast.classList.remove('visible');
                    // Remove from DOM after transition
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300); // Match CSS transition duration
                };

                closeBtn.addEventListener('click', removeToast);

                openBtn.addEventListener('click', () => {
                    window.open(url, '_blank', 'noopener noreferrer');
                    removeToast();
                });

                scrapeBtn.addEventListener('click', () => {
                    scrapeAndSaveLink(url); // Call the existing scrape function
                    removeToast();
                });

                // Make the toast visible with transition
                requestAnimationFrame(() => {
                    toast.classList.add('visible');
                });

                 // Optional: Auto-hide after a delay (e.g., 15 seconds)
                 setTimeout(removeToast, 15000);
            }

            // Book display functions
            function showBook() {
                // Hide welcome screen
                DOM.welcomeScreen.style.display = 'none';
                
                // Show content
                displayCurrentChapter();
                
                // Show navbar briefly
                DOM.navbar.classList.add('visible');
                
                // Set timeout to auto-hide navbar
                clearTimeout(state.navbarHideTimer);
                state.navbarHideTimer = setTimeout(() => {
                    DOM.navbar.classList.remove('visible');
                }, 3000);
                
                // Populate table of contents
                populateToc();
                
                // Save book to library
                saveBookToLibrary();
            }
            
            function displayCurrentChapter() {
                const chapter = state.bookData.chapters[state.bookData.currentPosition];
                if (!chapter) return;
                
                DOM.contentArea.innerHTML = ''; // Clear previous content
                
                // Update chapter title in navbar
                DOM.bookTitle.textContent = `${state.bookData.title || 'Book'} - ${chapter.title}`;
    
                // Check if Markdown mode is enabled
                if (state.settings.markdownModeEnabled) {
                    // Render Markdown with basic formatting (headings, links, bold) while preserving line breaks
                    let processedContent = chapter.content;

                    // Apply heading markdown FIRST (important to do before paragraph/br logic)
                    // Match headings at the beginning of a line
                    processedContent = processedContent.replace(/^###### (.*$)/gim, '<h6>$1</h6>');
                    processedContent = processedContent.replace(/^##### (.*$)/gim, '<h5>$1</h5>');
                    processedContent = processedContent.replace(/^#### (.*$)/gim, '<h4>$1</h4>');
                    processedContent = processedContent.replace(/^### (.*$)/gim, '<h3>$1</h3>');
                    processedContent = processedContent.replace(/^## (.*$)/gim, '<h2>$1</h2>');
                    processedContent = processedContent.replace(/^# (.*$)/gim, '<h1>$1</h1>');

                    // Apply [link text](url) markdown -> <a> tags
                    // Added rel="noopener noreferrer" for security
                    processedContent = processedContent.replace(/\[(.*?)\]\((.*?)\)/g, (match, text, url) => {
                        const safeUrl = url.trim().replace(/"/g, '&quot;'); // Escape quotes in URL
                        // Basic check for common protocols or relative/anchor paths
                        if (safeUrl.startsWith('http:') || safeUrl.startsWith('https:') || safeUrl.startsWith('/') || safeUrl.startsWith('#')) {
                             // Escape HTML entities in link text to prevent XSS if text contains HTML chars
                             // We will apply bold *after* this, so don't escape the asterisks here yet.
                             const escapedText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                             return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${escapedText}</a>`;
                        }
                        // If URL looks unsafe or not standard, just display the escaped text
                        return text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    });

                    // Apply **bold** markdown -> <strong> tags SECOND
                    // Using a non-greedy match for content inside **
                    // This will now correctly apply bold inside the already created <a> tags or anywhere else.
                    processedContent = processedContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

                    // Replace newline characters with <br> tags to preserve line breaks
                    processedContent = processedContent.replace(/\n/g, '<br>');

                    // Set the innerHTML. Assumes the original markdown source is relatively safe
                    // or that the potential harm from unescaped HTML (outside links/bold) is acceptable.
                    DOM.contentArea.innerHTML = processedContent;

                    // Ensure wrapping works correctly, overriding potential inherited styles
                    DOM.contentArea.style.whiteSpace = 'normal';
                    DOM.contentArea.style.wordWrap = 'break-word';

                } else {
                    // Original HTML rendering logic
                    const lines = chapter.content.split('\n');
                    let currentElement = null;

                    lines.forEach((line, index) => {
                        // ... (keep existing HTML rendering logic here) ...
                        const trimmedLine = line.trim();

                        if (trimmedLine.startsWith('# ')) { // H1
                            const h = document.createElement('h1');
                            h.textContent = trimmedLine.substring(2).trim();
                            DOM.contentArea.appendChild(h);
                            currentElement = null;
                        } else if (trimmedLine.startsWith('## ')) { // H2
                            const h = document.createElement('h2');
                            h.textContent = trimmedLine.substring(3).trim();
                            DOM.contentArea.appendChild(h);
                            currentElement = null;
                        } else if (trimmedLine.startsWith('### ')) { // H3
                            const h = document.createElement('h3');
                            h.textContent = trimmedLine.substring(4).trim();
                            DOM.contentArea.appendChild(h);
                            currentElement = null;
                        } else if (trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ')) { // List item
                            if (!currentElement || currentElement.tagName !== 'UL') {
                                currentElement = document.createElement('ul');
                                DOM.contentArea.appendChild(currentElement);
                            }
                            const li = document.createElement('li');
                            li.textContent = trimmedLine.substring(2).trim();
                            currentElement.appendChild(li);
                        } else if (trimmedLine === '---' || trimmedLine === '***') { // Horizontal rule
                            DOM.contentArea.appendChild(document.createElement('hr'));
                            currentElement = null;
                        } else if (trimmedLine) { // Paragraph
                            const p = document.createElement('p');
                            // Basic inline markdown (bold, italic) - could be expanded
                            let processedLine = line.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                            processedLine = processedLine.replace(/\*(.*?)\*/g, '<em>$1</em>');
                            p.innerHTML = processedLine; // Use innerHTML for basic formatting
                            p.setAttribute('data-p-index', index); // Add index for position tracking
                            DOM.contentArea.appendChild(p);
                            currentElement = null;
                        } else if (currentElement && currentElement.tagName === 'P') {
                             // Add extra space after a paragraph if followed by a blank line
                             DOM.contentArea.appendChild(document.createElement('br'));
                             currentElement = null;
                        } else if (!currentElement) {
                             // Add single break for consecutive blank lines outside paragraphs/lists
                             DOM.contentArea.appendChild(document.createElement('br'));
                        }
                    });
                } // End of the 'else' block for HTML rendering
                
                // Initially scroll to top (will be updated if restoring position)
                DOM.contentArea.scrollTop = 0;
                
                // Update navigation buttons visibility
                updateNavigationButtonsState();
                
                // Update progress bar
                updateProgressBar();
                
                // summarizeBtn visibility logic removed
    
                // Update Source URL display at the top of the content area
                if (state.bookData.sourceUrl) {
                    DOM.sourceUrlContentLink.href = state.bookData.sourceUrl;
                    DOM.sourceUrlContentLink.textContent = state.bookData.sourceUrl;
                    DOM.sourceUrlDisplay.style.display = 'block'; // Show the display area
                } else {
                    DOM.sourceUrlDisplay.style.display = 'none'; // Hide the display area
                }
            }
            
            function populateToc() {
                DOM.tocContent.innerHTML = '';
                
                state.bookData.chapters.forEach((chapter, index) => {
                    const item = document.createElement('div');
                    item.className = 'toc-item';
                    item.textContent = chapter.title;
                    item.setAttribute('data-index', index);
                    
                    if (index === state.bookData.currentPosition) {
                        item.classList.add('toc-active');
                    }
                    
                    item.addEventListener('click', () => {
                        state.bookData.currentPosition = index;
                        displayCurrentChapter();
                        closeTocPanel();
                        
                        // Save progress after TOC navigation
                        saveBookToLibrary();
                    });
                    
                    DOM.tocContent.appendChild(item);
                });
            }
            
            function updateNavigationButtonsState() {
                // Update previous button visibility
                if (state.bookData.currentPosition <= 0) {
                    DOM.prevBtn.style.opacity = '0.5';
                    DOM.prevBtn.style.pointerEvents = 'none';
                } else {
                    DOM.prevBtn.style.opacity = '1';
                    DOM.prevBtn.style.pointerEvents = 'auto';
                }
                
                // Update next button visibility
                if (state.bookData.currentPosition >= state.bookData.chapters.length - 1) {
                    DOM.nextBtn.style.opacity = '0.5';
                    DOM.nextBtn.style.pointerEvents = 'none';
                } else {
                    DOM.nextBtn.style.opacity = '1';
                    DOM.nextBtn.style.pointerEvents = 'auto';
                }
            }
            
            // Navigation functions
            function goToPrevious() {
                if (state.bookData.currentPosition > 0) {
                    state.bookData.currentPosition--;
                    displayCurrentChapter();
                    saveBookToLibrary();
                }
            }
            
            function goToNext() {
                if (state.bookData.currentPosition < state.bookData.chapters.length - 1) {
                    state.bookData.currentPosition++;
                    displayCurrentChapter();
                    saveBookToLibrary();
                }
            }
            
            // UI Controls
            function toggleNavbar() {
                DOM.navbar.classList.toggle('visible');
                
                if (DOM.navbar.classList.contains('visible')) {
                    clearTimeout(state.navbarHideTimer);
                    state.navbarHideTimer = setTimeout(() => {
                        DOM.navbar.classList.remove('visible');
                    }, 3000);
                }
            }
            
            function toggleTocPanel() {
                DOM.tocPanel.classList.toggle('visible');
                DOM.overlay.classList.toggle('visible');
                DOM.settingsPanel.classList.remove('visible');
                
                // If the TOC panel is now visible, scroll to the active chapter
                if (DOM.tocPanel.classList.contains('visible')) {
                    // Find the active TOC item
                    const activeItem = DOM.tocContent.querySelector('.toc-item[data-index="' + state.bookData.currentPosition + '"]');
                    
                    if (activeItem) {
                        // Scroll the item into view with some offset from the top
                        setTimeout(() => {
                            activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 100); // Small delay to ensure panel is visible
                    }
                }
            }
            
            function closeTocPanel() {
                DOM.tocPanel.classList.remove('visible');
                DOM.overlay.classList.remove('visible');
            }
            
            function toggleSettingsPanel() {
                DOM.settingsPanel.classList.toggle('visible');
                DOM.overlay.classList.toggle('visible');
                DOM.tocPanel.classList.remove('visible');
            }
            
            function closeSettingsPanel() {
                DOM.settingsPanel.classList.remove('visible');
                DOM.overlay.classList.remove('visible');
            }
            
            function closeAllPanels() {
                DOM.tocPanel.classList.remove('visible');
                DOM.settingsPanel.classList.remove('visible');
                DOM.overlay.classList.remove('visible');
            }
            
            function goToHome() {
                DOM.welcomeScreen.style.display = 'flex';
                DOM.navbar.classList.remove('visible');
                closeAllPanels();
                DOM.fileInput.value = ''; // Reset file input
                DOM.textInput.value = ''; // Reset text input
                DOM.textInputTitle.value = ''; // Reset text input title
                
                // Reset book data
                state.bookData = {
                    title: '',
                    content: '',
                    chapters: [],
                    currentPosition: 0,
                    sourceUrl: null // Reset sourceUrl
                };
                state.selectedListId = 'all'; // Reset selected list to 'All'
                state.bookLists = []; // Clear loaded lists

                // Hide the source URL display in the content area
                DOM.sourceUrlDisplay.style.display = 'none';
                
                // Refresh library and lists if user is logged in
                supabase.auth.getSession().then(({ data: { session } }) => {
                    if (session) {
                        fetchBookLists().then(() => { // Fetches lists and renders badges
                             loadUserLibrary(); // Loads books for the default 'all' list
                        });
                    } else {
                        // Ensure badges are cleared/reset if logged out
                        renderListBadges();
                    }
                });
            }

            function handleContentClick(e) {
                // --- START: Intercept Markdown Link Clicks ---
                if (state.settings.markdownModeEnabled) {
                    const link = e.target.closest('a'); // Find the nearest ancestor anchor tag

                    if (link && link.href && DOM.contentArea.contains(link)) { // Ensure link is within content area
                        // It's a click on a link within the content area in Markdown mode
                        e.preventDefault(); // Stop the browser from following the link immediately
                        const url = link.href;

                        // Check if it's a scrapable URL (http/https)
                        if (url.startsWith('http://') || url.startsWith('https://')) {
                            // Show confirmation toast instead of automatically scraping
                            const linkText = link.textContent || url; // Use link text or URL as display
                            showLinkActionConfirmation(url, linkText);
                        } else {
                            // For non-http links (e.g., mailto:, javascript:, internal anchors #), open normally or ignore
                            console.warn(`Link is not directly scrapable or is internal: ${url}`);
                            // Optionally open non-http links in a new tab if desired
                            // window.open(url, '_blank', 'noopener noreferrer');
                            showToast(`Cannot scrape this type of link: ${url.substring(0, 30)}...`, 3000);
                        }
                        return; // We've handled this click, no need for further UI toggling logic
                    }
                }
                // --- END: Intercept Markdown Link Clicks ---

                // Existing code follows:
                // Don't toggle UI if text is being selected
                const selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) return;
                
                // Get click position
                const clickY = e.clientY;
                const viewportHeight = window.innerHeight;
                
                // If navbar is visible, hide it on click outside of navbar
                if (DOM.navbar.classList.contains('visible')) {
                    // Check if click is outside navbar
                    if (!DOM.navbar.contains(e.target)) {
                        DOM.navbar.classList.remove('visible');
                    }
                } 
                // If navbar is hidden, show it on click in top area
                else if (clickY <= viewportHeight * 0.15) {
                    DOM.navbar.classList.add('visible');
                    
                    // Auto-hide after delay
                    clearTimeout(state.navbarHideTimer);
                    state.navbarHideTimer = setTimeout(() => {
                        DOM.navbar.classList.remove('visible');
                    }, 3000);
                }
                
                // Hide translation popup when clicking elsewhere
                DOM.translationPopup.classList.remove('visible');
                setTimeout(() => {
                    DOM.translationPopup.style.display = 'none';
                }, 200); // Match transition duration
            }
            
            // Handle text selection for translation
            function handleTextSelection() {
                // Check if translation is enabled
                const translationEnabled = DOM.translationToggle.checked;
                if (!translationEnabled) {
                    return;
                }
                
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                // Hide the popup if no text is selected
                if (!selectedText) {
                    DOM.translationPopup.style.display = 'none';
                    clearTimeout(state.translationTimer);
                    return;
                }
                
                // Only proceed for reasonable text selection
                if (selectedText.length > 1 && selectedText.length < 500) {
                    // Clear any existing timer
                    clearTimeout(state.translationTimer);
                    
                    // Set a new timer for translation (750ms delay)
                    state.translationTimer = setTimeout(() => {
                        // Get the selection's bounding box
                        const range = selection.getRangeAt(0);
                        const rect = range.getBoundingClientRect();
                        state.lastSelectionRect = rect; // <-- SAVE the rect for flashcard positioning
                        
                        // Position the translation popup safely within viewport
                        positionTranslationPopup(rect);
                        
                        // Show loading state
                        DOM.translationContent.textContent = 'Translating...';
                        DOM.translationLoading.style.display = 'flex';

                        // Speak the full selection if enabled
                        if (state.settings.speakSelectionEnabled) {
                            speakText(selectedText);
                        }

                        // Get translation (and potentially generate flashcard which might speak word if setting is off)
                        translateText(selectedText);
                    }, 750);
                }
            }
            
            function positionTranslationPopup(rect) {
                const popup = DOM.translationPopup;
                
                // Get viewport dimensions
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Make sure popup is displayed so we can get its dimensions
                popup.style.display = 'block';
                popup.classList.remove('visible');
                
                // Initial position
                let leftPos = rect.left + window.scrollX;
                let topPos = rect.bottom + window.scrollY + 10;
                
                // Get popup dimensions
                const popupWidth = popup.offsetWidth;
                const popupHeight = popup.offsetHeight;
                
                // Adjust horizontal position
                if (leftPos + popupWidth > viewportWidth - 10) {
                    leftPos = Math.max(10, viewportWidth - popupWidth - 10);
                }
                
                // Adjust vertical position
                if (topPos + popupHeight > viewportHeight + window.scrollY - 10) {
                    // Position above selection if it would go off bottom
                    topPos = rect.top + window.scrollY - popupHeight - 10;
                    
                    // If now goes off top, position to the side instead
                    if (topPos < window.scrollY) {
                        // Try right side
                        leftPos = rect.right + window.scrollX + 10;
                        topPos = rect.top + window.scrollY;
                        
                        // If goes off right edge, try left side
                        if (leftPos + popupWidth > viewportWidth - 10) {
                            leftPos = Math.max(10, rect.left + window.scrollX - popupWidth - 10);
                        }
                    }
                }
                
                // Update popup position
                popup.style.left = `${leftPos}px`;
                popup.style.top = `${topPos}px`;
                
                // Show the popup with transition
                requestAnimationFrame(() => {
                    popup.classList.add('visible');
                });
            }
            
            // Settings controls
            function decreaseFontSize() {
                if (state.settings.fontSize > 70) {
                    state.settings.fontSize -= 10;
                    updateFontSize();
                } else {
                    showToast('Minimum font size reached');
                }
            }
            
            function increaseFontSize() {
                if (state.settings.fontSize < 200) {
                    state.settings.fontSize += 10;
                    updateFontSize();
                } else {
                    showToast('Maximum font size reached');
                }
            }
            
            function updateFontSize() {
                DOM.contentArea.style.fontSize = `${state.settings.fontSize}%`;
                DOM.fontSizeValue.textContent = `${state.settings.fontSize}%`;
                // Save immediately to localStorage
                localStorage.setItem('ebook-font-size', state.settings.fontSize);
            }
            
            function decreaseLineHeight() {
                if (state.settings.lineHeight > 1.2) {
                    state.settings.lineHeight = Math.round((state.settings.lineHeight - 0.1) * 10) / 10;
                    updateLineHeight();
                } else {
                    showToast('Minimum line height reached');
                }
            }
            
            function increaseLineHeight() {
                if (state.settings.lineHeight < 2.4) {
                    state.settings.lineHeight = Math.round((state.settings.lineHeight + 0.1) * 10) / 10;
                    updateLineHeight();
                } else {
                    showToast('Maximum line height reached');
                }
            }
            
            function updateLineHeight() {
                DOM.contentArea.style.lineHeight = state.settings.lineHeight;
                DOM.lineHeightValue.textContent = state.settings.lineHeight;
                // Save immediately to localStorage
                localStorage.setItem('ebook-line-height', state.settings.lineHeight);
            }
            
            function setTheme(theme) {
                // Remove all theme classes
                document.body.classList.remove('light-theme', 'sepia-theme', 'dark-theme');
                // Add the selected theme class
                document.body.classList.add(`${theme}-theme`);
                
                // Update active state on theme options
                DOM.themeOptions.forEach(option => {
                    option.classList.remove('active');
                    if (option.getAttribute('data-theme') === theme) {
                        option.classList.add('active');
                    }
                });
                
                state.settings.theme = theme;
                // Save immediately to localStorage
                localStorage.setItem('ebook-theme', theme);
            }
            
            function updateProgressBar() {
                if (!state.bookData.chapters.length) return;
                
                const scrollTop = DOM.contentArea.scrollTop;
                const scrollHeight = DOM.contentArea.scrollHeight;
                const clientHeight = DOM.contentArea.clientHeight;
                
                // Calculate chapter progress (0-1)
                let chapterProgress = 0;
                if (scrollHeight > clientHeight) {
                    chapterProgress = scrollTop / (scrollHeight - clientHeight);
                }
                
                // Calculate overall progress 
                const chaptersProgress = state.bookData.currentPosition / Math.max(1, state.bookData.chapters.length - 1);
                const weightedChapterProgress = chapterProgress / state.bookData.chapters.length;
                const overallProgress = (chaptersProgress + weightedChapterProgress) * 100;
                
                // Update progress bar width
                DOM.progressBar.style.width = `${overallProgress}%`;
                
                // Save reading progress to library after a delay
                debounce(saveReadingProgress, 1500)();
            }
            
            // Save reading progress with enhanced position tracking
            function saveReadingProgress() {
                // Store additional metadata for better position restoration
                const currentPosition = {
                    // Basic chapter position
                    chapter: state.bookData.currentPosition,
                    
                    // Percentage through chapter (more resilient to font/layout changes)
                    percentComplete: calculatePercentageComplete(),
                    
                    // Absolute scroll position as fallback
                    scroll: DOM.contentArea.scrollTop || 0,
                    
                    // Current viewport data for validation
                    viewportHeight: DOM.contentArea.clientHeight,
                    contentHeight: DOM.contentArea.scrollHeight,
                    
                    // Timestamp for freshness check
                    timestamp: new Date().getTime(),
                    
                    // Store text anchor for even more precise positioning
                    textAnchor: findVisibleTextAnchor()
                };
                
                // Store in local state
                state.lastPosition = currentPosition;
                
                // Save to library storage
                saveBookToLibrary();
            }
            
            // Calculate percentage complete in current chapter
            function calculatePercentageComplete() {
                const scrollTop = DOM.contentArea.scrollTop;
                const scrollHeight = DOM.contentArea.scrollHeight;
                const clientHeight = DOM.contentArea.clientHeight;
                
                if (scrollHeight <= clientHeight) return 0;
                return scrollTop / (scrollHeight - clientHeight);
            }
            
            // Find the first visible text element as an anchor
            function findVisibleTextAnchor() {
                const paragraphs = DOM.contentArea.querySelectorAll('p');
                const scrollTop = DOM.contentArea.scrollTop;
                const viewportHeight = DOM.contentArea.clientHeight;
                
                // Add index attribute to paragraphs if not already there
                if (!paragraphs[0]?.hasAttribute('data-p-index')) {
                    paragraphs.forEach((p, index) => {
                        p.setAttribute('data-p-index', index);
                    });
                }
                
                // Find the first paragraph that's visible in the viewport
                for (let i = 0; i < paragraphs.length; i++) {
                    const rect = paragraphs[i].getBoundingClientRect();
                    const paragraphTop = rect.top + scrollTop - DOM.contentArea.offsetTop;
                    
                    // If this paragraph is fully or partially visible
                    if (paragraphTop + rect.height > scrollTop && paragraphTop < scrollTop + viewportHeight) {
                        // Get first 50 chars of content for validation, and calculate offset
                        const text = paragraphs[i].textContent?.substring(0, 50) || '';
                        const offset = (scrollTop - paragraphTop) / rect.height;
                        
                        // Return anchor data
                        return {
                            index: parseInt(paragraphs[i].getAttribute('data-p-index')),
                            text: text,
                            offset: Math.max(0, Math.min(1, offset))  // Clamp between 0 and 1
                        };
                    }
                }
                
                // Fallback if no paragraph is found
                return null;
            }
            
            // Utility functions
            function showLoading() {
                DOM.loading.classList.add('visible');
            }
            
            function hideLoading() {
                DOM.loading.classList.remove('visible');
            }
            
            function showToast(message, duration = 3000) {
                const toast = DOM.toast;
                toast.textContent = message;
                toast.classList.add('visible');
                
                setTimeout(() => {
                    toast.classList.remove('visible');
                }, duration);
            }
            
            function debounce(func, delay) {
                const context = this;
                return function() {
                    const args = arguments;
                    const functionName = func.name || 'anonymous';
                    
                    clearTimeout(state.debounceTimers[functionName]);
                    
                    state.debounceTimers[functionName] = setTimeout(() => {
                        func.apply(context, args);
                        delete state.debounceTimers[functionName];
                    }, delay);
                };
            }
            
            // Authentication & API Settings functions
            async function checkAuthAndLoadApiSettings() {
                // Check if the user is logged in
                const { data: { session } } = await supabase.auth.getSession();
                state.session = session;
                
                if (!session) {
                    // Redirect to index.html if not logged in
                    window.location.href = 'index.html';
                    return; // Stop further execution in this function
                } else {
                    // User is signed in
                    DOM.loginBtn.classList.add('hidden');
                    DOM.authSection.innerHTML = `
                        <p>Signed in as ${session.user.email}</p>
                    `;
                    
                    // Load user's library and lists
                    DOM.librarySection.style.display = 'block';
                    fetchBookLists().then(() => { // Fetch lists first
                        loadUserLibrary(); // Then load library (which depends on lists)
                    });
                }

                // User is logged in, check if they have API settings
                state.userApiSettings = await getUserApiSettings();
                
                let aiSettingsHtml = '';
                let canUseAi = false;
                let canUseFirecrawl = false;

                if (state.userApiSettings) {
                    if (state.userApiSettings.api_key && state.userApiSettings.model) {
                        aiSettingsHtml += `
                            <p>✅ Gemini API Key configured</p>
                            <p>Model: ${state.userApiSettings.model}</p>`;
                        canUseAi = true;
                    } else {
                         aiSettingsHtml += `<p>❌ Gemini API Key not configured. <a href="index.html" target="_blank">Set up in dashboard</a>.</p>`;
                    }
                    
                    if (state.userApiSettings.firecrawl_api_key) {
                        aiSettingsHtml += `<p>✅ Firecrawl API Key configured</p>`;
                        canUseFirecrawl = true;
                    } else {
                        aiSettingsHtml += `<p>❌ Firecrawl API Key not configured. <a href="index.html" target="_blank">Set up in dashboard</a>.</p>`;
                    }
                } else {
                    aiSettingsHtml = `
                        <p>To use AI features (Summarize, Translate, Read URL), please 
                        <a href="index.html" target="_blank">sign in and configure API keys</a> in the main dashboard.</p>
                    `;
                }

                DOM.aiSettingsContent.innerHTML = aiSettingsHtml;

                // Enable/disable features based on keys
                DOM.summarizeBtn.style.display = canUseAi ? 'block' : 'none';
                DOM.translationToggle.disabled = !canUseAi; // Disable toggle if no Gemini key
                DOM.processUrlBtn.disabled = !canUseFirecrawl; // Disable URL button if no Firecrawl key
                
                // Add tooltip or visual cue for disabled URL button
                if (!canUseFirecrawl) {
                    DOM.urlInputContainer.title = "Firecrawl API key needed. Set it up in the main dashboard.";
                    DOM.processUrlBtn.style.opacity = "0.5";
                    DOM.processUrlBtn.style.cursor = "not-allowed";
                } else {
                    DOM.urlInputContainer.title = "";
                    DOM.processUrlBtn.style.opacity = "1";
                    DOM.processUrlBtn.style.cursor = "pointer";
                }
                // Removed summarizeBtn display logic from checkAuthAndLoadApiSettings
            }

            // Get the user's Gemini API settings from Supabase
            async function getUserApiSettings() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return null;
                
                const { data, error } = await supabase
                    .from('user_settings')
                    .select('api_key, model, firecrawl_api_key') // Select all needed keys
                    .eq('user_id', session.user.id)
                    .maybeSingle();

                if (error) {
                    console.error('Error fetching API settings:', error);
                    return null;
                }

                return data;
            }

            // --- List Creation UI Functions ---

            function toggleCreateListInput() {
                if (!state.isCreatingList) {
                    // Show input, change button, set state
                    DOM.newListNameInput.style.display = 'block';
                    DOM.newListNameInput.focus();
                    DOM.createListBtn.textContent = '✓'; // Change to checkmark or "Confirm"
                    state.isCreatingList = true;
                } else {
                    // Try to create list
                    handleCreateList();
                    // handleCreateList will call cancelListCreation on success/failure
                }
            }

            function cancelListCreation() {
                DOM.newListNameInput.style.display = 'none';
                DOM.newListNameInput.value = ''; // Clear input
                DOM.createListBtn.textContent = '+'; // Reset button
                state.isCreatingList = false;
            }

            // --- Library functions ---
            async function loadUserLibrary() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                
                const libraryList = document.getElementById('library-list');
                libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Loading books...</div>';

                try {
                    // Base query
                    let query = supabase
                        .from('ebooks')
                        .select('*')
                        .eq('user_id', session.user.id);

                    // Apply list filter
                    if (state.selectedListId === 'all') {
                        // 'all' means show all books, so no list_id filter is applied.
                    } else if (state.selectedListId) {
                        // Filter by specific list ID
                        query = query.eq('list_id', state.selectedListId);
                    } else {
                        // Filter for books not in any list (list_id is null) - This corresponds to the "Unlisted" option
                        query = query.is('list_id', null);
                    }

                    // Add ordering
                    query = query.order('updated_at', { ascending: false });

                    const { data: books, error } = await query;

                    if (error) {
                        throw error;
                    }

                    // Removed update to DOM.currentListName as the element is deleted

                    if (!books || books.length === 0) {
                        libraryList.innerHTML = `<div style="text-align: center; padding: 20px;">This list is empty</div>`;
                        return;
                    }

                    // Display books
                    libraryList.innerHTML = '';
                    books.forEach(book => {
                        const date = new Date(book.updated_at).toLocaleDateString();
                        const progress = calculateOverallProgress(book);
                        
                        const item = document.createElement('div');
                        item.className = 'library-item';
                        item.innerHTML = `
                            <div class="library-item-details">
                                <div class="library-item-title">${escapeHTML(book.title)}</div>
                                <div class="library-item-meta">
                                    ${book.file_type.toUpperCase()} • Last read: ${date} • ${progress}% complete
                                </div>
                                <div class="progress-bar-container">
                                    <div class="progress-bar" style="width: ${progress}%"></div>
                                </div>
                            </div>
                            <div class="library-item-actions" style="position: relative;"> <!-- Added relative positioning -->
                                <!-- Move button/dropdown will be added dynamically if lists exist -->
                                <button class="library-item-move" data-id="${book.id}" data-current-list-id="${book.list_id || ''}" style="display: none;">Move</button>
                                <div class="move-list-dropdown">
                                    <!-- Dropdown options populated by JS -->
                                </div>
                                <button class="library-item-delete" data-id="${book.id}">×</button>
                            </div>
                        `;
                        
                        // Add click event to open the book
                        item.addEventListener('click', (event) => {
                            // Don't open if the delete button was clicked
                            if (event.target.classList.contains('library-item-delete')) {
                                return;
                            }
                            loadBookFromLibrary(book);
                        });
                        
                        libraryList.appendChild(item);

                        // Add Move button functionality if lists exist
                        const moveButton = item.querySelector('.library-item-move');
                        const dropdownContainer = item.querySelector('.move-list-dropdown');

                        if (moveButton && dropdownContainer && state.bookLists.length > 0) {
                            moveButton.style.display = 'inline-block'; // Show the button
                            moveButton.addEventListener('click', (event) => {
                                event.stopPropagation(); // Prevent opening the book or closing dropdown immediately

                                // Close other open dropdowns first
                                document.querySelectorAll('.move-list-dropdown.visible').forEach(dd => {
                                    if (dd !== dropdownContainer) {
                                        dd.classList.remove('visible');
                                    }
                                });

                                // Toggle current dropdown
                                const isVisible = dropdownContainer.classList.toggle('visible');
                                if (isVisible) {
                                    const bookId = moveButton.getAttribute('data-id');
                                    // Use || '' to handle null list_id correctly
                                    const currentListId = moveButton.getAttribute('data-current-list-id') || null;
                                    renderMoveToListDropdown(dropdownContainer, bookId, currentListId);
                                }
                            });
                        }
                    });

                    // Add delete button event listeners
                    document.querySelectorAll('.library-item-delete').forEach(button => {
                        button.addEventListener('click', async (event) => {
                            event.stopPropagation();
                            const bookId = button.getAttribute('data-id');

                            if (confirm('Remove this book from your library?')) {
                                await deleteBookFromLibrary(bookId);
                            }
                        });
                    });
                } catch (error) {
                    console.error('Error loading library:', error);
                    libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Error loading library</div>';
                }
            }

            // --- NEW: List Management Functions ---

            // Fetch book lists from Supabase
            async function fetchBookLists() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;

                try {
                    const { data, error } = await supabase
                        .from('book_lists')
                        .select('id, name')
                        .eq('user_id', session.user.id)
                        .order('name', { ascending: true });

                    if (error) throw error;

                    state.bookLists = data || [];
                    renderListBadges(); // Update the badges
                } catch (error) {
                    console.error('Error fetching book lists:', error);
                    showToast('Could not load book lists');
                    state.bookLists = [];
                    renderListBadges(); // Render empty badges on error
                }
            }

            // Render the list badges
            function renderListBadges() {
                DOM.listBadgeContainer.innerHTML = ''; // Clear existing badges
                const badgeColors = 5; // Number of colors defined in CSS

                // Helper function to create a badge
                const createBadge = (text, listId, isSpecial = false, colorIndex = -1) => {
                    const badge = document.createElement('div');
                    badge.className = 'list-badge';
                    badge.textContent = text;
                    badge.setAttribute('data-list-id', listId === null ? '' : listId); // Use empty string for null

                    // Apply active state
                    const currentIdStr = state.selectedListId === null ? '' : String(state.selectedListId);
                    const badgeIdStr = listId === null ? '' : String(listId);
                    if (currentIdStr === badgeIdStr) {
                        badge.classList.add('active');
                    }

                    // Apply color index for non-special badges
                    if (!isSpecial && colorIndex >= 0) {
                         badge.setAttribute('data-color-index', colorIndex % badgeColors);
                    }

                    return badge;
                };

                // Add 'All' badge
                DOM.listBadgeContainer.appendChild(createBadge('All', 'all', true));

                // Add 'Unlisted' badge
                DOM.listBadgeContainer.appendChild(createBadge('Unlisted', null, true));

                // Add badges for each list
                state.bookLists.forEach((list, index) => {
                    DOM.listBadgeContainer.appendChild(createBadge(list.name, list.id, false, index));
                });
            }

            // Handle list badge click
            function handleListBadgeClick(event) {
                const clickedBadge = event.target.closest('.list-badge');
                if (!clickedBadge || clickedBadge.classList.contains('active')) {
                    return; // Ignore clicks outside badges or on the active badge
                }

                const selectedValue = clickedBadge.getAttribute('data-list-id');
                state.selectedListId = selectedValue === "" ? null : selectedValue; // Store null for 'Unlisted', 'all' for 'All', or the ID

                // Update active state visually
                DOM.listBadgeContainer.querySelectorAll('.list-badge').forEach(badge => {
                    badge.classList.remove('active');
                });
                clickedBadge.classList.add('active');

                loadUserLibrary(); // Reload the library view for the selected list
            }


            // Handle create new list action (called by toggleCreateListInput or Enter key)
            async function handleCreateList() {
                const listName = DOM.newListNameInput.value.trim();
                if (!listName) {
                    showToast('Please enter a name for the new list.');
                    DOM.newListNameInput.focus(); // Keep focus if name is empty
                    return;
                }

                const { data: { session } } = await supabase.auth.getSession();
                if (!session) {
                    showToast('Please sign in to create lists.');
                    return; // Don't reset UI yet
                }

                // Show loading state on button (visual feedback)
                DOM.createListBtn.disabled = true;
                DOM.createListBtn.classList.add('loading');
                DOM.createListBtn.textContent = '...'; // Indicate loading

                try {
                    const { data, error } = await supabase
                        .from('book_lists')
                        .insert({ user_id: session.user.id, name: listName })
                        .select() // Select the newly created list
                        .single(); // Expecting a single result

                    if (error) {
                        if (error.code === '23505') { // Unique constraint violation
                            throw new Error(`List "${listName}" already exists.`);
                        } else {
                            throw error;
                        }
                    }

                    showToast(`List "${listName}" created.`);
                    cancelListCreation(); // Hide input, reset button state
                    await fetchBookLists(); // Refresh the list data and badges
                    // Optionally switch to the new list and reload library
                    // state.selectedListId = data.id;
                    // renderListBadges(); // Update badge active state
                    // loadUserLibrary();

                } catch (error) {
                    console.error('Error creating list:', error);
                    showToast(`Error: ${error.message}`);
                    // Don't cancel on error, allow user to retry or fix name
                    DOM.createListBtn.disabled = false;
                    DOM.createListBtn.classList.remove('loading');
                    DOM.createListBtn.textContent = '✓'; // Keep confirm state on error
                    DOM.newListNameInput.focus();
                }
                // No finally block needed as success calls cancelListCreation
            }

            // Render the dropdown options for moving a book
            function renderMoveToListDropdown(dropdownElement, bookId, currentListIdStr) {
                dropdownElement.innerHTML = ''; // Clear previous options

                // Convert currentListIdStr back to null if it's an empty string
                const currentListId = currentListIdStr === '' ? null : parseInt(currentListIdStr, 10);

                // Option to move to 'Unlisted'
                const unlistedOption = document.createElement('div');
                unlistedOption.className = 'move-list-option';
                unlistedOption.textContent = 'Unlisted'; // Simplified name
                unlistedOption.setAttribute('data-target-list-id', ''); // Use empty string for null

                if (currentListId === null) {
                    unlistedOption.classList.add('disabled');
                    unlistedOption.title = 'Already in this list';
                } else {
                    unlistedOption.addEventListener('click', (e) => {
                        e.stopPropagation();
                        moveBookToList(bookId, null);
                        dropdownElement.classList.remove('visible');
                    });
                }
                dropdownElement.appendChild(unlistedOption);

                // Add separator
                const separator = document.createElement('hr');
                separator.style.margin = '2px 0';
                separator.style.borderColor = 'var(--border-color)';
                dropdownElement.appendChild(separator);


                // Options for each list
                state.bookLists.forEach(list => {
                    const option = document.createElement('div');
                    option.className = 'move-list-option';
                    option.textContent = list.name;
                    option.setAttribute('data-target-list-id', list.id);

                    if (list.id === currentListId) {
                        option.classList.add('disabled');
                        option.title = 'Already in this list';
                    } else {
                        option.addEventListener('click', (e) => {
                            e.stopPropagation();
                            moveBookToList(bookId, list.id);
                            dropdownElement.classList.remove('visible');
                        });
                    }
                    dropdownElement.appendChild(option);
                });
            }


            // Move a book to a different list
            async function moveBookToList(bookId, targetListId) {
                showLoading(); // Show loading indicator
                try {
                    const { error } = await supabase
                        .from('ebooks')
                        .update({ list_id: targetListId, updated_at: new Date() }) // Update list_id and timestamp
                        .eq('id', bookId);

                    if (error) throw error;

                    showToast("Book moved successfully.");
                    loadUserLibrary(); // Refresh the current library view

                } catch (error) {
                    console.error('Error moving book:', error);
                    showToast("Error moving book.");
                } finally {
                    hideLoading(); // Hide loading indicator
                }
            }

            // --- End NEW List Management Functions ---


            // Escape HTML to prevent XSS
            function escapeHTML(str) {
                return str
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }
            
            async function deleteBookFromLibrary(bookId) {
                try {
                    const { error } = await supabase
                        .from('ebooks')
                        .delete()
                        .eq('id', bookId);
                    
                    if (error) {
                        throw error;
                    }
                    
                    // Reload library
                    loadUserLibrary();
                    showToast('Book removed from library');
                } catch (error) {
                    console.error('Error deleting book:', error);
                    showToast('Could not delete the book');
                }
            }
            
            async function saveBookToLibrary() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return false;
                
                if (!state.bookData.title) return false;
                
                try {
                    // Determine file type
                    let fileType = 'txt';
                    if (state.bookData.title.includes('.')) {
                        fileType = state.bookData.title.split('.').pop().toLowerCase();
                    }
                    
                    // Prepare book data
                    const bookContent = state.bookData.content && state.bookData.content.length < 100000 
                        ? state.bookData.content 
                        : null;
                    
                    // Create metadata with chapter information (without full content)
                    const metadata = {
                        chapters: state.bookData.chapters.map(chapter => {
                            // Store selective chapter content to reduce database size
                            return {
                                title: chapter.title,
                                startLine: chapter.startLine,
                                endLine: chapter.endLine,
                                content: chapter.content // Include content for better offline experience
                            };
                        }),
                        // --- Save Markdown mode preference ---
                        markdownModeEnabled: state.settings.markdownModeEnabled,
                        // --- End change ---
                        sourceUrl: state.bookData.sourceUrl // Save the source URL
                    };
                    
                    // Use enhanced position data if available, otherwise create basic position
                    const lastPosition = state.lastPosition || {
                        chapter: state.bookData.currentPosition,
                        scroll: DOM.contentArea.scrollTop || 0,
                        percentComplete: calculatePercentageComplete(),
                        timestamp: new Date().getTime()
                    };
                    
                    // Check if this book already exists
                    const { data: existingBooks } = await supabase
                        .from('ebooks')
                        .select('id')
                        .eq('title', state.bookData.title)
                        .eq('user_id', session.user.id)
                        .maybeSingle();
                    
                    if (existingBooks && existingBooks.id) {
                        // Update existing book - only update progress-related fields
                        const { error } = await supabase
                            .from('ebooks')
                            .update({
                                // title: state.bookData.title, // Don't update title on progress save
                                // content: bookContent,       // Don't update content
                                // file_type: fileType,        // Don't update file type
                                metadata: metadata,
                                last_position: lastPosition,
                                // list_id is updated via moveBookToList, not typically here
                                updated_at: new Date()
                            })
                            .eq('id', existingBooks.id);
                        
                        if (error) throw error;
                    } else {
                        // Insert new book
                        const { error } = await supabase
                            .from('ebooks')
                            .insert({
                                user_id: session.user.id,
                                title: state.bookData.title,
                                content: bookContent,
                                file_type: fileType,
                                metadata: metadata,
                                last_position: lastPosition,
                                // Use the currentListId from state, which might have been set by AI
                                list_id: state.bookData.currentListId || null 
                            });
                        
                        if (error) throw error;
                    }
                    
                    return true;
                } catch (error) {
                    console.error('Error saving book:', error);
                    return false;
                }
            }
            
            async function loadBookFromLibrary(book) {
                showLoading();
                
                try {
                    // Set up book data
                    state.bookData.title = book.title;
                    state.bookData.currentListId = book.list_id || null; // Store the list ID
                    DOM.bookTitle.textContent = book.title;

                    // Check for chapters in metadata
                    if (book.metadata && book.metadata.chapters && book.metadata.chapters.length > 0) {
                        state.bookData.chapters = book.metadata.chapters.map(chapter => {
                            return {
                                title: chapter.title,
                                content: chapter.content || "Chapter content not available",
                                startLine: chapter.startLine,
                                endLine: chapter.endLine
                            };
                        });
                        // Load source URL from metadata
                        if (book.metadata.sourceUrl) {
                            state.bookData.sourceUrl = book.metadata.sourceUrl;
                        } else {
                            state.bookData.sourceUrl = null; // Reset if not present
                        }
                    }
                    // Fallback to content if no chapters in metadata
                    else if (book.content) {
                        state.bookData.content = book.content;
                        
                        // Create a single chapter from content
                        state.bookData.chapters = [{
                            title: book.title,
                            content: book.content,
                            startLine: 0,
                            endLine: book.content.split('\n').length
                        }];
                    } 
                    // No usable content
                    else {
                        throw new Error('Book content not available');
                    }

                    // --- Restore Markdown mode preference ---
                    if (book.metadata && book.metadata.markdownModeEnabled !== undefined) {
                        state.settings.markdownModeEnabled = book.metadata.markdownModeEnabled;
                    } else {
                        // Default for older books or if not set
                        state.settings.markdownModeEnabled = false;
                    }
                    DOM.markdownModeToggle.checked = state.settings.markdownModeEnabled;
                    // --- End change ---

                    // Save last position data for restoration after render
                    const lastPosition = book.last_position || {};

                    // Restore chapter position
                    if (lastPosition.chapter !== undefined) {
                        state.bookData.currentPosition = lastPosition.chapter;
                    }
                    
                    // Show the book
                    showBook();
                    
                    // Attempt to restore reading position with adaptive approach
                    restoreReadingPosition(lastPosition);
                    
                    hideLoading();
                } catch (error) {
                    console.error('Error loading book:', error);
                    hideLoading();
                    showToast('Error loading book: ' + error.message);
                }
            }
            
            // Restore reading position using multiple methods for reliability
            function restoreReadingPosition(lastPosition) {
                if (!lastPosition) return;
                
                // Show toast notification about restoring position
                showToast('Restoring reading position...', 1500);
                
                // Use requestAnimationFrame to ensure content is rendered
                requestAnimationFrame(() => {
                    // Check if position information is fresh enough (within last 90 days)
                    const isPositionRecent = lastPosition.timestamp && 
                        (Date.now() - lastPosition.timestamp < 90 * 24 * 60 * 60 * 1000);
                
                    // First try restoring by text anchor (most reliable across different font sizes/layouts)
                    if (isPositionRecent && lastPosition.textAnchor) {
                        const restored = restoreByTextAnchor(lastPosition.textAnchor);
                        if (restored) return;
                    }
                    
                    // Next try percentage-based position (good for different screen sizes)
                    if (lastPosition.percentComplete !== undefined) {
                        const scrollHeight = DOM.contentArea.scrollHeight;
                        const clientHeight = DOM.contentArea.clientHeight;
                        
                        if (scrollHeight > clientHeight) {
                            const targetPosition = lastPosition.percentComplete * (scrollHeight - clientHeight);
                            DOM.contentArea.scrollTo({
                                top: targetPosition,
                                behavior: 'smooth'
                            });
                            return;
                        }
                    }
                    
                    // Fallback to absolute scroll position
                    if (lastPosition.scroll) {
                        // Check if content height ratio is similar to maintain relative position
                        if (lastPosition.contentHeight && lastPosition.viewportHeight) {
                            const oldRatio = lastPosition.contentHeight / lastPosition.viewportHeight;
                            const newRatio = DOM.contentArea.scrollHeight / DOM.contentArea.clientHeight;
                            
                            // If ratios are reasonably similar, scale the scroll position
                            if (Math.abs(oldRatio - newRatio) < 0.5) {
                                const scaledPosition = lastPosition.scroll * (newRatio / oldRatio);
                                DOM.contentArea.scrollTo({
                                    top: scaledPosition,
                                    behavior: 'smooth'
                                });
                                return;
                            }
                        }
                        
                        // Last resort: try direct scroll position
                        DOM.contentArea.scrollTo({
                            top: lastPosition.scroll,
                            behavior: 'smooth'
                        });
                    }
                });
            }
            
            // Try to find and scroll to the text anchor
            function restoreByTextAnchor(textAnchor) {
                if (!textAnchor || textAnchor.index === undefined) return false;
                
                // Find all paragraphs
                const paragraphs = DOM.contentArea.querySelectorAll('p');
                
                // Try to find paragraph by index
                const paragraph = paragraphs[textAnchor.index];
                if (!paragraph) return false;
                
                // Verify content if text anchor has text (avoid wrong positioning)
                if (textAnchor.text) {
                    const actualText = paragraph.textContent?.substring(0, textAnchor.text.length) || '';
                    // Simple similarity check
                    const isSimilar = actualText.length > 0 && 
                        (actualText === textAnchor.text || 
                        (actualText.length > 10 && actualText.slice(0, 10) === textAnchor.text.slice(0, 10)));
                    
                    if (!isSimilar) {
                        // Content doesn't match, try finding by text search
                        for (let i = 0; i < paragraphs.length; i++) {
                            const searchText = paragraphs[i].textContent?.substring(0, textAnchor.text.length) || '';
                            if (searchText === textAnchor.text || 
                                (searchText.length > 10 && searchText.slice(0, 10) === textAnchor.text.slice(0, 10))) {
                                // Found matching paragraph
                                const rect = paragraphs[i].getBoundingClientRect();
                                const top = paragraphs[i].offsetTop - DOM.contentArea.offsetTop;
                                
                                // Apply offset within paragraph if available
                                const offset = textAnchor.offset || 0;
                                const scrollTarget = top + (offset * rect.height);
                                
                                // Scroll to position with slight offset for better reading
                                DOM.contentArea.scrollTo({
                                    top: Math.max(0, scrollTarget - 50),
                                    behavior: 'smooth'
                                });
                                return true;
                            }
                        }
                        return false;
                    }
                }
                
                // Calculate position in paragraph
                const rect = paragraph.getBoundingClientRect();
                const top = paragraph.offsetTop - DOM.contentArea.offsetTop;
                
                // Apply offset within paragraph if available
                const offset = textAnchor.offset || 0;
                const scrollTarget = top + (offset * rect.height);
                
                // Scroll to position with slight offset for better reading
                DOM.contentArea.scrollTo({
                    top: Math.max(0, scrollTarget - 50),
                    behavior: 'smooth'
                });
                
                return true;
            }
            
            // AI features
            // Gemini API helper functions
            const getApiUrl = (model) => `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=`;
            
            async function geminiRequest(apiKey, message, model) {
                try {
                    const res = await fetch(`${getApiUrl(model)}${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: message }]
                            }]
                        })
                    });
                    
                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(errorData.error?.message || 'API request failed');
                    }
                    
                    return res.json();
                } catch (error) {
                    console.error('Error calling Gemini API:', error);
                    return { error: { message: error.message || 'Failed to connect to Gemini API' } };
                }
            }
            
            // Translate text using Gemini API
            async function translateText(text) {
                if (!state.userApiSettings) {
                    DOM.translationContent.textContent = 'Please configure API key in settings to use translation.';
                    return;
                }
                
                // Show loading indicator
                DOM.translationContent.textContent = '';
                DOM.translationLoading.style.display = 'flex';
                
                try {
                    const prompt = `Translate the following English text to Vietnamese. Only return the translation without any explanation or additional text.\n\nText: "${text}"`;
                    
                    const response = await geminiRequest(
                        state.userApiSettings.api_key, 
                        prompt, 
                        state.userApiSettings.model
                    );
                    
                    // Hide loading indicator
                    DOM.translationLoading.style.display = 'none';
                    
                    if (response.error) {
                        DOM.translationContent.textContent = `Error: ${response.error.message}`;
                        return;
                    }
                    
                    const translation = response?.candidates?.[0]?.content?.parts?.[0]?.text || 'Translation failed.';
                    DOM.translationContent.textContent = translation;
                    
                    // Generate flashcard in parallel
                    generateFlashcard(text);
                } catch (error) {
                    console.error('Error translating text:', error);
                    DOM.translationLoading.style.display = 'none';
                    DOM.translationContent.textContent = 'An error occurred during translation.';
                }
            }
            
            // Generate a flashcard from selected text
            async function generateFlashcard(text) {
                if (!state.userApiSettings) return;
                
                try {
                    const prompt = `Extract a single useful vocabulary word or phrase from this text that would be good for a language learner. If the text is long, choose the most difficult or interesting word/phrase.
                    
                    Text: "${text}"
                    
                    Return in this JSON format without any additional text:
                    {
                        "word": "the extracted word or short phrase",
                        "phrase": "A sentence showing the word in context, with the <b>word</b> in bold",
                        "translation_answer": "vietnamese translation\\nBrief definition in English"
                    }`;
                    
                    const response = await geminiRequest(
                        state.userApiSettings.api_key, 
                        prompt, 
                        state.userApiSettings.model
                    );
                    
                    if (response.error) {
                        console.error('Error generating flashcard:', response.error);
                        return;
                    }
                    
                    const flashcardText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '';
                    
                    // Try to extract JSON from the response
                    try {
                        // Find the JSON part in the response
                        const jsonMatch = flashcardText.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const flashcardData = JSON.parse(jsonMatch[0]);
                            showFlashcardToast(flashcardData);
                        }
                    } catch (jsonError) {
                        console.error('Error parsing flashcard JSON:', jsonError, flashcardText);
                    }
                } catch (error) {
                    console.error('Error generating flashcard:', error);
                }
            }
            
            // Format translation to make Vietnamese part bold and English part italic
            function formatTranslation(translation) {
                // Split by newline - first part is Vietnamese, second part is English definition
                const parts = translation.split('\n');
                if (parts.length > 1) {
                    return `<b>${escapeHTML(parts[0])}</b><br><i>${escapeHTML(parts.slice(1).join('\n'))}</i>`;
                }
                return escapeHTML(translation);
            }
            
            // Show flashcard as a toast notification
            function showFlashcardToast(flashcardData) {
                // Remove any existing flashcard toast
                const existingToast = document.querySelector('.flashcard-toast');
                if (existingToast) {
                    existingToast.remove();
                }
                
                // Create toast element
                const toast = document.createElement('div');
                toast.className = 'flashcard-toast visible';
                
                // New positioning logic: if we have a selection rectangle, position near it
                if (state.lastSelectionRect) {
                    let left = state.lastSelectionRect.left;
                    let top = state.lastSelectionRect.bottom + 10; // 10px offset below the selection
                    
                    // Ensure the flashcard does not run off-screen horizontally.
                    const flashcardWidth = 240; // using the width from our CSS (flashcard-toast width)
                    if (left + flashcardWidth > window.innerWidth) {
                        left = window.innerWidth - flashcardWidth - 10;
                    }
                    
                    // Set inline style to override default CSS positioning
                    toast.style.left = `${left}px`;
                    toast.style.top = `${top}px`;
                    toast.style.bottom = 'auto';
                    toast.style.right = 'auto';
                } else {
                    // Fallback to default bottom-right positioning if no selection rect is available
                    toast.style.bottom = "20px";
                    toast.style.right = "20px";
                }
                
                // Create flashcard content with HTML escaping for security
                toast.innerHTML = `
                    <div class="flashcard-header">
                        <div class="flashcard-word">${escapeHTML(flashcardData.word)}</div>
                        <button type="button" class="flashcard-close-btn" aria-label="Close">×</button>
                    </div>
                    <div class="flashcard-translation">${formatTranslation(flashcardData.translation_answer)}</div>
                    <div class="flashcard-actions">
                        <button type="button" class="flashcard-speak-btn" aria-label="Speak">🔊</button>
                        <button type="button" class="flashcard-save-btn">Save</button>
                    </div>
                `;
                
                // Add to the document
                document.body.appendChild(toast);
                
                // Add close button functionality
                toast.querySelector('.flashcard-close-btn').addEventListener('click', () => {
                    toast.classList.add('fade-out');
                    setTimeout(() => {
                        toast.remove();
                    }, 500);
                });
                
                // Add speak button functionality
                toast.querySelector('.flashcard-speak-btn').addEventListener('click', () => {
                    speakText(flashcardData.word);
                });

                // Auto-speak the flashcard word ONLY if auto-speak is enabled AND speak-full-selection is disabled
                const autoSpeakEnabled = localStorage.getItem('auto-speak-enabled') !== 'false';
                const speakSelectionEnabled = state.settings.speakSelectionEnabled; // Use state value
                if (autoSpeakEnabled && !speakSelectionEnabled) {
                    // Small delay to ensure the toast is fully rendered
                    setTimeout(() => speakText(flashcardData.word), 300);
                }

                // Save button functionality
                toast.querySelector('.flashcard-save-btn').addEventListener('click', async () => {
                    const saveButton = toast.querySelector('.flashcard-save-btn');
                    
                    // Disable button while saving
                    saveButton.textContent = 'Saving...';
                    saveButton.disabled = true;
                    
                    // Only proceed if user is logged in
                    const { data: { session } } = await supabase.auth.getSession();
                    if (!session) {
                        showToast('Please sign in to save flashcards');
                        saveButton.textContent = 'Save';
                        saveButton.disabled = false;
                        return;
                    }
                    
                    try {
                        // Save to Supabase
                        const { error } = await supabase
                            .from('flashcards')
                            .insert({
                                user_id: session.user.id,
                                word: flashcardData.word,
                                phrase: flashcardData.phrase,
                                translation_answer: flashcardData.translation_answer,
                                state: "new",
                                due: new Date().toISOString(),
                                stability: 0.5, // Default stability
                                difficulty: 5, // Default difficulty 
                                elapsed_days: 0,
                                scheduled_days: 0,
                                reps: 0, 
                                lapses: 0
                            });
                            
                        if (error) throw error;
                        
                        // Update UI to show success
                        saveButton.textContent = 'Saved!';
                        saveButton.disabled = true;
                        
                        // Add fade-out animation after a short delay
                        setTimeout(() => {
                            toast.classList.add('fade-out');
                            
                            // Remove the element after the animation completes
                            setTimeout(() => {
                                if (document.body.contains(toast)) {
                                    toast.remove();
                                }
                            }, 500); // Match this duration to the CSS transition time
                        }, 1000);
                        
                    } catch (error) {
                        console.error('Error saving flashcard:', error);
                        saveButton.textContent = 'Failed';
                        
                        // Reset after a delay
                        setTimeout(() => {
                            saveButton.textContent = 'Retry';
                            saveButton.disabled = false;
                        }, 1500);
                    }
                });
                
                // Auto-hide after 20 seconds
                setTimeout(() => {
                    if (document.body.contains(toast)) {
                        toast.classList.add('fade-out');
                        setTimeout(() => toast.remove(), 500);
                    }
                }, 20000);
                
                // Smart positioning to avoid overlaps with selection and translation popup
                if (state.lastSelectionRect) {
                    // Get necessary rectangles and dimensions
                    const toastRect = toast.getBoundingClientRect();
                    const selRect = state.lastSelectionRect;
                    const viewportHeight = window.innerHeight;
                    const viewportWidth = window.innerWidth;
                    const margin = 10; // Margin to maintain between elements
                    
                    // Check if translation popup is visible first
                    let transRect = null;
                    if (DOM.translationPopup.classList.contains('visible')) {
                        transRect = DOM.translationPopup.getBoundingClientRect();
                    }
                    
                    // Calculate possible positions
                    const positions = {
                        below: {
                            top: selRect.bottom + margin,
                            left: Math.max(viewportWidth - toastRect.width - margin, 
                                  Math.min(selRect.left, viewportWidth - toastRect.width - margin))
                        },
                        above: {
                            top: selRect.top - toastRect.height - margin,
                            left: Math.max(viewportWidth - toastRect.width - margin, 
                                  Math.min(selRect.left, viewportWidth - toastRect.width - margin))
                        },
                        right: {
                            top: Math.min(selRect.top, viewportHeight - toastRect.height - margin),
                            left: Math.max(viewportWidth - toastRect.width - margin, selRect.right + margin)
                        },
                        left: {
                            top: Math.min(selRect.top, viewportHeight - toastRect.height - margin),
                            left: Math.max(viewportWidth - toastRect.width - margin, 
                                  selRect.left - toastRect.width - margin)
                        }
                    };
                    
                    // If translation popup is visible, add position below the translation
                    if (transRect) {
                        positions.belowTranslation = {
                            top: transRect.bottom + margin,
                            left: Math.max(viewportWidth - toastRect.width - margin, 
                                  Math.min(transRect.left, viewportWidth - toastRect.width - margin))
                        };
                    }
                    
                    // Function to check if a position would overlap with an element
                    const wouldOverlap = (pos, rect) => {
                        if (!rect) return false;
                        
                        const posRight = pos.left + toastRect.width;
                        const posBottom = pos.top + toastRect.height;
                        
                        return !(posBottom < rect.top || 
                                 pos.top > rect.bottom || 
                                 posRight < rect.left || 
                                 pos.left > rect.right);
                    };
                    
                    // Function to check if position is on screen
                    const isOnScreen = (pos) => {
                        return pos.top >= 0 && 
                               pos.left >= 0 && 
                               pos.left + toastRect.width <= viewportWidth &&
                               pos.top + toastRect.height <= viewportHeight;
                    };
                    
                    // Try each position in order of preference
                    const positionOrder = transRect ? 
                        ['belowTranslation', 'below', 'right', 'left', 'above'] : 
                        ['below', 'right', 'left', 'above'];
                    
                    let bestPosition = null;
                    
                    for (const posName of positionOrder) {
                        const pos = positions[posName];
                        
                        // Skip if position doesn't exist
                        if (!pos) continue;
                        
                        // Skip positions that would be off-screen
                        if (!isOnScreen(pos)) continue;
                        
                        // Check overlaps
                        const overlapsSelection = wouldOverlap(pos, selRect);
                        const overlapsTranslation = wouldOverlap(pos, transRect);
                        
                        // Perfect position - no overlaps
                        if (!overlapsSelection && !overlapsTranslation) {
                            bestPosition = pos;
                            break;
                        }
                        
                        // If we haven't found any valid position yet, use one that at least
                        // doesn't overlap the translation popup (overlapping selection is less problematic)
                        if (!bestPosition && !overlapsTranslation) {
                            bestPosition = pos;
                        }
                    }
                    
                    // If no good position was found, use a fallback
                    if (!bestPosition) {
                        // Try bottom-right corner of viewport as last resort
                        bestPosition = {
                            top: viewportHeight - toastRect.height - margin,
                            left: viewportWidth - toastRect.width - margin
                        };
                    }
                    
                    // Apply the best position
                    toast.style.top = `${bestPosition.top}px`;
                    toast.style.left = `${bestPosition.left}px`;
                    toast.style.bottom = 'auto';
                    toast.style.right = 'auto';
                }
            }
            
            // Function to speak text aloud
            function speakText(text) {
                // Check if speech synthesis is available
                if ('speechSynthesis' in window) {
                    // Cancel any ongoing speech
                    window.speechSynthesis.cancel();
                    
                    // Create a new speech synthesis utterance
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Get language from settings
                    const language = localStorage.getItem('speech-language') || 'en-US';
                    utterance.lang = language;
                    
                    // Try to find a good voice
                    const voices = window.speechSynthesis.getVoices();
                    const languageVoices = voices.filter(voice => voice.lang.startsWith(language.split('-')[0] + '-'));
                    
                    if (languageVoices.length > 0) {
                        // Prefer female voices if available (generally clearer for language learning)
                        const femaleVoice = languageVoices.find(voice => voice.name.includes('female') || voice.name.includes('Female'));
                        utterance.voice = femaleVoice || languageVoices[0];
                    }
                    
                    // Adjust settings for clarity
                    utterance.rate = 0.9; // Slightly slower rate
                    utterance.pitch = 1.0;
                    
                    // Speak the text
                    window.speechSynthesis.speak(utterance);
                } else {
                    console.error('Text-to-speech not supported in this browser');
                    showToast('Text-to-speech not supported in this browser');
                }
            }
            
            // summarizeCurrentChapter function removed
            
            // Save user preferences to Supabase or localStorage
            async function saveUserPreferences() {
                // Build preferences object
                const preferences = {
                    fontSize: state.settings.fontSize,
                    lineHeight: state.settings.lineHeight,
                    theme: state.settings.theme,
                    markdownModeEnabled: state.settings.markdownModeEnabled, // Added Markdown mode
                    translationEnabled: DOM.translationToggle.checked,
                    autoSpeakEnabled: DOM.autoSpeakToggle.checked,
                    speakSelectionEnabled: state.settings.speakSelectionEnabled, // Added Speak Selection
                    speechLanguage: DOM.speechLanguage.value
                };

                // Always save to localStorage as fallback
                localStorage.setItem('ebook-font-size', preferences.fontSize);
                localStorage.setItem('ebook-line-height', preferences.lineHeight);
                localStorage.setItem('ebook-theme', preferences.theme);
                localStorage.setItem('markdown-mode-enabled', preferences.markdownModeEnabled); // Added Markdown mode
                localStorage.setItem('translation-enabled', preferences.translationEnabled);
                localStorage.setItem('auto-speak-enabled', preferences.autoSpeakEnabled);
                localStorage.setItem('speak-selection-enabled', preferences.speakSelectionEnabled); // Added Speak Selection
                localStorage.setItem('speech-language', preferences.speechLanguage);

                // If user is logged in, save to Supabase
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                
                try {
                    // Get existing user_settings
                    const { data, error } = await supabase
                        .from('user_settings')
                        .select('*')
                        .eq('user_id', session.user.id)
                        .maybeSingle();
                    
                    if (error) throw error;
                    
                    // If no settings exist yet, we can't update
                    if (!data) return;
                    
                    // Update with new preferences (preserving existing fields like api_key)
                    const updatedSettings = {
                        ...data,
                        preferences: preferences
                    };
                    
                    // Save to Supabase
                    const { error: updateError } = await supabase
                        .from('user_settings')
                        .update(updatedSettings)
                        .eq('user_id', session.user.id);
                    
                    if (updateError) throw updateError;
                } catch (error) {
                    console.error('Error saving user preferences:', error);
                }
            }
            
            // Load user preferences from Supabase or localStorage
            async function loadUserPreferences() {
                // Try to load from localStorage first (fallback)
                const fontSizeFromStorage = parseInt(localStorage.getItem('ebook-font-size')) || 100;
                const lineHeightFromStorage = parseFloat(localStorage.getItem('ebook-line-height')) || 1.6;
                const themeFromStorage = localStorage.getItem('ebook-theme') || 'dark';
                
                // Apply localStorage settings immediately
                state.settings.fontSize = fontSizeFromStorage;
                state.settings.lineHeight = lineHeightFromStorage;
                state.settings.theme = themeFromStorage;
                
                // Update UI to reflect settings
                updateFontSize();
                updateLineHeight();
                setTheme(state.settings.theme);
                
                // Load translation toggle state
                if (localStorage.getItem('translation-enabled') === 'false') {
                    DOM.translationToggle.checked = false;
                } else {
                    DOM.translationToggle.checked = true;
                }
                
                // Load auto-speak toggle state
                if (localStorage.getItem('auto-speak-enabled') === 'false') {
                    DOM.autoSpeakToggle.checked = false;
                } else {
                    DOM.autoSpeakToggle.checked = true;
                }
                
                // Load speech language setting
                const speechLanguage = localStorage.getItem('speech-language') || 'en-US';
                DOM.speechLanguage.value = speechLanguage;

                // Load Markdown mode setting
                const markdownModeEnabled = localStorage.getItem('markdown-mode-enabled') === 'true';
                state.settings.markdownModeEnabled = markdownModeEnabled;
                DOM.markdownModeToggle.checked = markdownModeEnabled;

                // Load Speak Selection setting
                const speakSelectionEnabled = localStorage.getItem('speak-selection-enabled') === 'true';
                state.settings.speakSelectionEnabled = speakSelectionEnabled;
                DOM.speakSelectionToggle.checked = speakSelectionEnabled;

                // Check if user is logged in to load server settings
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                
                try {
                    // Try to load from Supabase
                    const { data, error } = await supabase
                        .from('user_settings')
                        .select('preferences')
                        .eq('user_id', session.user.id)
                        .maybeSingle();
                    
                    if (error || !data || !data.preferences) return;
                    
                    const prefs = data.preferences;
                    
                    // Apply font size from server
                    if (prefs.fontSize) {
                        state.settings.fontSize = prefs.fontSize;
                        updateFontSize();
                    }
                    
                    // Apply line height from server
                    if (prefs.lineHeight) {
                        state.settings.lineHeight = prefs.lineHeight;
                        updateLineHeight();
                    }
                    
                    // Apply theme from server
                    if (prefs.theme) {
                        setTheme(prefs.theme);
                    }
                    
                    // Apply translation toggle
                    if (prefs.translationEnabled !== undefined) {
                        DOM.translationToggle.checked = prefs.translationEnabled;
                        localStorage.setItem('translation-enabled', prefs.translationEnabled);
                    }
                    
                    // Apply auto speak toggle
                    if (prefs.autoSpeakEnabled !== undefined) {
                        DOM.autoSpeakToggle.checked = prefs.autoSpeakEnabled;
                        localStorage.setItem('auto-speak-enabled', prefs.autoSpeakEnabled);
                    }
                    
                    // Apply speech language
                    if (prefs.speechLanguage) {
                        DOM.speechLanguage.value = prefs.speechLanguage;
                        localStorage.setItem('speech-language', prefs.speechLanguage);
                    }

                    // Apply Markdown mode
                    if (prefs.markdownModeEnabled !== undefined) {
                        state.settings.markdownModeEnabled = prefs.markdownModeEnabled;
                        DOM.markdownModeToggle.checked = prefs.markdownModeEnabled;
                        localStorage.setItem('markdown-mode-enabled', prefs.markdownModeEnabled);
                    }

                    // Apply Speak Selection toggle
                    if (prefs.speakSelectionEnabled !== undefined) {
                        state.settings.speakSelectionEnabled = prefs.speakSelectionEnabled;
                        DOM.speakSelectionToggle.checked = prefs.speakSelectionEnabled;
                        localStorage.setItem('speak-selection-enabled', prefs.speakSelectionEnabled);
                    }
                } catch (error) {
                    console.error('Error loading user preferences:', error);
                }
            }

            // Clean Markdown using Gemini AI (Moved *inside* IIFE)
            async function cleanMarkdownWithAI(rawMarkdown) {
                // Now has access to 'state'
                if (!state.userApiSettings || !state.userApiSettings.api_key) {
                    throw new Error("Gemini API key not available.");
                }
            
                const prompt = `
You are an expert text processing AI. Your task is to clean up the following Markdown content, which was scraped from a webpage. Focus on extracting the main article content and improving its readability for an ebook reader.

Follow these instructions precisely:
1.  **Identify and Remove Extraneous Elements:** Eliminate headers, footers, navigation menus, sidebars, advertisements, cookie notices, social media links, comment sections, and other non-essential clutter.
2.  **Preserve Main Content:** Keep the core article text, including headings (like ##, ###), paragraphs, lists, blockquotes, and code blocks that belong to the main content.
3.  **Format for Readability:** Ensure paragraphs are well-separated (usually by a single blank line). Maintain the original Markdown formatting for elements like bold (**text**), italics (*text*), and inline code (\`code\`).
4.  **Link Handling:** Keep relevant inline links within the main article body. Remove lists of navigation links or footer links.
5.  **Structure:** Try to maintain the logical structure of the article using Markdown headings.
6.  **Remove Stray Random Characters:** Eliminate isolated backslash characters (\\) or sequences of them (\\\\), especially when they appear on their own lines or between paragraphs/images, automatically format properly the surrounding text.
7.  **Output:** Return *only* the cleaned Markdown content. Do not include any introductory phrases, explanations, or apologies (e.g., do not start with "Here is the cleaned content:").

Here is the raw Markdown content:
---
${rawMarkdown}
---
Cleaned Markdown Output:`;
                
                // Use the configured model, or potentially default to 'gemini-2.0-flash' if appropriate
                const modelToUse = state.userApiSettings.model || 'gemini-2.0-flash';
            
                const response = await geminiRequest( // geminiRequest is defined within the IIFE
                    state.userApiSettings.api_key,
                    prompt,
                    modelToUse
                );
            
                if (response.error) {
                    throw new Error(response.error.message || 'AI cleaning request failed');
                }
            
                const cleanedContent = response?.candidates?.[0]?.content?.parts?.[0]?.text;
            
                if (!cleanedContent) {
                    throw new Error('AI returned no content.');
                }
            
                return cleanedContent.trim();
            }

            // Generate Title and Category using AI
            async function generateTitleAndCategory(content) {
                if (!state.userApiSettings || !state.userApiSettings.api_key) {
                    console.warn("Gemini API key not available for title/category generation.");
                    return { generatedTitle: null, listId: null };
                }
                // Ensure we have lists to categorize into
                if (!state.bookLists || state.bookLists.length === 0) {
                    console.warn("No book lists available for categorization.");
                     // Proceed with title generation only
                }

                // Limit content length for the prompt
                const maxContentLength = 5000; // Reduced length for title/category task
                const truncatedContent = content.length > maxContentLength
                    ? content.substring(0, maxContentLength) + "..."
                    : content;

                // Prepare list information for the prompt
                const listOptions = state.bookLists && state.bookLists.length > 0
                    ? state.bookLists.map(list => `- ${list.name} (ID: ${list.id})`).join('\n')
                    : "No lists available.";

                const prompt = `
Analyze the following text content scraped from a webpage.

Content Snippet:
---
${truncatedContent}
---

Based on the content, perform the following tasks:
1.  **Generate a concise and relevant title** for this content (max 10 words).
2.  **Categorize the content** into ONE of the following existing lists. Choose the list that best fits the topic. If none fit well, choose null.

Available Lists:
${listOptions}
- Unlisted (ID: null)

Return the result ONLY in this exact JSON format. The value for "list_id" MUST be either the numeric ID of the chosen list (e.g., 6) or the string "null". Do not include the list name in the "list_id" field.

Example Output:
{
  "title": "Example Title About AI",
  "list_id": 6 
}

Another Example Output (if no list fits):
{
  "title": "Example Title About Something Else",
  "list_id": null
}

Actual Output JSON:
{
  "title": "Generated Title",
  "list_id": chosen_list_id_or_null 
}`;

                try {
                    const response = await geminiRequest(
                        state.userApiSettings.api_key,
                        prompt,
                        'gemini-2.0-flash' // Force flash model
                    );
                    console.log("list options", listOptions);

                    if (response.error) {
                        throw new Error(response.error.message);
                    }

                    const resultText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
                    
                    // Attempt to parse the JSON response
                    let parsedResult = {};
                    try {
                        // Find the JSON part in the response
                        const jsonMatch = resultText.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            parsedResult = JSON.parse(jsonMatch[0]);
                        } else {
                             console.warn("AI did not return valid JSON for title/category.", resultText);
                             parsedResult = { title: null, list_id: null }; // Fallback
                        }
                    } catch (jsonError) {
                        console.error('Error parsing title/category JSON:', jsonError, resultText);
                        parsedResult = { title: null, list_id: null }; // Fallback
                    }

                    // Validate and sanitize list_id (should be string 'null' or a number)
                    let listId = parsedResult.list_id;
                    if (listId === 'null' || listId === null) {
                        listId = null;
                    } else if (typeof listId === 'string' && !isNaN(parseInt(listId))) {
                         listId = parseInt(listId); // Convert numeric string ID to number if needed by DB logic
                    } else if (typeof listId !== 'number') {
                         console.warn(`Received unexpected list_id type: ${typeof listId}, value: ${listId}. Defaulting to null.`);
                         listId = null; // Default to null if invalid type/value
                    }
                    console.log("parsedResult", parsedResult);
                    console.log("got listId", listId);


                    return {
                        generatedTitle: parsedResult.title || null,
                        listId: listId
                    };

                } catch (error) {
                    console.error('Error generating title and category:', error);
                    showToast(`AI title/category generation failed: ${error.message}`, 4000);
                    return { generatedTitle: null, listId: null }; // Return nulls on error
                }
            }
            
            // Return public API
            return {
                init
            };
        })();
        
        // Initialize the app when DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            EbookApp.init();
        });

        // Calculate overall reading progress for a book
        function calculateOverallProgress(book) {
            if (!book.last_position) return 0;
            
            // If we have chapters, calculate based on chapter position and chapter progress
            if (book.metadata && book.metadata.chapters && book.metadata.chapters.length > 0) {
                const chaptersLength = book.metadata.chapters.length;
                const currentChapter = book.last_position.chapter || 0;
                const chapterProgress = book.last_position.percentComplete || 0;
                
                // Same formula as in updateProgressBar
                const chaptersProgress = currentChapter / Math.max(1, chaptersLength - 1);
                const weightedChapterProgress = chapterProgress / chaptersLength;
                return Math.round((chaptersProgress + weightedChapterProgress) * 100);
            }
            
            // If we don't have chapters, just use the percentComplete
            return Math.round((book.last_position.percentComplete || 0) * 100);
        }
    </script>
</body>
</html>
