<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Ebook Reader</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* CSS styles remain exactly the same as provided in the prompt */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --light-bg: #f8f8f8;
            --light-text: #333;
            --light-panel-bg: #fff;
            --light-border: #eee;
            --light-panel-shadow: rgba(0, 0, 0, 0.08);
            --light-highlight: rgba(66, 133, 244, 0.3);

            --sepia-bg: #f8f1e3;
            --sepia-text: #5f4b32;
            --sepia-panel-bg: #f7f0e0;
            --sepia-border: rgba(95, 75, 50, 0.15);
            --sepia-panel-shadow: rgba(95, 75, 50, 0.1);
            --sepia-highlight: rgba(210, 180, 140, 0.3);

            --dark-bg: #222;
            --dark-text: #e0e0e0;
            --dark-panel-bg: #333;
            --dark-border: #444;
            --dark-panel-shadow: rgba(0, 0, 0, 0.2);
            --dark-highlight: rgba(66, 133, 244, 0.4);

            --primary-color: #4285f4;
            --success-color: #34a853;
            --danger-color: #d93025;
            --panel-radius: 12px;

            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
            --reader-line-height: 1.6; /* Default line height */
        }

        body.light-theme {
            --bg-color: var(--light-bg);
            --text-color: var(--light-text);
            --panel-bg: var(--light-panel-bg);
            --border-color: var(--light-border);
            --panel-shadow: var(--light-panel-shadow);
            --highlight-color: var(--light-highlight);
            --input-bg: rgba(0, 0, 0, 0.05);
            --select-bg: rgba(0, 0, 0, 0.05);
            --modal-backdrop-color: rgba(0, 0, 0, 0.4);
            --text-muted: #666;
        }

        body.sepia-theme {
            --bg-color: var(--sepia-bg);
            --text-color: var(--sepia-text);
            --panel-bg: var(--sepia-panel-bg);
            --border-color: var(--sepia-border);
            --panel-shadow: var(--sepia-panel-shadow);
            --highlight-color: var(--sepia-highlight);
            --input-bg: rgba(95, 75, 50, 0.05);
            --select-bg: rgba(95, 75, 50, 0.05);
            --modal-backdrop-color: rgba(95, 75, 50, 0.4);
            --text-muted: #8c7a64;
        }

        body.dark-theme {
            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
            --input-bg: rgba(255, 255, 255, 0.05);
            --select-bg: rgba(255, 255, 255, 0.05);
            --modal-backdrop-color: rgba(0, 0, 0, 0.6);
            --text-muted: rgba(224, 224, 224, 0.7);
        }

        .hidden {
            display: none !important;
        }

        #ai-response-area {
            display: none;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        ::selection {
            background-color: var(--highlight-color);
        }

        html {
            font-size: 16px;
        }

        @media (max-width: 768px) {
            html {
                font-size: 14px;
            }
        }

        #app {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
        }

        #welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Changed from center to start */
            background-color: var(--bg-color);
            z-index: 100;
            padding: 3vh 1rem 1rem; /* Reduced top padding, added bottom */
            overflow-y: auto;
        }

        #welcome-screen h1 {
            margin-bottom: 1.5rem;
            text-align: center;
            font-size: 2.2rem;
        }

        .welcome-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align items to the top */
            width: 100%;
            max-width: 650px; /* Slightly wider */
            padding: 1rem;
            flex-grow: 1; /* Allow content to take space */
            display: flex; /* Ensure flex properties apply */
            flex-direction: column; /* Stack children vertically */
        }

        .welcome-actions {
            display: flex;
            flex-direction: column;
            gap: 1.5rem; /* Adjusted gap */
            margin-top: 1rem; /* Reduced top margin */
            width: 100%;
            align-items: center;
        }

        .main-actions {
             display: flex;
             gap: 1rem;
             justify-content: center;
             flex-wrap: wrap;
             width: 100%;
        }

        #library-section {
            width: 100%;
            max-width: 600px;
            margin-top: 2.5rem;
            background-color: var(--panel-bg);
            border-radius: 8px;
            /* Removed fixed height, let flexbox handle it */
            box-shadow: 0 2px 8px var(--panel-shadow);
            display: flex; /* Keep flex */
            flex-direction: column;
            overflow: hidden;
        }

        #list-management {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            gap: 1rem;
            flex-wrap: wrap;
        }

        #list-filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #list-filter {
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.9rem;
        }

        #create-list-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        #new-list-name {
            display: none;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.9rem;
            flex: 1;
            margin-right: 0.5rem;
        }

        #create-list-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            min-width: 40px;
            height: 34px;
            line-height: 1;
            text-align: center;
        }

        #list-controls-wrapper {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            flex-shrink: 0;
            padding: 1.25rem 1.25rem 0.5rem;
        }

        #list-badge-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            flex-grow: 1;
        }

        .list-badge {
            padding: 0.3rem 0.8rem;
            border-radius: 12px;
            font-size: 0.85rem;
            cursor: pointer;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            white-space: nowrap;
        }

        .list-badge:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .list-badge.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            font-weight: 500;
        }

        .list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.2); border-color: rgba(52, 168, 83, 0.4); color: #6fbf73; }
        .list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.2); border-color: rgba(251, 188, 5, 0.4); color: #fdd663; }
        .list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.2); border-color: rgba(234, 67, 53, 0.4); color: #f28b82; }
        .list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.2); border-color: rgba(66, 133, 244, 0.4); color: #8ab4f8; }
        .list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.2); border-color: rgba(156, 39, 176, 0.4); color: #c58af9; }

        body.light-theme .list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.1); border-color: rgba(52, 168, 83, 0.2); color: #0d652d; }
        body.light-theme .list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.1); border-color: rgba(251, 188, 5, 0.2); color: #995200; }
        body.light-theme .list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.1); border-color: rgba(234, 67, 53, 0.2); color: #940a0a; }
        body.light-theme .list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.1); border-color: rgba(66, 133, 244, 0.2); color: #0b57d0; }
        body.light-theme .list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.1); border-color: rgba(156, 39, 176, 0.2); color: #58117a; }

        .list-badge.active[data-color-index="0"],
        .list-badge.active[data-color-index="1"],
        .list-badge.active[data-color-index="2"],
        .list-badge.active[data-color-index="3"],
        .list-badge.active[data-color-index="4"] {
             background-color: var(--primary-color);
             border-color: var(--primary-color);
             color: white;
        }

        #create-list-group {
            flex-shrink: 0;
        }

        #new-list-name {
            width: 150px;
        }

        #create-list-btn {
        }

        #ai-cleanup-btn {
            padding: 0.4rem;
            font-size: 1.1rem;
            min-width: 34px;
            width: 34px;
            height: 34px;
            line-height: 1;
            margin-left: 0.5rem;
        }

        #library-list {
            flex: 1 1 auto;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            padding: 0 1.25rem 1.25rem;
            min-height: 0;
            position: relative;
            max-height: calc(100% - 50px);
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }

        #library-list::-webkit-scrollbar {
            width: 8px;
        }

        #library-list::-webkit-scrollbar-track {
            background: transparent;
        }

        #library-list::-webkit-scrollbar-thumb {
            background-color: rgba(155, 155, 155, 0.5);
            border-radius: 4px;
            border: 2px solid transparent;
        }

        #library-list::-webkit-scrollbar-thumb:hover {
            background-color: rgba(155, 155, 155, 0.8);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .input-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .input-field,
        .select-field {
            flex: 1;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            font-size: 1rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Added transition */
        }

        .input-field:focus,
        .select-field:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color), 0.2); /* Added focus ring */
        }

        #text-input {
            width: 100%;
            min-height: 120px;
            margin-bottom: 0;
        }

        #toggle-text-input-container {
            text-align: center;
            margin-top: 0.5rem;
        }

        #toggle-text-input {
            font-size: 0.9rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        #toggle-text-input:hover {
            text-decoration: underline;
        }

        #text-input-container {
            width: 100%;
        }

        .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1rem; /* Slightly increased padding */
            margin-bottom: 0.6rem; /* Increased gap */
            background-color: transparent; /* Transparent background */
            border: 1px solid var(--border-color); /* Subtle border */
            border-radius: 6px; /* Slightly larger radius */
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .library-item:hover {
            background-color: rgba(255, 255, 255, 0.05); /* Adjusted hover */
            border-color: rgba(255, 255, 255, 0.15); /* Highlight border on hover */
        }

        .library-item-details {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }

        .library-item-title {
            display: inline;
            font-weight: 500;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        .library-item-list-badge {
            font-size: 0.65rem;
            padding: 0.1rem 0.4rem;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            margin-left: 0.5rem;
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }
        .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.15); border: 1px solid rgba(52, 168, 83, 0.3); color: #6fbf73; }
        .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.15); border: 1px solid rgba(251, 188, 5, 0.3); color: #fdd663; }
        .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.15); border: 1px solid rgba(234, 67, 53, 0.3); color: #f28b82; }
        .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.15); border: 1px solid rgba(66, 133, 244, 0.3); color: #8ab4f8; }
        .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.15); border: 1px solid rgba(156, 39, 176, 0.3); color: #c58af9; }

        body.light-theme .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.1); border-color: rgba(52, 168, 83, 0.2); color: #0d652d; }
        body.light-theme .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.1); border-color: rgba(251, 188, 5, 0.2); color: #995200; }
        body.light-theme .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.1); border-color: rgba(234, 67, 53, 0.2); color: #940a0a; }
        body.light-theme .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.1); border-color: rgba(66, 133, 244, 0.2); color: #0b57d0; }
        body.light-theme .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.1); border-color: rgba(156, 39, 176, 0.2); color: #58117a; }

        .library-item-title-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .library-item-list-badge {
            font-size: 0.65rem;
            padding: 0.1rem 0.4rem;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            margin-left: 0.5rem;
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }
        .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.15); border: 1px solid rgba(52, 168, 83, 0.3); color: #6fbf73; }
        .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.15); border: 1px solid rgba(251, 188, 5, 0.3); color: #fdd663; }
        .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.15); border: 1px solid rgba(234, 67, 53, 0.3); color: #f28b82; }
        .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.15); border: 1px solid rgba(66, 133, 244, 0.3); color: #8ab4f8; }
        .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.15); border: 1px solid rgba(156, 39, 176, 0.3); color: #c58af9; }

        body.light-theme .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.1); border-color: rgba(52, 168, 83, 0.2); color: #0d652d; }
        body.light-theme .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.1); border-color: rgba(251, 188, 5, 0.2); color: #995200; }
        body.light-theme .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.1); border-color: rgba(234, 67, 53, 0.2); color: #940a0a; }
        body.light-theme .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.1); border-color: rgba(66, 133, 244, 0.2); color: #0b57d0; }
        body.light-theme .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.1); border-color: rgba(156, 39, 176, 0.2); color: #58117a; }

        .library-item-title-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .library-item-meta {
            font-size: 0.75rem;
            color: rgba(var(--text-color), 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .library-item-move {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            margin-right: 0.5rem;
            transition: background-color 0.2s;
        }
        .library-item-move:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .move-list-dropdown {
            position: absolute;
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 2px 8px var(--panel-shadow);
            z-index: 10;
            min-width: 150px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            margin-top: 2px;
            right: 0;
        }

        .move-list-dropdown.visible {
            display: block;
        }

        .move-list-option {
            padding: 0.5rem 0.8rem;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-bottom: 1px solid var(--border-color);
        }
        .move-list-option:last-child {
            border-bottom: none;
        }

        .move-list-option:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .move-list-option.disabled {
            color: var(--text-muted);
            cursor: default;
            background-color: transparent;
        }


        .progress-bar-container {
            height: 4px;
            background-color: rgba(var(--text-color), 0.1);
            border-radius: 2px;
            margin-top: 0.3rem;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .library-item-actions {
            display: flex;
            gap: 0.5rem;
            margin-left: 0.5rem;
            flex-shrink: 0;
        }

        .library-item-delete {
            color: var(--danger-color);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.125rem;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
        }

        .library-item-delete:hover {
            background-color: rgba(217, 48, 37, 0.1);
        }

        .auth-section {
            margin-top: 1.875rem;
            text-align: center;
        }

        .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px; /* Slightly larger radius */
            padding: 0.8rem 1.6rem; /* Increased padding */
            font-size: 1rem;
            font-weight: 500; /* Slightly bolder text */
            cursor: pointer;
            box-shadow: 0 1px 3px var(--panel-shadow); /* Softer shadow */
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
        }

        .button:hover {
            background-color: #3367d6;
            box-shadow: 0 2px 6px var(--panel-shadow); /* Enhance shadow on hover */
        }

        .button:active {
            transform: translateY(1px);
        }

        .button-secondary {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            box-shadow: none;
        }

        .button-secondary:hover {
            background-color: rgba(66, 133, 244, 0.1); /* Light primary color background */
            border-color: #3367d6; /* Darker primary on hover */
            box-shadow: none;
        }

        body.light-theme .button-secondary {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }
        body.light-theme .button-secondary:hover {
            background-color: rgba(66, 133, 244, 0.05);
            border-color: #0b57d0;
        }

        .button.loading {
            position: relative;
            color: transparent !important;
            pointer-events: none;
        }

        .button.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1rem;
            height: 1rem;
            margin-top: -0.5rem;
            margin-left: -0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: button-spin 0.8s linear infinite;
        }

        @keyframes button-spin {
            to { transform: rotate(360deg); }
        }

        .success-button {
            background-color: var(--success-color);
        }

        .success-button:hover {
            background-color: #2e9549;
        }

        .example-book-section {
            margin-top: 1.875rem;
            text-align: center;
            padding: 1.25rem;
            background-color: rgba(66, 133, 244, 0.1);
            border-radius: 8px;
            margin-bottom: 1.25rem;
        }

        .example-book-section p {
            margin-bottom: 0.75rem;
        }

        #navbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3.5rem;
            background-color: var(--panel-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            z-index: 20;
        }

        #navbar.visible {
            transform: translateY(0);
        }

        #book-title {
            font-size: 1.125rem;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 40%;
        }

        #navbar-buttons {
            display: flex;
            gap: 1rem;
        }

        .navbar-btn {
            background-color: transparent;
            border: none;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
            font-size: 1.25rem;
            transition: background-color 0.2s;
        }

        .navbar-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #reader-container {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #content-area {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
            padding-top: 2rem; /* Ensure space below navbar */
            padding-bottom: 4rem; /* Ensure space above nav controls */
            -webkit-overflow-scrolling: touch;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
            transition: background-color 0.3s ease, color 0.3s ease;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: var(--reader-line-height); /* Apply reader line height */
            font-size: calc(1rem * var(--settings-font-size, 1)); /* Apply font size */
            font-family: inherit; /* Ensure reader font applies */
            word-wrap: break-word; /* Ensure long words break */
            position: relative; /* Needed for text anchor calculations */
        }

        #content-area img {
            max-width: 100%;
            height: auto;
            display: block; /* Optional: ensures block-level behavior */
            margin: 1rem auto; /* Optional: centers images and adds space */
            border-radius: 4px; /* Slightly rounded corners for images */
        }

        /* Base paragraph style */
        #content-area p {
            margin-bottom: 1rem;
            /* line-height is inherited from #content-area */
        }

        /* Markdown Content Styling (applies to manually generated HTML) */
        #content-area h1,
        #content-area h2,
        #content-area h3,
        #content-area h4,
        #content-area h5,
        #content-area h6 {
            font-weight: 600; /* Less bold than default */
            margin-top: 1.5rem;
            margin-bottom: 0.5rem; /* Less space after headings */
            line-height: 1.4; /* Specific line height for headings */
            padding-bottom: 0.2em; /* Optional: space below heading text */
            border-bottom: 1px solid var(--border-color); /* Subtle separator */
        }

        #content-area h1 { font-size: 1.3em; border-bottom-width: 2px; }
        #content-area h2 { font-size: 1.2em; }
        #content-area h3 { font-size: 1.1em; border-bottom: none;}
        #content-area h4, #content-area h5, #content-area h6 { font-size: 1em; border-bottom: none; }

        #content-area ul,
        #content-area ol {
            margin-bottom: 1rem;
            padding-left: 1.5em; /* Standard indent */
        }

        #content-area li {
            margin-bottom: 0.5rem; /* Space between list items */
        }
        #content-area li > p { /* No extra margin for paragraphs directly inside list items */
             margin-bottom: 0;
        }
        #content-area li > ul,
        #content-area li > ol { /* Indentation for nested lists */
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        #content-area blockquote {
            margin-left: 1em;
            margin-right: 1em;
            margin-bottom: 1rem;
            padding: 0.5em 1em;
            border-left: 3px solid var(--primary-color); /* Highlight with primary color */
            background-color: rgba(255, 255, 255, 0.03); /* Subtle background */
            color: var(--text-muted, rgba(224, 224, 224, 0.8)); /* Muted color for quotes */
            font-style: italic;
        }
        body.light-theme #content-area blockquote { background-color: rgba(0, 0, 0, 0.03); color: var(--text-muted, #555); }
        body.sepia-theme #content-area blockquote { background-color: rgba(95, 75, 50, 0.04); color: var(--text-muted, #7a6853); }

         #content-area blockquote p { /* Paragraphs inside blockquotes */
              margin-bottom: 0.5rem;
         }
         #content-area blockquote p:last-child {
              margin-bottom: 0;
         }

        #content-area code {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em; /* Slightly smaller */
        }
        body.light-theme #content-area code { background-color: rgba(0, 0, 0, 0.05); }
        body.sepia-theme #content-area code { background-color: rgba(95, 75, 50, 0.08); }


        #content-area pre {
            background-color: rgba(0, 0, 0, 0.2); /* Darker background for code blocks */
            padding: 0.8em 1em;
            border-radius: 4px;
            overflow-x: auto;
            margin-bottom: 1rem;
            font-family: monospace;
            line-height: 1.4; /* Specific line height for code blocks */
            border: 1px solid var(--border-color); /* Add border */
        }
        body.light-theme #content-area pre { background-color: rgba(0, 0, 0, 0.03); border: 1px solid #ddd; }
        body.sepia-theme #content-area pre { background-color: rgba(95, 75, 50, 0.05); border: 1px solid rgba(95, 75, 50, 0.1); }


        #content-area pre code {
            background-color: transparent;
            padding: 0;
            font-size: inherit; /* Inherit pre's font size */
            border: none;
        }

        #content-area hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 1.5rem 0;
        }
        /* End Markdown Content Styling */

        #settings-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--panel-bg);
            padding: 1.5rem; /* Increased padding */
            border-top-left-radius: var(--panel-radius);
            border-top-right-radius: var(--panel-radius);
            box-shadow: 0 -2px 10px var(--panel-shadow);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 30;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.25rem;
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-grid > .settings-section {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        #settings-panel > .settings-grid:last-of-type {
             border-bottom: none;
        }
         #settings-panel > .settings-section:last-child {
             border-bottom: none;
             margin-bottom: 0;
             padding-bottom: 0;
         }


        #settings-panel.visible {
            transform: translateY(0);
        }

        .settings-section {
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .settings-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
        }

        #ai-settings-content {
            margin-bottom: 1rem;
        }

        .settings-row.ai-toggle {
            margin-top: 0.75rem;
        }

        #ai-response-area {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            padding: 0.75rem;
            margin-top: 0.75rem;
            font-size: 0.875rem;
            max-height: 12.5rem;
            overflow-y: auto;
            border: 1px solid var(--border-color); /* Add border */
        }
         /* AI Response Area Markdown styles */
        #ai-response-area p { margin-bottom: 0.5rem; }
        #ai-response-area ul, #ai-response-area ol { padding-left: 1.2em; margin-bottom: 0.5rem; }
        #ai-response-area li { margin-bottom: 0.25rem; }
        #ai-response-area strong { font-weight: bold; }
        #ai-response-area em { font-style: italic; }


        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .font-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
        }

        .theme-options {
            display: flex;
            gap: 1rem;
        }

        .theme-option {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .theme-option.active {
            border-color: var(--primary-color);
        }

        .light-option {
            background-color: var(--light-bg);
            border: 1px solid var(--light-border);
        }

        .sepia-option {
            background-color: var(--sepia-bg);
        }

        .dark-option {
            background-color: var(--dark-bg);
        }

        #nav-controls {
            position: fixed;
            bottom: 1.25rem;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 1.25rem;
            pointer-events: none;
            z-index: 15;
        }

        .nav-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background-color: var(--panel-bg);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transition: background-color 0.2s;
        }

        .nav-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #toc-panel {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 80%;
            max-width: 20rem;
            background-color: var(--panel-bg);
            z-index: 30;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px var(--panel-shadow);
        }

        #toc-panel.visible {
            transform: translateX(0);
        }

        #toc-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #toc-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem; /* Increased horizontal padding */
        }

        .toc-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .toc-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .toc-item.toc-active {
            font-weight: bold;
            background-color: rgba(var(--primary-color), 0.1);
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.4);
            z-index: 25;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #overlay.visible {
            display: block;
            opacity: 1;
        }

        #progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background-color: var(--primary-color);
            transition: width 0.2s ease;
            z-index: 10;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #loading.visible {
            display: flex;
            opacity: 1;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-left-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #translation-popup {
            position: fixed;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            padding: 16px;
            min-width: 220px;
            max-width: 320px;
            z-index: 100;
            display: none;
            border: 1px solid rgba(0,0,0,0.08);
            transform: translateY(10px);
            opacity: 0;
            transition: transform 0.2s ease, opacity 0.2s ease;
            font-style: italic;
            color: #4285f4;
        }

        #translation-popup.visible {
            transform: translateY(0);
            opacity: 1;
        }

        body.light-theme #translation-popup {
            background-color: #ffffff;
            color: #4285f4;
        }

        body.sepia-theme #translation-popup {
            background-color: #f7f0e0;
            color: #4285f4;
            border-color: rgba(95, 75, 50, 0.15);
        }

        body.dark-theme #translation-popup {
            background-color: #2d2d2d;
            color: #4285f4;
            border-color: rgba(255,255,255,0.1);
        }

        #translation-popup:before {
            content: '';
            position: absolute;
            top: -8px;
            left: 20px;
            width: 14px;
            height: 14px;
            background-color: inherit;
            border-top: 1px solid rgba(0,0,0,0.08);
            border-left: 1px solid rgba(0,0,0,0.08);
            transform: rotate(45deg);
        }

        body.dark-theme #translation-popup:before {
            border-color: rgba(255,255,255,0.1);
        }

        body.sepia-theme #translation-popup:before {
            border-color: rgba(95, 75, 50, 0.15);
        }

        #translation-content {
            margin-bottom: 10px;
            font-size: 15px;
            line-height: 1.5;
        }

        #translation-loading {
            display: none;
            align-items: center;
            justify-content: center;
            height: 30px;
        }

        #translation-loading .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-left-color: #4285f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        body.dark-theme #translation-loading .spinner {
            border-color: rgba(255,255,255,0.1);
            border-left-color: #4285f4;
        }

        .flashcard-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            padding: 8px 12px;
            width: 240px;
            z-index: 1000;
            font-size: 14px;
            opacity: 1;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        body.dark-theme .flashcard-toast {
            background-color: #333;
            color: #e0e0e0;
        }

        .flashcard-toast.visible {
            display: block;
        }

        .flashcard-toast.fade-out {
            opacity: 0;
            transform: translateY(10px);
        }

        .flashcard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .flashcard-close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #888;
            padding: 0;
            margin: 0;
        }

        .flashcard-word {
            font-weight: bold;
            font-size: 16px;
        }

        .flashcard-translation {
            margin-bottom: 8px;
            line-height: 1.3;
            font-size: 13px;
        }

        .flashcard-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .flashcard-speak-btn {
            background-color: #34a853;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 0 0 auto;
        }

        .flashcard-save-btn {
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 1;
        }

        .flashcard-save-btn:disabled {
            background-color: #a4c2f4;
        }

        .button.icon-btn {
            padding: 0; /* Remove padding */
            width: 2.5rem; /* Make it square */
            height: 2.5rem; /* Make it square */
            font-size: 1.5rem; /* Adjust icon size */
            line-height: 2.5rem; /* Center icon vertically */
            text-align: center; /* Center icon horizontally */
            flex-shrink: 0; /* Prevent shrinking */
        }

        #url-input-container {
            width: 50%; /* Take full width of parent */
            max-width: 550px; /* Limit maximum width */
            margin-left: auto; /* Center within parent */
            margin-right: auto; /* Center within parent */
        }

        @media (max-width: 768px) {
            #toc-panel {
                width: 100%;
                max-width: none;
            }

            .welcome-buttons {
                flex-direction: column;
                width: 100%;
            }

            .welcome-buttons .button {
                width: 100%;
                text-align: center;
            }

            #book-title {
                max-width: 60%;
            }

            #navbar-buttons {
                gap: 0.5rem;
            }

            .flashcard-toast {
                left: 1.25rem;
                right: 1.25rem;
                width: auto;
            }

            #chat-panel {
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                max-width: none;
                max-height: none;
                border-radius: 0;
                transform: translate(0, 0) scale(1);
                border: none;
            }

            #chat-panel:not(.visible) {
                 transform: translateY(100%);
                 opacity: 0;
            }
            #chat-panel.visible {
                 transform: translateY(0);
                 opacity: 1;
            }

        }

        button, input[type="checkbox"] {
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        #content-area a {
            text-decoration: underline;
            font-style: italic;
            color: var(--primary-color);
            cursor: pointer;
        }

        #content-area a:hover {
            color: #3367d6;
        }
        #toast {
            position: fixed;
            bottom: 1.25rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: var(--panel-bg);
            color: var(--text-color);
            padding: 0.75rem 1.25rem;
            border-radius: 4px;
            box-shadow: 0 4px 12px var(--panel-shadow);
            z-index: 1000;
            transition: transform 0.3s ease;
            text-align: center;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
        }

        .link-action-toast {
            position: fixed;
            bottom: 1.25rem;
            left: 50%;
            transform: translateX(-50%) translateY(150px);
            background-color: var(--panel-bg);
            color: var(--text-color);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--panel-shadow);
            z-index: 1001;
            transition: transform 0.3s ease;
            width: 90%;
            max-width: 400px;
            text-align: left;
        }

        .link-action-toast.visible {
            transform: translateX(-50%) translateY(0);
        }

        .link-action-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .link-action-close-btn {
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            line-height: 1;
        }

        .link-action-url {
            font-size: 0.9rem;
            margin-bottom: 1rem;
            word-break: break-word;
        }

        .link-action-target-url {
            font-size: 0.8rem;
            margin-bottom: 1rem;
            word-break: break-all;
            color: var(--text-muted);
            max-height: 4.8em;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .link-action-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .link-action-btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: transparent;
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .link-action-btn.scrape {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .link-action-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .link-action-btn.scrape:hover {
            background-color: #3367d6;
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--modal-backdrop-color);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal-backdrop.visible {
            display: block;
            opacity: 1;
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background-color: var(--panel-bg);
            color: var(--text-color);
            border-radius: var(--panel-radius);
            box-shadow: 0 8px 25px var(--panel-shadow);
            z-index: 1000;
            display: none;
            flex-direction: column;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .modal.visible {
            display: flex;
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .modal-header {
            padding: 0.8rem 1.2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.3rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.2rem;
            line-height: 1;
        }

        .modal-body {
            padding: 1rem 1.2rem;
            overflow-y: auto;
            flex-grow: 1;
            font-size: 0.9rem;
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }
        .modal-body::-webkit-scrollbar { width: 6px; }
        .modal-body::-webkit-scrollbar-track { background: transparent; }
        .modal-body::-webkit-scrollbar-thumb { background-color: rgba(155, 155, 155, 0.5); border-radius: 3px; }

        .modal-body p {
            margin-bottom: 1rem;
            color: var(--text-muted);
        }

        .cleanup-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        .cleanup-item:last-child {
            border-bottom: none;
        }

        .cleanup-item input[type="checkbox"] {
            margin-right: 0.8rem;
            flex-shrink: 0;
            width: 18px;
            height: 18px;
        }

        .cleanup-item-details {
            flex-grow: 1;
            min-width: 0;
        }

        .cleanup-item-title {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 0.1rem;
        }

        .cleanup-item-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .modal-footer {
            padding: 0.8rem 1.2rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            flex-shrink: 0;
        }

        .modal-footer .button {
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
        }

        .modal-footer .button.danger {
            background-color: var(--danger-color);
        }
        .modal-footer .button.danger:hover {
            background-color: #c5221f;
        }

        .line-height-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        #source-url-display {
            display: none;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        #source-url-content-link {
            word-break: break-all;
            color: var(--primary-color);
            text-decoration: none;
        }
        #source-url-content-link:hover {
            text-decoration: underline;
        }

        #api-status-container {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .api-status-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.4rem;
        }

        .api-status-item .status-icon {
            margin-right: 0.5rem;
            font-size: 1rem;
        }

        .api-status-item .status-text a {
            color: var(--primary-color);
            text-decoration: underline;
        }
        .panel {
            position: fixed;
            background-color: var(--panel-bg);
            color: var(--text-color);
            border-radius: var(--panel-radius);
            box-shadow: 0 5px 20px var(--panel-shadow);
            z-index: 1001;
            display: none;
            flex-direction: column;
            border: 1px solid var(--border-color);
        }

        .settings-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 18px 25px;
            padding: 20px;
            max-height: 75vh;
            overflow-y: auto;
            align-items: start;
        }

        .settings-content > .settings-divider,
        .settings-content > .ai-features-section,
        .settings-content > .api-status-section {
            grid-column: 1 / -1;
            margin-top: 0;
            margin-bottom: 0;
        }
        .settings-content > .settings-divider {
            margin-top: 3px;
            margin-bottom: 3px;
        }


        .settings-section {
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-section > label {
            display: block;
            margin-bottom: 0px;
            font-weight: bold;
            color: var(--text-color);
            font-size: 0.95em;
        }

        .setting-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-control.font-size-control,
        .setting-control.line-height-control {
            justify-content: space-between;
        }

        .setting-control.font-size-control span,
        .setting-control.line-height-control span {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            flex-grow: 1;
        }

        .theme-control {
            justify-content: flex-start;
            gap: 10px;
        }

        .theme-option {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: border-color 0.3s ease, transform 0.2s ease;
        }
        .theme-option:hover {
            transform: scale(1.1);
        }
        .theme-option.active {
             border-color: var(--primary-color);
             border-width: 3px;
        }
        .theme-option[data-theme="light"] { background-color: var(--light-panel-bg); }
        .theme-option[data-theme="sepia"] { background-color: var(--sepia-panel-bg); }
        .theme-option[data-theme="dark"] { background-color: var(--dark-panel-bg); }


        .setting-control.checkbox-control {
            justify-content: space-between;
            width: 100%;
            padding: 1px 0;
        }

        .setting-control.checkbox-control label {
            margin-bottom: 0;
            font-weight: normal;
            flex-grow: 1;
            cursor: pointer;
        }

        .setting-control.checkbox-control input[type="checkbox"] {
            margin: 0;
            flex-shrink: 0;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }

        .settings-section:has(#markdownModeToggle) > label {
            margin-bottom: 5px;
        }
        .settings-section:has(#markdownModeToggle) .setting-control.checkbox-control {
        }

        .setting-control:has(#speechLanguageSelect) {
            justify-content: space-between;
            width: 100%;
            padding: 1px 0;
        }
        .setting-control:has(#speechLanguageSelect) label {
             margin-bottom: 0;
             font-weight: normal;
             flex-shrink: 0;
             cursor: default;
        }
        #speechLanguageSelect {
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            color: var(--text-color);
            max-width: 160px;
            font-size: 0.9em;
        }

        .api-status-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 5px;
        }

        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        .icon-btn {
            padding: 0;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
            font-size: 1.1em;
            flex-shrink: 0;
        }
        .icon-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-color);
        }
        .icon-btn:active {
            transform: scale(0.95);
        }

        #chat-panel {
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%) scale(0.9);
             width: 90%;
             max-width: 700px;
             height: 80vh;
             max-height: 700px;
             opacity: 0;
             transition: transform 0.3s ease, opacity 0.3s ease;
             overflow: hidden;
         }

        #chat-panel.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            display: flex;
        }

        #chat-header {
            padding: 0.6rem 1.1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .chat-header-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        #chat-header h3 {
            margin: 0;
            font-size: 1.1rem;
            flex-grow: 1;
        }

        .chat-clear-btn {
            font-size: 1rem;
            width: 28px;
            height: 28px;
        }

        .chat-context-toggle {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        #chat-messages {
            flex: 1 1 auto;
            overflow-y: auto;
            padding: 1rem 1.1rem;
            display: flex;
            flex-direction: column;
            gap: 0.85rem;
            min-height: 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }

        #chat-messages::-webkit-scrollbar { width: 6px; }
        #chat-messages::-webkit-scrollbar-track { background: transparent; }
        #chat-messages::-webkit-scrollbar-thumb { background-color: rgba(155, 155, 155, 0.5); border-radius: 3px; }

        .chat-message {
            padding: 0.6rem 0.9rem;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
            line-height: 1.5;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .chat-message.user {
            background-color: var(--primary-color);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 2px;
        }

        .chat-message.assistant {
            background-color: var(--panel-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            align-self: flex-start;
            border-bottom-left-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            max-width: 100%;
        }

        .chat-message.assistant a {
            color: var(--primary-color);
            text-decoration: underline;
        }
        .chat-message.assistant a:hover {
            color: #66a3ff;
        }

        .chat-message.assistant.loading::after {
            content: '...';
            display: inline-block;
            animation: loading-dots 1.5s infinite;
        }

        #chat-suggestions {
            display: none;
            padding: 0.25rem 0 0.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
            flex-shrink: 0;
        }

        .suggestion-chip {
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            cursor: pointer;
            border: 1px solid var(--border-color);
            background-color: rgba(255, 255, 255, 0.08);
            color: var(--text-muted);
            transition: background-color 0.2s, color 0.2s;
            white-space: nowrap;
        }

        .suggestion-chip:hover {
            background-color: rgba(255, 255, 255, 0.15);
            color: var(--text-color);
        }

        @keyframes loading-dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }


        #chat-input-area {
            flex-direction: column;
            display: flex;
            padding: 0.4rem 0.6rem;
            border-top: 1px solid var(--border-color);
            gap: 0.5rem;
            align-items: stretch;
            flex-shrink: 0;
        }

        .chat-input-row {
            display: flex;
            align-items: flex-end;
            gap: 0.5rem;
            width: 100%;
        }

        #chat-input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            font-size: 0.95rem;
            resize: none;
            line-height: 1.4;
            min-height: 36px;
            max-height: 80px;
            overflow-y: auto;
        }

        #chat-send-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.95rem;
            height: 36px;
            flex-shrink: 0;
        }

    </style>
</head>
<body class="dark-theme">
    <div id="app">
        <div id="welcome-screen">
            <div class="welcome-content">
                <h1>Enhanced Ebook Reader</h1>
                <p>Read from a URL, paste text, or open a local file.</p>

                <div class="welcome-actions">
                    <!-- URL Input First -->
                    <div class="input-group" id="url-input-container">
                        <div class="input-row">
                            <input id="url-input" type="url" placeholder="Enter a URL to read" class="input-field">
                            <button type="button" id="process-url-btn" class="button icon-btn" aria-label="Read URL">➔</button>
                        </div>
                    </div>

                    <!-- Text Input Section -->
                    <div id="toggle-text-input-container">
                        <a href="#" id="toggle-text-input">or paste text directly</a>
                    </div>
                    <div class="input-group" id="text-input-container" style="display: none;">
                        <textarea id="text-input" class="input-field" placeholder="Paste your text here..."></textarea>
                        <div class="input-row">
                            <input id="text-input-title" type="text" placeholder="Enter a title (optional)" class="input-field">
                            <button type="button" id="process-text-btn" class="button">Read Text</button>
                        </div>
                    </div>

                     <!-- Local File / Example Section -->
                     <div style="margin-top: 1.5rem; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 1rem;"> <!-- Increased margin-top slightly -->
                        <button type="button" id="open-file-btn" class="button button-secondary">Open Local File</button>
                        <div class="example-book-section" style="margin-top: 0.2rem; margin-bottom: 0;"> <!-- Further reduced top margin -->
                            <p style="margin-bottom: 0.5rem;">Don't have an ebook? Try our example:</p>
                            <a id="example-book-btn" class="button success-button" href="https://raw.githubusercontent.com/dat-lequoc/apps/refs/heads/main/ebooks/Kundera%2C%20Milan%20-%20The%20Unbearable%20Lightness%20of%20Being%20(2017%2C%20Faber%20and%20Faber)%20-%20libgen.li.epub" target="_blank" rel="noopener">Download Sample Book</a>
                        </div>
                    </div>

                    <!-- Sign In Button (if needed) -->
                    <div class="main-actions" style="margin-top: 1rem;">
                         <button type="button" id="login-btn" class="button hidden">Sign In</button>
                    </div>
                </div>

                <!-- Auth Status Moved Down -->
                <div class="auth-section" id="auth-section" style="margin-top: auto; padding-top: 1rem;"> <!-- Push to bottom -->
                    <p>Sign in to save books to your library.</p>
                </div>

                <div id="library-section" style="display: none;">
                    <div id="list-controls-wrapper">
                        <div id="list-badge-container">
                        </div>
                        <div id="create-list-group">
                            <input type="text" id="new-list-name" placeholder="New list name..." />
                            <button type="button" id="create-list-btn" class="button">+</button>
                            <button type="button" id="ai-cleanup-btn" class="button icon-btn" title="AI Library Cleanup" aria-label="AI Library Cleanup" style="display: none;">🧹</button>
                        </div>
                    </div>
                    <div id="library-list">
                    </div>
                </div>
            </div>
        </div>

        <div id="navbar">
            <div id="book-title">Ebook Title</div>
            <div id="navbar-buttons">
                <button type="button" class="navbar-btn" id="toc-btn" aria-label="Table of Contents">☰</button>
                <button type="button" class="navbar-btn" id="settings-btn" aria-label="Settings">⚙️</button>
                <button type="button" class="navbar-btn" id="chat-btn" aria-label="Chat">💬</button>
                <button type="button" class="navbar-btn" id="home-btn" aria-label="Home">⌂</button>
            </div>
        </div>

        <div id="reader-container">
            <div id="content-area">
                <div id="source-url-display" style="display: none; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); font-size: 0.9rem;">
                    Source: <a id="source-url-content-link" href="#" target="_blank" rel="noopener noreferrer" style="word-break: break-all; color: var(--primary-color);"></a>
                </div>
            </div>
            <div id="progress-bar"></div>
        </div>

        <div id="nav-controls">
            <button type="button" class="nav-btn" id="prev-btn" aria-label="Previous Chapter">←</button>
            <button type="button" class="nav-btn" id="next-btn" aria-label="Next Chapter">→</button>
        </div>

        <div id="toc-panel">
            <div id="toc-header">
                <h3>Table of Contents</h3>
                <button type="button" class="navbar-btn" id="close-toc-btn" aria-label="Close">✕</button>
            </div>
            <div id="toc-content"></div>
        </div>

        <div id="settings-panel">
            <div class="settings-grid">
                <div class="settings-section">
                    <div class="settings-title">Font Size</div>
                    <div class="font-size-controls">
                        <button type="button" class="font-btn" id="font-decrease-btn" aria-label="Decrease Font Size">A-</button>
                        <span id="font-size-value">100%</span>
                        <button type="button" class="font-btn" id="font-increase-btn" aria-label="Increase Font Size">A+</button>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="settings-title">Line Height</div>
                    <div class="line-height-controls">
                        <button type="button" class="font-btn" id="line-height-decrease-btn" aria-label="Decrease Line Height">-</button>
                        <span id="line-height-value">1.6</span>
                        <button type="button" class="font-btn" id="line-height-increase-btn" aria-label="Increase Line Height">+</button>
                    </div>
                </div>
            </div>

            <div class="settings-grid">
                <div class="settings-section">
                    <div class="settings-title">Theme</div>
                    <div class="theme-options">
                        <div class="theme-option light-option" data-theme="light" title="Light Theme"></div>
                        <div class="theme-option sepia-option" data-theme="sepia" title="Sepia Theme"></div>
                        <div class="theme-option dark-option active" data-theme="dark" title="Dark Theme"></div>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="settings-title">Content View</div>
                    <div class="settings-row">
                        <label for="view-raw-html-toggle">View Raw HTML (URLs/EPUBs)</label>
                        <input type="checkbox" id="view-raw-html-toggle">
                    </div>
                </div>
            </div>

            <div class="settings-section" id="ai-features-section">
                <div class="settings-title">AI Features</div>
                <div class="settings-row ai-toggle">
                    <label for="translation-toggle">Text Selection Translation</label>
                    <input type="checkbox" id="translation-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="auto-speak-toggle">Auto Speak Flashcard Words</label>
                    <input type="checkbox" id="auto-speak-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="speak-selection-toggle">Speak Full Selection (instead of just flashcard word)</label>
                    <input type="checkbox" id="speak-selection-toggle">
                </div>
                <div class="settings-row">
                    <label for="speech-language">Speech Language</label>
                    <select id="speech-language">
                        <option value="en-US">English</option>
                        <option value="fr-FR">French</option>
                    </select>
                </div>
                <div id="ai-settings-content">
                    <p>Loading API status...</p>
                </div>
                <button type="button" id="summarize-chapter-btn" class="button" style="margin-top: 0.75rem; display: none;">Summarize Chapter</button>
                <div id="ai-response-area" style="display: none; margin-top: 1rem; background-color: rgba(255, 255, 255, 0.05); border-radius: 4px; padding: 0.75rem; font-size: 0.875rem; max-height: 15rem; overflow-y: auto;"></div>
            </div>
        </div>

        <div id="chat-panel" class="panel">
            <div id="chat-header">
                <h3>Chat with AI</h3>
                <div class="chat-header-controls">
                    <button type="button" class="icon-btn chat-clear-btn" id="chat-clear-btn" aria-label="Clear Chat" title="Clear Chat History">🗑️</button>
                    <div class="chat-context-toggle">
                        <input type="checkbox" id="chat-full-doc-toggle" style="width: 16px; height: 16px; vertical-align: middle;" checked>
                        <label for="chat-full-doc-toggle" style="font-size: 0.85rem; vertical-align: middle; cursor: pointer;">Use Full Document</label>
                    </div>
                    <button type="button" class="navbar-btn" id="close-chat-btn" aria-label="Close">✕</button>
                </div>
            </div>
            <div id="chat-messages">
                <div class="chat-message assistant">Hello! Ask me anything about the full document <br> (or toggle 'Use Full Document' above to focus on the current chapter).</div>
            </div>
            <div id="chat-input-area">
                <div id="chat-suggestions">
                </div>
                <div class="chat-input-row">
                    <textarea id="chat-input" placeholder="Type your message..." rows="1"></textarea>
                    <button type="button" id="chat-send-btn" class="button">Send</button>
                </div>
            </div>
        </div>

        <div id="overlay"></div>

        <div id="loading">
            <div class="spinner"></div>
        </div>

        <div id="translation-popup">
            <div id="translation-content"></div>
            <div id="translation-loading">
                <div class="spinner"></div>
            </div>
        </div>

        <div id="toast"></div>

        <input type="file" id="file-input" accept=".txt,.epub,.pdf" style="display: none;">
    </div>

    <div id="ai-cleanup-backdrop" class="modal-backdrop"></div>
    <div id="ai-cleanup-modal" class="modal">
        <div class="modal-header">
            <h3>AI Cleanup Suggestions</h3>
            <button type="button" id="ai-cleanup-close-btn" class="modal-close-btn" aria-label="Close">×</button>
        </div>
        <div class="modal-body" id="ai-cleanup-list">
            <p>Loading suggestions...</p>
        </div>
        <div class="modal-footer">
            <button type="button" id="ai-cleanup-cancel-btn" class="button">Cancel</button>
            <button type="button" id="ai-cleanup-confirm-btn" class="button danger">Delete Selected</button>
        </div>
    </div>

    <script>
        // --- START: Manual Markdown Parser ---
        /**
         * Basic HTML escaping. Crucial to prevent XSS.
         */
        function escapeHTML(str) {
             if (!str) return '';
             return str.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;')
                       .replace(/'/g, '&#039;');
        }

        /**
         * Processes inline Markdown elements within a text block.
         * Assumes HTML has already been escaped.
         */
        function processInlineMarkdown(text) {
            if (!text) return '';

            // 1. Inline Code `code` (Handles already escaped HTML inside)
            text = text.replace(/`([^`]+)`/g, (match, code) => `<code>${code}</code>`);

            // 2. Images: ![alt text](url)
            text = text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, alt, src) =>
                `<img src="${escapeHTML(src)}" alt="${escapeHTML(alt)}">`
            );

            // 3. Links: [link text](url)
            text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, linkText, href) =>
                `<a href="${escapeHTML(href)}" target="_blank" rel="noopener noreferrer">${linkText}</a>`
            );

            // 4. Bold: **text** or __text__ (must be careful not to greedily match across lines if text spans lines - shouldn't happen with current block logic)
            text = text.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/__([^_]+)__/g, '<strong>$1</strong>');

            // 5. Italics: *text* or _text_ (must be careful not to greedily match or overlap bold)
            // Process italics after bold to avoid conflicts with __
            text = text.replace(/(?<!\*)\*([^\*]+)\*(?!\*)/g, '<em>$1</em>'); // Avoid **
            text = text.replace(/(?<!_)_([^_]+)_(?!_)/g, '<em>$1</em>'); // Avoid __

            // Optional: Handle simple line breaks within paragraphs if needed
            // text = text.replace(/(?<!\n)\n(?!\n)/g, '<br>\n'); // Replaces single newlines with <br>

            return text;
        }

        /**
         * Converts a Markdown string to basic HTML.
         * Focuses on common block elements and delegates inline processing.
         */
        function markdownToHtml(md) {
            if (!md) return '';

            // Normalize line endings and split into lines
            const lines = md.replace(/\r\n/g, '\n').split('\n');
            let html = '';
            let i = 0;
            let currentParagraph = ''; // Buffer for paragraph lines

            const closeParagraph = () => {
                if (currentParagraph) {
                    html += `<p>${processInlineMarkdown(currentParagraph.trim())}</p>\n`;
                    currentParagraph = '';
                }
            };

            while (i < lines.length) {
                const line = lines[i];

                // --- Code Blocks (```) ---
                if (line.trim().startsWith('```')) {
                    closeParagraph(); // End any open paragraph
                    let block = '';
                    let lang = line.trim().substring(3).trim();
                    i++;
                    while (i < lines.length && !lines[i].trim().startsWith('```')) {
                        block += lines[i] + '\n';
                        i++;
                    }
                    html += `<pre><code${lang ? ` class="language-${escapeHTML(lang)}"` : ''}>${escapeHTML(block.replace(/\n$/, ''))}</code></pre>\n`;
                    i++; // Skip closing ```
                    continue;
                }

                // --- Headings (#) ---
                const headingMatch = line.match(/^(#{1,6})\s+(.*)/);
                if (headingMatch) {
                    closeParagraph();
                    const level = headingMatch[1].length;
                    const headingText = headingMatch[2].trim();
                    html += `<h${level}>${processInlineMarkdown(headingText)}</h${level}>\n`;
                    i++;
                    continue;
                }

                // --- Horizontal Rules (---, ***, ___) ---
                 if (/^\s*([-*_])\s*\1\s*\1\s*$/.test(line.trim())) {
                     closeParagraph();
                     html += '<hr>\n';
                     i++;
                     continue;
                 }

                // --- Blockquotes (>) ---
                 if (line.trim().startsWith('>')) {
                     closeParagraph();
                     let block = '';
                     while (i < lines.length && lines[i].trim().startsWith('>')) {
                         // Remove '>' and optional space
                         block += lines[i].trim().replace(/^>\s?/, '') + '\n';
                         i++;
                     }
                     // Recursively process inner content for nested markdown (e.g., bold inside quote)
                     html += `<blockquote>${markdownToHtml(block.trim())}</blockquote>\n`; // Recursive call!
                     continue;
                 }

                 // --- Lists (UL/OL) ---
                 const ulMatch = line.match(/^(\s*)([*+-])\s+(.*)/);
                 const olMatch = line.match(/^(\s*)(\d+)\.\s+(.*)/);

                 if (ulMatch || olMatch) {
                    closeParagraph();
                    const listType = olMatch ? 'ol' : 'ul';
                    const startIndent = (ulMatch || olMatch)[1].length; // Indentation of the first item
                    let listHtml = '';

                    while (i < lines.length) {
                        const currentLine = lines[i];
                        const currentIndentMatch = currentLine.match(/^(\s*)/);
                        const currentIndent = currentIndentMatch ? currentIndentMatch[1].length : 0;

                        // Check if line is a valid list item for the current list type and indent level
                        const itemUlMatch = currentLine.match(/^(\s*)([*+-])\s+(.*)/);
                        const itemOlMatch = currentLine.match(/^(\s*)(\d+)\.\s+(.*)/);
                        const itemMatch = (listType === 'ul' && itemUlMatch) || (listType === 'ol' && itemOlMatch);

                        if (itemMatch && currentIndent >= startIndent) {
                            // TODO: Handle multi-line list items and nested lists (complex)
                            // Basic: Treat each line as a separate item for now
                            listHtml += `<li>${processInlineMarkdown(itemMatch[itemMatch.length-1])}</li>\n`;
                            i++;
                        } else if (currentLine.trim() === '' && i + 1 < lines.length) {
                            // Look ahead: if the next line is also part of the list, treat blank line as part of multi-line item (difficult)
                            // Simple approach: Blank line ends the list if next line isn't an item
                            const nextLine = lines[i+1];
                            const nextUlMatch = nextLine.match(/^(\s*)([*+-])\s+(.*)/);
                            const nextOlMatch = nextLine.match(/^(\s*)(\d+)\.\s+(.*)/);
                             if (!nextUlMatch && !nextOlMatch) {
                                 break; // End list
                             }
                             // Otherwise, potentially part of multi-line item - skip blank line for now
                             i++;
                        }
                         else {
                             // Line doesn't match list format or indent, end the list
                             break;
                         }
                    }
                    const startAttr = (listType === 'ol' && olMatch[2] !== '1') ? ` start="${olMatch[2]}"` : '';
                    html += `<${listType}${startAttr}>\n${listHtml}</${listType}>\n`;
                    continue; // Continue main loop after list processing
                 }


                // --- Paragraphs (Default) ---
                if (line.trim() !== '') {
                    // Add line to current paragraph buffer
                    currentParagraph += (currentParagraph ? '\n' : '') + line;
                } else {
                    // Blank line: End the current paragraph if one exists
                    closeParagraph();
                }
                i++; // Move to the next line
            }

            // Close any remaining paragraph at the end of the input
            closeParagraph();

            return html;
        }
        // --- END: Manual Markdown Parser ---


        const EbookApp = (function() {
            const supabaseUrl = 'https://iioxqphxakvhhtyvdhrh.supabase.co';
            const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpb3hxcGh4YWt2aGh0eXZkaHJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg4MzQ5MjAsImV4cCI6MjA1NDQxMDkyMH0.7I2CaBH1DyiRYEtzunIM5-l3GaWYT15Mly39jW-ga5Q';
            const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);

            const DOM = {
                app: document.getElementById('app'),
                welcomeScreen: document.getElementById('welcome-screen'),
                readerContainer: document.getElementById('reader-container'),
                contentArea: document.getElementById('content-area'),
                navbar: document.getElementById('navbar'),
                bookTitle: document.getElementById('book-title'),
                tocBtn: document.getElementById('toc-btn'),
                settingsBtn: document.getElementById('settings-btn'),
                homeBtn: document.getElementById('home-btn'),
                tocPanel: document.getElementById('toc-panel'),
                closeTocBtn: document.getElementById('close-toc-btn'),
                tocContent: document.getElementById('toc-content'),
                settingsPanel: document.getElementById('settings-panel'),
                overlay: document.getElementById('overlay'),
                fileInput: document.getElementById('file-input'),
                openFileBtn: document.getElementById('open-file-btn'),
                exampleBookBtn: document.getElementById('example-book-btn'),
                textInput: document.getElementById('text-input'),
                textInputTitle: document.getElementById('text-input-title'),
                processTextBtn: document.getElementById('process-text-btn'),
                toggleTextInput: document.getElementById('toggle-text-input'),
                textInputContainer: document.getElementById('text-input-container'),
                urlInputContainer: document.getElementById('url-input-container'),
                urlInput: document.getElementById('url-input'),
                processUrlBtn: document.getElementById('process-url-btn'),
                fontDecreaseBtn: document.getElementById('font-decrease-btn'),
                fontIncreaseBtn: document.getElementById('font-increase-btn'),
                fontSizeValue: document.getElementById('font-size-value'),
                lineHeightDecreaseBtn: document.getElementById('line-height-decrease-btn'),
                lineHeightIncreaseBtn: document.getElementById('line-height-increase-btn'),
                lineHeightValue: document.getElementById('line-height-value'),
                themeOptions: document.querySelectorAll('.theme-option'),
                progressBar: document.getElementById('progress-bar'),
                prevBtn: document.getElementById('prev-btn'),
                nextBtn: document.getElementById('next-btn'),
                loading: document.getElementById('loading'),
                toast: document.getElementById('toast'),
                loginBtn: document.getElementById('login-btn'),
                librarySection: document.getElementById('library-section'),
                authSection: document.getElementById('auth-section'),
                translationToggle: document.getElementById('translation-toggle'),
                autoSpeakToggle: document.getElementById('auto-speak-toggle'),
                speakSelectionToggle: document.getElementById('speak-selection-toggle'),
                speechLanguage: document.getElementById('speech-language'),
                translationPopup: document.getElementById('translation-popup'),
                translationContent: document.getElementById('translation-content'),
                translationLoading: document.getElementById('translation-loading'),
                viewRawHtmlToggle: document.getElementById('view-raw-html-toggle'),
                sourceUrlDisplay: document.getElementById('source-url-display'),
                sourceUrlContentLink: document.getElementById('source-url-content-link'),
                listBadgeContainer: document.getElementById('list-badge-container'),
                createListBtn: document.getElementById('create-list-btn'),
                newListNameInput: document.getElementById('new-list-name'),
                createListGroup: document.getElementById('create-list-group'),
                aiCleanupBtn: document.getElementById('ai-cleanup-btn'),
                aiCleanupModal: document.getElementById('ai-cleanup-modal'),
                aiCleanupBackdrop: document.getElementById('ai-cleanup-backdrop'),
                aiCleanupList: document.getElementById('ai-cleanup-list'),
                aiCleanupCloseBtn: document.getElementById('ai-cleanup-close-btn'),
                aiCleanupCancelBtn: document.getElementById('ai-cleanup-cancel-btn'),
                aiCleanupConfirmBtn: document.getElementById('ai-cleanup-confirm-btn'),
                chatBtn: document.getElementById('chat-btn'),
                chatPanel: document.getElementById('chat-panel'),
                closeChatBtn: document.getElementById('close-chat-btn'),
                chatMessages: document.getElementById('chat-messages'),
                chatInput: document.getElementById('chat-input'),
                chatSendBtn: document.getElementById('chat-send-btn'),
                chatClearBtn: document.getElementById('chat-clear-btn'),
                chatFullDocToggle: document.getElementById('chat-full-doc-toggle'),
                chatSuggestions: document.getElementById('chat-suggestions'),
                aiSettingsContent: document.getElementById('ai-settings-content'),
                summarizeChapterBtn: document.getElementById('summarize-chapter-btn'),
                aiResponseArea: document.getElementById('ai-response-area')
            };

            let state = {
                bookData: {
                    title: '',
                    content: '', // Older HTML content (fallback)
                    chapters: [],
                    currentPosition: 0,
                    sourceUrl: null,
                    rawContent: null, // Raw HTML from EPUB/URL
                    currentListId: null
                },
                settings: {
                    fontSize: 100,
                    lineHeight: 1.6,
                    theme: 'dark',
                    viewRawHtmlEnabled: false,
                    speakSelectionEnabled: false
                },
                session: null,
                userApiSettings: null,
                translationTimer: null,
                navbarHideTimer: null,
                debounceTimers: {},
                bookLists: [],
                selectedListId: 'all',
                isCreatingList: false,
                isAiCleanupModalOpen: false,
                lastSelectionRect: null,
                chatHistory: [],
                chatUseFullDocument: true,
                lastPosition: null
            };

            const initialSuggestedQuestions = [
                "Summarize this.",
                "Key points?",
                "Explain the main idea.",
            ];

            function init() {
                setupEventListeners();
                checkAuthAndLoadApiSettings();
                loadUserPreferences();
                // Set initial CSS variables based on settings
                updateCssVariables();
            }

             function updateCssVariables() {
                document.documentElement.style.setProperty('--reader-line-height', state.settings.lineHeight);
                // Font size is applied directly to contentArea, but could be a variable too
                // document.documentElement.style.setProperty('--settings-font-size', `${state.settings.fontSize / 100}`);
                DOM.contentArea.style.fontSize = `${state.settings.fontSize}%`;
            }

            function setupEventListeners() {
                DOM.openFileBtn.addEventListener('click', () => DOM.fileInput.click());
                DOM.fileInput.addEventListener('change', handleFileSelected);
                DOM.processTextBtn.addEventListener('click', processInputText);
                DOM.exampleBookBtn.addEventListener('click', downloadExampleBook);
                DOM.toggleTextInput.addEventListener('click', (e) => {
                    e.preventDefault();
                    DOM.textInputContainer.style.display = DOM.textInputContainer.style.display === 'none' ? 'block' : 'none';
                });
                DOM.processUrlBtn.addEventListener('click', processUrlInput);

                DOM.tocBtn.addEventListener('click', toggleTocPanel);
                DOM.closeTocBtn.addEventListener('click', closeTocPanel);
                DOM.settingsBtn.addEventListener('click', toggleSettingsPanel);
                DOM.chatBtn.addEventListener('click', toggleChatPanel);
                DOM.homeBtn.addEventListener('click', goToHome);
                DOM.overlay.addEventListener('click', closeAllPanels);
                DOM.closeChatBtn.addEventListener('click', closeChatPanel);
                DOM.prevBtn.addEventListener('click', goToPrevious);
                DOM.nextBtn.addEventListener('click', goToNext);

                DOM.contentArea.addEventListener('click', handleContentClick);
                DOM.contentArea.addEventListener('scroll', debounce(updateProgressBar, 100));
                DOM.contentArea.addEventListener('touchstart', handleTouchStart);
                DOM.contentArea.addEventListener('touchend', handleTouchEnd);

                DOM.fontDecreaseBtn.addEventListener('click', () => { decreaseFontSize(); saveUserPreferences(); });
                DOM.fontIncreaseBtn.addEventListener('click', () => { increaseFontSize(); saveUserPreferences(); });
                DOM.lineHeightDecreaseBtn.addEventListener('click', () => { decreaseLineHeight(); saveUserPreferences(); });
                DOM.lineHeightIncreaseBtn.addEventListener('click', () => { increaseLineHeight(); saveUserPreferences(); });

                DOM.themeOptions.forEach(option => {
                    option.addEventListener('click', () => { setTheme(option.getAttribute('data-theme')); saveUserPreferences(); });
                });

                DOM.viewRawHtmlToggle.addEventListener('change', function() {
                    state.settings.viewRawHtmlEnabled = this.checked;
                    displayCurrentChapter(); // Re-render with new view setting
                    saveUserPreferences();
                });

                DOM.translationToggle.addEventListener('change', function() { localStorage.setItem('translation-enabled', this.checked); saveUserPreferences(); });
                DOM.autoSpeakToggle.addEventListener('change', function() { localStorage.setItem('auto-speak-enabled', this.checked); saveUserPreferences(); });
                DOM.speakSelectionToggle.addEventListener('change', function() { state.settings.speakSelectionEnabled = this.checked; localStorage.setItem('speak-selection-enabled', this.checked); saveUserPreferences(); });
                DOM.speechLanguage.addEventListener('change', function() { localStorage.setItem('speech-language', this.value); saveUserPreferences(); });

                document.addEventListener('selectionchange', handleTextSelection);
                DOM.loginBtn.addEventListener('click', () => { window.open('index.html', '_blank'); });

                DOM.listBadgeContainer.addEventListener('click', handleListBadgeClick);
                DOM.createListBtn.addEventListener('click', toggleCreateListInput);

                DOM.aiCleanupBtn.addEventListener('click', showAiCleanupModal);
                DOM.aiCleanupCloseBtn.addEventListener('click', hideAiCleanupModal);
                DOM.aiCleanupCancelBtn.addEventListener('click', hideAiCleanupModal);
                DOM.aiCleanupConfirmBtn.addEventListener('click', handleAiCleanupConfirm);
                DOM.aiCleanupBackdrop.addEventListener('click', hideAiCleanupModal);

                document.addEventListener('keydown', handleKeyPress);
                document.addEventListener('selectionchange', debounce(handleTextSelection, 300));
                document.addEventListener('click', handleGlobalClick);

                DOM.chatSendBtn.addEventListener('click', handleSendMessage);
                DOM.chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } });
                DOM.chatClearBtn.addEventListener('click', clearChat);
                DOM.chatFullDocToggle.addEventListener('change', (e) => {
                    state.chatUseFullDocument = e.target.checked;
                    showToast(`Chat context set to: ${state.chatUseFullDocument ? 'Full Document' : 'Current Chapter'}`, 2000);
                });
                DOM.chatSuggestions.addEventListener('click', handleSuggestionClick);
                DOM.summarizeChapterBtn.addEventListener('click', summarizeCurrentChapter);
            }

            function downloadExampleBook() { console.log('Example book link clicked.'); }

             function handleGlobalClick(event) {
                 const openDropdowns = document.querySelectorAll('.move-list-dropdown.visible');
                 openDropdowns.forEach(dropdown => {
                     const moveButton = dropdown.closest('.library-item-actions')?.querySelector('.library-item-move');
                     if (moveButton && !dropdown.contains(event.target) && !moveButton.contains(event.target)) {
                         dropdown.classList.remove('visible');
                     }
                 });

                 if (state.isCreatingList && !DOM.createListGroup.contains(event.target)) {
                     if (!DOM.createListBtn.contains(event.target)) {
                         cancelListCreation();
                     }
                 }

                 if (DOM.chatPanel.classList.contains('visible') && !DOM.chatPanel.contains(event.target) && !DOM.chatBtn.contains(event.target)) { closeChatPanel(); }
                 if (DOM.settingsPanel.classList.contains('visible') && !DOM.settingsPanel.contains(event.target) && !DOM.settingsBtn.contains(event.target)) { closeSettingsPanel(); }
                 if (DOM.tocPanel.classList.contains('visible') && !DOM.tocPanel.contains(event.target) && !DOM.tocBtn.contains(event.target)) { closeTocPanel(); }
             }

            function handleKeyPress(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.key === 'ArrowLeft' && e.altKey) { goToPrevious(); e.preventDefault(); }
                if (e.key === 'ArrowRight' && e.altKey) { goToNext(); e.preventDefault(); }

                if (e.key === 'Escape') {
                    if (state.isCreatingList) { cancelListCreation(); }
                    else if (state.isAiCleanupModalOpen) { hideAiCleanupModal(); }
                    else { closeAllPanels(); }
                    e.preventDefault();
                }

                if (e.key === 'Enter' && state.isCreatingList && e.target === DOM.newListNameInput) { handleCreateList(); e.preventDefault(); }
                if (e.key === 't' && !e.ctrlKey && !e.metaKey) { toggleTocPanel(); e.preventDefault(); }
                if (e.key === 's' && !e.ctrlKey && !e.metaKey) { toggleSettingsPanel(); e.preventDefault(); }
                if (e.key === 'h' && !e.ctrlKey && !e.metaKey) { goToHome(); e.preventDefault(); }
                if ((e.key === '+' || e.key === '=') && (e.ctrlKey || e.metaKey)) { increaseFontSize(); saveUserPreferences(); e.preventDefault(); }
                if (e.key === '-' && (e.ctrlKey || e.metaKey)) { decreaseFontSize(); saveUserPreferences(); e.preventDefault(); }
                if (e.key === 'c' && !e.ctrlKey && !e.metaKey && DOM.readerContainer.offsetParent !== null) { toggleChatPanel(); e.preventDefault(); }
            }

            function handleTouchStart(e) { state.touchStartY = e.touches[0].clientY; }
            function handleTouchEnd(e) {
                state.touchEndY = e.changedTouches[0].clientY;
                const distance = state.touchStartY - state.touchEndY;
                if (distance < -50 && DOM.contentArea.scrollTop <= 0) { toggleNavbar(); }
            }

            function handleFileSelected() {
                const file = DOM.fileInput.files[0];
                if (!file) return;
                showLoading();
                DOM.bookTitle.textContent = file.name;
                state.bookData.title = file.name;
                state.bookData.currentListId = null;
                state.bookData.sourceUrl = null; // Reset source URL for local files
                state.bookData.rawContent = null; // Reset raw content
                const fileExtension = file.name.split('.').pop().toLowerCase();
                if (fileExtension === 'txt') { processTextFile(file); }
                else if (fileExtension === 'epub') { processEpubFile(file); }
                else if (fileExtension === 'pdf') { processPdfFile(file); }
                else { hideLoading(); showToast('Unsupported file format'); }
            }

            function processInputText() {
                const text = DOM.textInput.value.trim();
                if (!text) { showToast('Please enter some text'); return; }
                showLoading();
                let customTitle = DOM.textInputTitle.value.trim() || text.substring(0, 20).trim() + (text.length > 20 ? '...' : '');
                DOM.bookTitle.textContent = customTitle;
                state.bookData.title = customTitle;
                state.bookData.currentListId = null;
                state.bookData.sourceUrl = null;
                state.bookData.rawContent = null;
                try {
                    // Treat pasted text as Markdown by default
                    state.bookData.chapters = [{ title: customTitle, markdownContent: text, content: null, startLine: 0, endLine: text.split('\n').length }];
                    state.settings.viewRawHtmlEnabled = false; // Default to Markdown view
                    DOM.viewRawHtmlToggle.checked = false;
                    showBook();
                } catch (error) { console.error('Error processing input text:', error); showToast('Error processing text'); }
                finally { hideLoading(); }
            }

            function processTextFile(file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        // Treat plain text files as Markdown by default
                        const chapters = splitIntoChapters(text, 1000); // Simple chapter splitting for TXT
                        state.bookData.chapters = chapters.map((chap, index) => ({
                            title: chap.title || `Chapter ${index + 1}`,
                            markdownContent: chap.content, // Store as Markdown
                            content: null, // No separate HTML content
                            startLine: chap.startLine,
                            endLine: chap.endLine
                        }));
                        state.settings.viewRawHtmlEnabled = false; // Default to Markdown view
                        DOM.viewRawHtmlToggle.checked = false;
                        showBook();
                    } catch (error) { console.error('Error processing text file:', error); showToast('Error processing file'); }
                    finally { hideLoading(); }
                };
                reader.onerror = function(error) { console.error('Error reading file:', error); hideLoading(); showToast('Error reading file'); };
                reader.readAsText(file);
            }

            // Helper to split text into basic chapters
            function splitIntoChapters(text, linesPerChapter = 1000) {
                const lines = text.split('\n');
                const chapters = [];
                let currentChapterLines = [];
                let chapterStartLine = 0;

                for (let i = 0; i < lines.length; i++) {
                    currentChapterLines.push(lines[i]);
                    // Simple split logic (can be improved)
                    if (currentChapterLines.length >= linesPerChapter || i === lines.length - 1) {
                        const chapterContent = currentChapterLines.join('\n');
                        // Try to find a title in the first few lines
                        let title = null;
                        for(let j=0; j<Math.min(5, currentChapterLines.length); j++) {
                            const trimmedLine = currentChapterLines[j].trim();
                            if (trimmedLine && trimmedLine.length < 80 && !trimmedLine.startsWith('>') && !trimmedLine.startsWith('*') && !trimmedLine.startsWith('-') && !trimmedLine.startsWith('+') && !/^\d+\./.test(trimmedLine)) {
                                title = trimmedLine;
                                break;
                            }
                        }
                        chapters.push({
                            title: title || `Part ${chapters.length + 1}`,
                            content: chapterContent,
                            startLine: chapterStartLine,
                            endLine: i + 1
                        });
                        currentChapterLines = [];
                        chapterStartLine = i + 1;
                    }
                }
                return chapters;
            }


            function processEpubFile(file) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const arrayBuffer = e.target.result;
                        if (typeof JSZip === 'undefined') { await loadExternalScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'); }
                        await extractEpubContent(arrayBuffer);
                    } catch (error) { console.error('Error processing EPUB:', error); hideLoading(); showToast('Error processing EPUB file'); }
                };
                reader.onerror = function(error) { console.error('Error reading EPUB file:', error); hideLoading(); showToast('Error reading EPUB file'); };
                reader.readAsArrayBuffer(file);
            }

            async function loadExternalScript(url) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = url;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
                    document.head.appendChild(script);
                });
            }

            async function extractEpubContent(arrayBuffer) {
                try {
                    const jszip = new JSZip();
                    const zip = await jszip.loadAsync(arrayBuffer);
                    const containerXml = await zip.file('META-INF/container.xml').async('text');
                    const parser = new DOMParser();
                    const containerDoc = parser.parseFromString(containerXml, 'application/xml');
                    const rootFile = containerDoc.querySelector('rootfile');
                    if (!rootFile) throw new Error('Invalid EPUB: container.xml doesn\'t contain a rootfile');
                    const rootFilePath = rootFile.getAttribute('full-path');
                    const rootDir = rootFilePath.substring(0, rootFilePath.lastIndexOf('/') + 1) || '';
                    const opfContent = await zip.file(rootFilePath).async('text');
                    const opfDoc = parser.parseFromString(opfContent, 'application/xml');
                    const metadataElem = opfDoc.querySelector('metadata');
                    if (metadataElem) {
                        const titleElem = metadataElem.querySelector('dc\\:title, title');
                        if (titleElem && titleElem.textContent) { state.bookData.title = titleElem.textContent.trim(); DOM.bookTitle.textContent = state.bookData.title; }
                    }
                    const spine = opfDoc.querySelector('spine');
                    const manifest = opfDoc.querySelector('manifest');
                    if (!spine || !manifest) throw new Error('Invalid EPUB: missing spine or manifest');
                    const manifestItems = {};
                    manifest.querySelectorAll('item').forEach(item => { manifestItems[item.getAttribute('id')] = { href: item.getAttribute('href'), mediaType: item.getAttribute('media-type') }; });
                    const spineItems = [];
                    spine.querySelectorAll('itemref').forEach(itemref => {
                        const idref = itemref.getAttribute('idref');
                        if (manifestItems[idref] && manifestItems[idref].mediaType.includes('html')) { spineItems.push({ id: idref, href: manifestItems[idref].href }); }
                    });

                    let combinedRawHtml = ''; // To store raw HTML for raw view
                    state.bookData.chapters = [];

                    for (const item of spineItems) {
                         const fullPath = rootDir + item.href;
                         try {
                             const chapterHtmlContent = await zip.file(fullPath).async('text');
                             combinedRawHtml += chapterHtmlContent + "\n<!-- Chapter Break -->\n"; // Append raw HTML

                             const htmlDoc = parser.parseFromString(chapterHtmlContent, 'text/html');
                             let title = item.href.split('/').pop().replace(/\.[^/.]+$/, ""); // Fallback title
                             const titleTag = htmlDoc.querySelector('title');
                             const h1 = htmlDoc.querySelector('h1');
                             if (titleTag && titleTag.textContent.trim()) title = titleTag.textContent.trim();
                             else if (h1 && h1.textContent.trim()) title = h1.textContent.trim();

                             // Convert body to basic Markdown (simplistic conversion)
                             const bodyElement = htmlDoc.body;
                             let markdownContent = '';
                             if (bodyElement) {
                                 // Very basic conversion - treat block elements as paragraphs
                                 bodyElement.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote, pre').forEach(el => {
                                     const text = el.textContent?.trim();
                                     if (text) {
                                         let prefix = '';
                                         if (el.tagName.startsWith('H')) {
                                             prefix = '#'.repeat(parseInt(el.tagName.substring(1), 10)) + ' ';
                                         } else if (el.tagName === 'LI') {
                                              prefix = '* '; // Assume unordered for simplicity
                                         } else if (el.tagName === 'BLOCKQUOTE') {
                                              prefix = '> ';
                                         } else if (el.tagName === 'PRE') {
                                              prefix = '```\n'; // Wrap code blocks
                                              markdownContent += prefix + text + '\n```\n\n';
                                              return; // Skip default paragraph ending
                                         }
                                         markdownContent += prefix + text + '\n\n'; // Double newline for paragraph breaks
                                     }
                                 });
                             } else {
                                 markdownContent = "[Could not extract content body]";
                             }

                             state.bookData.chapters.push({
                                 title: title || `Chapter ${state.bookData.chapters.length + 1}`,
                                 markdownContent: markdownContent.trim(), // Store as Markdown
                                 content: chapterHtmlContent, // Store original HTML for raw view reference in metadata later
                                 startLine: 0, // Line numbers less relevant here
                                 endLine: 0
                             });
                         } catch (error) {
                             console.error(`Error loading EPUB chapter ${item.href}:`, error);
                             state.bookData.chapters.push({ title: `Error Loading Chapter`, markdownContent: `[Error loading content: ${error.message}]`, content: null, startLine: 0, endLine: 0 });
                         }
                    }

                    state.bookData.rawContent = combinedRawHtml; // Store combined raw HTML

                    if (state.bookData.chapters.length === 0) {
                        state.bookData.chapters.push({ title: state.bookData.title || 'Content', markdownContent: "[Could not extract readable content from this EPUB file.]", content: null, startLine: 0, endLine: 1 });
                    }

                    state.settings.viewRawHtmlEnabled = false; // Default to Markdown view
                    DOM.viewRawHtmlToggle.checked = false;
                    showBook();
                    hideLoading();
                } catch (error) { console.error('Error extracting EPUB content:', error); hideLoading(); showToast('Error processing EPUB file'); }
            }

            function processPdfFile(file) {
                const reader = new FileReader();
                reader.onload = function() {
                    showToast('PDF support is limited. For a better experience, use a dedicated PDF reader app.');
                    state.bookData.chapters = [{ title: state.bookData.title || 'PDF Content', markdownContent: "PDF content extraction is limited in this simple reader.\n\nFor a better experience with PDFs, consider using a dedicated PDF reader app.", content: null, startLine: 0, endLine: 2 }];
                     state.settings.viewRawHtmlEnabled = false; // Default to Markdown view
                     DOM.viewRawHtmlToggle.checked = false;
                    showBook();
                    hideLoading();
                };
                reader.onerror = function(error) { console.error('Error reading PDF file:', error); hideLoading(); showToast('Error reading PDF file'); };
                reader.readAsArrayBuffer(file);
            }

            async function firecrawlScrapeRequest(apiKey, url) {
                console.log('Attempting to scrape URL:', url);
                try {
                    const response = await fetch('https://api.firecrawl.dev/v0/scrape', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({
                             url: url,
                             pageOptions: { onlyMainContent: false }, // Get full page for raw view
                             extractorOptions: { mode: 'markdown' } // Request Markdown extraction
                         })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `Firecrawl API request failed with status ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Error calling Firecrawl API:', error);
                    return { error: { message: error.message || 'Failed to connect to Firecrawl API' } };
                }
            }

            async function processUrlInput() {
                const url = DOM.urlInput.value.trim();
                if (!url || !url.startsWith('http')) { showToast('Please enter a valid URL'); return; }
                if (!state.userApiSettings || !state.userApiSettings.firecrawl_api_key) { showToast('Firecrawl API key not configured. Please set it up in the main dashboard.'); return; }

                DOM.processUrlBtn.classList.add('loading');
                DOM.processUrlBtn.disabled = true;
                showLoading(); // Show global loading indicator
                DOM.bookTitle.textContent = `Reading: ${url}`;
                state.bookData.title = url;
                state.bookData.currentListId = null;

                try {
                    const response = await firecrawlScrapeRequest(state.userApiSettings.firecrawl_api_key, url);
                    if (response.error) throw new Error(response.error.message);
                    if (!response.data) throw new Error("No data received from Firecrawl.");

                    const rawMarkdownContent = response.data.markdown || "[No Markdown content extracted]";
                    const rawHtmlContent = response.data.content || "[No HTML content extracted]"; // Get raw HTML too

                    state.bookData.rawContent = rawHtmlContent; // Store raw HTML for raw view
                    state.bookData.sourceUrl = url;

                    showToast('Generating title & category with AI...', 3000);
                    let titleCategoryResult = { generatedTitle: null, listId: null };

                    try {
                        // Use a model available in state.userApiSettings or fallback
                        const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest'; // Use Flash as a default if not set
                        titleCategoryResult = await generateTitleAndCategory(rawMarkdownContent, modelToUse);
                        showToast(`Title/Category generated.`, 2000);
                    } catch (aiError) {
                        console.error(`AI title/category generation failed: ${aiError.message}.`);
                        showToast(`AI Title/Cat failed: ${aiError.message}.`, 3000);
                    }

                    const { generatedTitle, listId } = titleCategoryResult;
                    if (generatedTitle) { state.bookData.title = generatedTitle; DOM.bookTitle.textContent = state.bookData.title; showToast(`AI generated title: "${generatedTitle}"`, 3000); }
                    else if (response.data.metadata && response.data.metadata.title) { state.bookData.title = response.data.metadata.title; DOM.bookTitle.textContent = state.bookData.title; }
                    else { showToast('Could not determine title, using URL.', 2000); }

                    state.bookData.currentListId = listId;
                    if (listId !== null) { const listName = state.bookLists.find(l => l.id === listId)?.name || 'Unknown List'; showToast(`Categorized into: "${listName}"`, 3000); }
                    else { showToast('Categorized as Unlisted.', 2000); }

                    // Store content: markdown for display, original HTML for raw view metadata
                    state.bookData.chapters = [{
                        title: 'Content',
                        markdownContent: rawMarkdownContent,
                        content: rawHtmlContent, // Keep raw HTML associated with the chapter for metadata
                        startLine: 0,
                        endLine: 0
                    }];

                    state.settings.viewRawHtmlEnabled = false; // Default to Markdown view
                    DOM.viewRawHtmlToggle.checked = false;
                    showBook();

                } catch (error) {
                    console.error('Error processing URL:', error);
                    showToast(`Error reading URL: ${error.message}`);
                    goToHome(); // Go back home on error
                } finally {
                    DOM.urlInput.value = '';
                    DOM.processUrlBtn.classList.remove('loading');
                    DOM.processUrlBtn.disabled = false;
                    hideLoading();
                }
            }


            async function scrapeAndSaveLink(url) {
                 if (!state.userApiSettings || !state.userApiSettings.firecrawl_api_key) { showToast('Firecrawl API key needed to scrape. Configure in dashboard.', 4000); return; }
                 showToast(`Scraping "${url}"...`, 2000);
                 try {
                     const response = await firecrawlScrapeRequest(state.userApiSettings.firecrawl_api_key, url);
                     if (response.error) throw new Error(response.error.message || 'Firecrawl request failed');
                     if (!response.data) throw new Error('No data received from Firecrawl.');

                     const rawHtmlContent = response.data.content || "[No HTML content extracted]";
                     const markdownContent = response.data.markdown || "[No Markdown content extracted]";
                     const scrapedTitle = (response.data.metadata && response.data.metadata.title) || url;

                     const scrapedBookData = {
                         title: scrapedTitle,
                         content: null, // Main content column is deprecated for large text
                         raw_content: rawHtmlContent, // Store raw HTML here for raw view
                         file_type: 'url',
                         metadata: {
                             chapters: [{
                                 title: 'Content',
                                 content: rawHtmlContent, // Store raw HTML in chapter metadata too
                                 markdownContent: markdownContent, // Store extracted Markdown
                                 startLine: 0, endLine: 0
                             }],
                             viewRawHtmlEnabled: false, // Default scraped links to Markdown view
                             sourceUrl: url
                         },
                         last_position: { chapter: 0, percentComplete: 0, scroll: 0, timestamp: new Date().getTime() }
                     };
                     await saveScrapedBook(scrapedBookData, state.bookData.currentListId); // Use current reader's list context
                 } catch (error) { console.error('Error scraping and saving link:', error); showToast(`Error scraping "${url}": ${error.message}`, 5000); }
            }

            async function saveScrapedBook(scrapedBookData, targetListId = null) {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) { console.error('Cannot save scraped book: User not logged in.'); showToast('Please sign in to save scraped content.', 4000); return false; }
                try {
                    const { error } = await supabase.from('ebooks').insert({
                        user_id: session.user.id,
                        title: scrapedBookData.title,
                        content: scrapedBookData.content, // Keep null or small excerpt if desired
                        raw_content: scrapedBookData.raw_content, // Save raw HTML
                        file_type: scrapedBookData.file_type,
                        metadata: scrapedBookData.metadata, // Includes chapter with MD and raw HTML
                        last_position: scrapedBookData.last_position,
                        list_id: targetListId // Assign list ID
                    });
                    if (error) { if (error.code === '23505') { console.warn(`Book with title "${scrapedBookData.title}" already exists. Skipping save.`); showToast(`Book "${scrapedBookData.title}" already in library.`, 3000); return true; } else { throw error; } }
                    console.log(`Successfully saved scraped book: "${scrapedBookData.title}"`);
                    showToast(`"${scrapedBookData.title}" saved to library!`, 3000);
                    if (DOM.welcomeScreen.style.display !== 'none') { loadUserLibrary(); }
                    return true;
                } catch (error) { console.error('Error saving scraped book to Supabase:', error); showToast(`Failed to save "${scrapedBookData.title}" to library. DB Error.`, 4000); return false; }
            }

            function showLinkActionConfirmation(url, linkText) {
                const existingToast = document.querySelector('.link-action-toast');
                if (existingToast) existingToast.remove();
                const toast = document.createElement('div');
                toast.className = 'link-action-toast';
                toast.innerHTML = `
                    <div class="link-action-header"><span>Action for Link:</span><button type="button" class="link-action-close-btn" aria-label="Close">×</button></div>
                    <div class="link-action-url" title="Clicked link text">${escapeHTML(linkText)}</div>
                    <div class="link-action-target-url" title="Target URL">URL: ${escapeHTML(url)}</div>
                    <div class="link-action-buttons"><button type="button" class="link-action-btn open">Open Link</button><button type="button" class="link-action-btn scrape">Scrape & Save</button></div>`;
                document.body.appendChild(toast);
                const closeBtn = toast.querySelector('.link-action-close-btn');
                const openBtn = toast.querySelector('.link-action-btn.open');
                const scrapeBtn = toast.querySelector('.link-action-btn.scrape');
                const removeToast = () => { toast.classList.remove('visible'); setTimeout(() => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, 300); };
                closeBtn.addEventListener('click', removeToast);
                openBtn.addEventListener('click', () => { window.open(url, '_blank', 'noopener noreferrer'); removeToast(); });
                scrapeBtn.addEventListener('click', () => { scrapeAndSaveLink(url); removeToast(); });
                requestAnimationFrame(() => { toast.classList.add('visible'); });
                setTimeout(removeToast, 15000);
            }

            function renderSuggestedQuestions(questions = []) {
                DOM.chatSuggestions.innerHTML = '';
                if (questions && questions.length > 0) {
                    DOM.chatSuggestions.style.display = 'flex';
                    questions.forEach(question => {
                        const chip = document.createElement('button');
                        chip.className = 'suggestion-chip';
                        chip.textContent = question;
                        chip.type = 'button';
                        DOM.chatSuggestions.appendChild(chip);
                    });
                } else {
                    DOM.chatSuggestions.style.display = 'none';
                }
            }

            function handleSuggestionClick(event) {
                const clickedChip = event.target.closest('.suggestion-chip');
                if (!clickedChip) return;
                sendSuggestedQuestion(clickedChip.textContent);
            }

            function sendSuggestedQuestion(question) {
                if (!state.userApiSettings || !state.userApiSettings.api_key) { displayChatMessage('assistant', 'Sorry, the Gemini API key is not configured. Please set it up in the main dashboard.'); return; }
                displayChatMessage('user', question);
                state.chatHistory.push({ role: 'user', parts: [{ text: question }] });
                const loadingElement = displayChatMessage('assistant', '', true);
                DOM.chatSendBtn.disabled = true;
                processAndSendChat(question, loadingElement);
            }

            function showBook() {
                DOM.welcomeScreen.style.display = 'none';
                DOM.navbar.classList.add('visible'); // Show navbar immediately
                clearTimeout(state.navbarHideTimer);
                state.navbarHideTimer = setTimeout(() => { DOM.navbar.classList.remove('visible'); }, 3000);

                displayCurrentChapter(); // Render content *before* populating TOC or saving
                populateToc();
                saveBookToLibrary(); // Save initial state or update
            }

            function displayCurrentChapter() {
                const chapter = state.bookData.chapters[state.bookData.currentPosition];
                if (!chapter) return;
                DOM.contentArea.innerHTML = ''; // Clear previous content

                // Update chapter title in navbar
                const chapterTitleText = `${state.bookData.title || 'Book'} - ${chapter.title}`;
                if (state.bookData.sourceUrl) { DOM.bookTitle.innerHTML = `<a href="${escapeHTML(state.bookData.sourceUrl)}" target="_blank" rel="noopener noreferrer" title="Open Source URL" style="color: var(--primary-color); text-decoration: none;">${escapeHTML(chapterTitleText)}</a>`; DOM.bookTitle.style.cursor = 'pointer'; }
                else { DOM.bookTitle.innerHTML = escapeHTML(chapterTitleText); DOM.bookTitle.style.cursor = 'default'; }

                // Enable/disable raw HTML toggle
                const canViewRaw = !!(state.bookData.rawContent || (chapter && chapter.content));
                DOM.viewRawHtmlToggle.disabled = !canViewRaw;
                DOM.viewRawHtmlToggle.closest('.settings-row').title = !canViewRaw ? "Raw HTML view only available for books added via URL or EPUB." : "View the original scraped/extracted HTML content.";
                 // Ensure toggle reflects current state even if disabled
                 DOM.viewRawHtmlToggle.checked = canViewRaw && state.settings.viewRawHtmlEnabled;

                let contentToDisplay = '';
                let displayMode = 'markdown'; // Default

                // Determine what content to show
                if (canViewRaw && state.settings.viewRawHtmlEnabled) {
                     // Prioritize book-level raw content if available, else chapter-level
                    contentToDisplay = state.bookData.rawContent || chapter.content || "[Raw HTML not available]";
                    displayMode = 'raw';
                } else if (typeof chapter.markdownContent === 'string' && chapter.markdownContent.trim() !== '') {
                    // Use Markdown content if available and not in raw mode
                    contentToDisplay = chapter.markdownContent;
                    displayMode = 'markdown';
                } else if (typeof chapter.content === 'string' && chapter.content.trim() !== '') {
                     // Fallback to older HTML content field if Markdown is missing
                     contentToDisplay = chapter.content;
                     displayMode = 'html_fallback'; // Render as HTML
                 } else {
                    // Ultimate fallback
                    contentToDisplay = '<p>[Content not available for this chapter.]</p>';
                    displayMode = 'html_fallback';
                }

                 // Render the content based on the mode
                 if (displayMode === 'raw') {
                    // Render raw content within a <pre> tag for proper display
                    const pre = document.createElement('pre');
                    pre.style.whiteSpace = 'pre-wrap';
                    pre.style.wordBreak = 'break-word';
                    pre.style.fontFamily = 'monospace'; // Use monospace for raw view
                    pre.style.fontSize = 'inherit'; // Don't apply reader font size
                    pre.style.lineHeight = 'inherit'; // Don't apply reader line height
                    pre.textContent = contentToDisplay;
                    DOM.contentArea.appendChild(pre);
                    // Reset reader-specific styles when showing raw HTML
                    DOM.contentArea.style.fontFamily = 'monospace';
                } else if (displayMode === 'markdown') {
                    // Use our custom Markdown parser
                    DOM.contentArea.innerHTML = markdownToHtml(contentToDisplay);
                    // Apply reader styles AFTER content is set
                    DOM.contentArea.style.fontFamily = 'inherit'; // Reset to reader font
                    updateCssVariables(); // Apply font size and line height from settings
                     // Add data-p-index for text anchor restoration (important after innerHTML change)
                     DOM.contentArea.querySelectorAll('p').forEach((p, index) => {
                        p.setAttribute('data-p-index', index);
                    });
                } else { // html_fallback
                     DOM.contentArea.innerHTML = contentToDisplay; // Render as plain HTML
                     // Apply reader styles
                     DOM.contentArea.style.fontFamily = 'inherit';
                     updateCssVariables();
                     // Add data-p-index for text anchor restoration
                      DOM.contentArea.querySelectorAll('p').forEach((p, index) => {
                         p.setAttribute('data-p-index', index);
                     });
                     if (displayMode === 'html_fallback' && chapter.markdownContent === null) {
                         console.warn("Displayed chapter using older 'content' field (HTML). Markdown was missing.");
                     }
                 }

                DOM.contentArea.scrollTop = 0; // Scroll to top on chapter change
                updateNavigationButtonsState();
                updateProgressBar();

                // Show source URL if available
                if (state.bookData.sourceUrl) { DOM.sourceUrlContentLink.href = state.bookData.sourceUrl; DOM.sourceUrlContentLink.textContent = state.bookData.sourceUrl; DOM.sourceUrlDisplay.style.display = 'block'; }
                else { DOM.sourceUrlDisplay.style.display = 'none'; }
            }

            function populateToc() {
                DOM.tocContent.innerHTML = '';
                if (!state.bookData.chapters || state.bookData.chapters.length === 0) {
                    DOM.tocContent.innerHTML = '<div class="toc-item">No chapters found</div>';
                    return;
                }
                state.bookData.chapters.forEach((chapter, index) => {
                    const item = document.createElement('div');
                    item.className = 'toc-item';
                    item.textContent = chapter.title || `Chapter ${index + 1}`;
                    item.setAttribute('data-index', index);
                    if (index === state.bookData.currentPosition) item.classList.add('toc-active');
                    item.addEventListener('click', () => {
                        state.bookData.currentPosition = index;
                        displayCurrentChapter();
                        closeTocPanel();
                        saveBookToLibrary(); // Save progress on chapter change
                    });
                    DOM.tocContent.appendChild(item);
                });
            }

            function updateNavigationButtonsState() {
                DOM.prevBtn.style.opacity = state.bookData.currentPosition <= 0 ? '0.5' : '1';
                DOM.prevBtn.style.pointerEvents = state.bookData.currentPosition <= 0 ? 'none' : 'auto';
                DOM.nextBtn.style.opacity = state.bookData.currentPosition >= state.bookData.chapters.length - 1 ? '0.5' : '1';
                DOM.nextBtn.style.pointerEvents = state.bookData.currentPosition >= state.bookData.chapters.length - 1 ? 'none' : 'auto';
            }

            function goToPrevious() { if (state.bookData.currentPosition > 0) { state.bookData.currentPosition--; displayCurrentChapter(); saveBookToLibrary(); } }
            function goToNext() { if (state.bookData.currentPosition < state.bookData.chapters.length - 1) { state.bookData.currentPosition++; displayCurrentChapter(); saveBookToLibrary(); } }

            function toggleNavbar() {
                DOM.navbar.classList.toggle('visible');
                if (DOM.navbar.classList.contains('visible')) { clearTimeout(state.navbarHideTimer); state.navbarHideTimer = setTimeout(() => { DOM.navbar.classList.remove('visible'); }, 3000); }
            }

            function toggleTocPanel() {
                const isVisible = !DOM.tocPanel.classList.contains('visible');
                DOM.tocPanel.classList.toggle('visible', isVisible);
                DOM.overlay.classList.toggle('visible', isVisible);
                // Close other panels if opening TOC
                if (isVisible) {
                    DOM.settingsPanel.classList.remove('visible');
                    DOM.chatPanel.classList.remove('visible');
                    // Scroll active item into view
                    const activeItem = DOM.tocContent.querySelector('.toc-active');
                    if (activeItem) {
                        setTimeout(() => activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' }), 150);
                    }
                }
            }
            function closeTocPanel() { DOM.tocPanel.classList.remove('visible'); if (!DOM.settingsPanel.classList.contains('visible') && !DOM.chatPanel.classList.contains('visible')) DOM.overlay.classList.remove('visible'); }

            function toggleSettingsPanel() {
                const isVisible = !DOM.settingsPanel.classList.contains('visible');
                DOM.settingsPanel.classList.toggle('visible', isVisible);
                DOM.overlay.classList.toggle('visible', isVisible);
                 if (isVisible) { DOM.tocPanel.classList.remove('visible'); DOM.chatPanel.classList.remove('visible'); }
            }
            function closeSettingsPanel() { DOM.settingsPanel.classList.remove('visible'); if (!DOM.tocPanel.classList.contains('visible') && !DOM.chatPanel.classList.contains('visible')) DOM.overlay.classList.remove('visible'); }

            function toggleChatPanel() {
                const isVisible = !DOM.chatPanel.classList.contains('visible');
                DOM.chatPanel.classList.toggle('visible', isVisible);
                DOM.overlay.classList.toggle('visible', isVisible);
                 if (isVisible) { DOM.tocPanel.classList.remove('visible'); DOM.settingsPanel.classList.remove('visible'); if (state.chatHistory.length <= 1) renderSuggestedQuestions(initialSuggestedQuestions); else renderSuggestedQuestions([]); }
                 else { renderSuggestedQuestions([]); }
            }
            function closeChatPanel() { DOM.chatPanel.classList.remove('visible'); if (!DOM.tocPanel.classList.contains('visible') && !DOM.settingsPanel.classList.contains('visible')) DOM.overlay.classList.remove('visible'); renderSuggestedQuestions([]); }


            function closeAllPanels() {
                closeTocPanel();
                closeSettingsPanel();
                closeChatPanel();
                // Overlay is handled by individual close functions
            }

            function showAiCleanupModal() {
                if (!state.session) { showToast("Please sign in to use AI features.", 3000); return; }
                if (!state.userApiSettings || !state.userApiSettings.api_key) { showToast("Gemini API key needed for AI Cleanup. Configure in dashboard.", 4000); return; }
                DOM.aiCleanupList.innerHTML = '<p>Loading suggestions...</p>';
                DOM.aiCleanupModal.classList.add('visible');
                DOM.aiCleanupBackdrop.classList.add('visible');
                state.isAiCleanupModalOpen = true;
                DOM.aiCleanupConfirmBtn.disabled = true;
                DOM.aiCleanupConfirmBtn.classList.add('loading');
                fetchAllUserBooks()
                    .then(allBooks => {
                        if (!allBooks || allBooks.length === 0) { DOM.aiCleanupList.innerHTML = '<p>Your library is empty. Nothing to clean up!</p>'; DOM.aiCleanupConfirmBtn.disabled = true; DOM.aiCleanupConfirmBtn.classList.remove('loading'); return; }
                        return generateCleanupSuggestions(allBooks);
                    })
                    .then(suggestedBooks => { if (suggestedBooks) populateAiCleanupModal(suggestedBooks); })
                    .catch(error => { console.error("Error during AI Cleanup:", error); DOM.aiCleanupList.innerHTML = `<p>Error generating suggestions: ${error.message}</p>`; DOM.aiCleanupConfirmBtn.disabled = true; DOM.aiCleanupConfirmBtn.classList.remove('loading'); });
            }

            function hideAiCleanupModal() { DOM.aiCleanupModal.classList.remove('visible'); DOM.aiCleanupBackdrop.classList.remove('visible'); state.isAiCleanupModalOpen = false; }

            async function fetchAllUserBooks() {
                if (!state.session) return [];
                try {
                    // Select raw_content as well for potential size check later if needed
                    const { data: books, error } = await supabase.from('ebooks').select('id, title, file_type, metadata, last_position, updated_at, raw_content').eq('user_id', state.session.user.id).order('updated_at', { ascending: true });
                    if (error) throw error;
                    return books || [];
                } catch (error) { console.error("Error fetching all user books:", error); showToast("Could not fetch library for cleanup.", 3000); return []; }
            }

            async function generateCleanupSuggestions(books) {
                 const today = new Date().toISOString().split('T')[0];
                 const bookDataForPrompt = books.map(book => ({ id: book.id, title: book.title.substring(0, 80), progress: calculateOverallProgress(book), last_read: book.last_position?.timestamp ? new Date(book.last_position.timestamp).toISOString().split('T')[0] : new Date(book.updated_at).toISOString().split('T')[0] }));
                 const maxBooksInPrompt = 150;
                 const booksToSend = bookDataForPrompt.slice(0, maxBooksInPrompt);
                 const prompt = `Analyze the following list of ebooks from a user's library. Identify books that are strong candidates for deletion based on these criteria:\n\nToday's date is: ${today}\n\n1.  **Old & Unread:** Books last read over 1 year ago (before ${today.substring(0, 4)}-${today.substring(5, 7)}-${today.substring(8)}) AND have less than 5% progress.\n2.  **Fully Read:** Books with 98% or more progress.\n3.  **Likely Test/Temporary Items:** Books with very short titles (e.g., "test", "untitled", "url", or just a raw URL) that haven't been read recently (e.g., last read > 3 months ago).\n4.  **Duplicates:** Books with identical or very similar titles where one has significantly less progress or hasn't been read for much longer. Prioritize keeping the one with more progress or more recent activity.\n5.  **Old News:** Books whose titles clearly indicate they are news articles (e.g., contain "News", "Daily", "Update") and were last read more than 1 week ago (before ${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}).\n\n**Constraint:** Do NOT suggest deleting items last read within the last 7 days (i.e., on or after ${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}), regardless of other criteria, unless they are clearly fully read (>=98% progress).\n\nHere is the list of books (id, title, progress percentage, last read date YYYY-MM-DD):\n---\n${JSON.stringify(booksToSend, null, 2)}\n---\n\nReturn ONLY a JSON array containing the integer IDs of the books you suggest for deletion based *strictly* on the criteria above. Do not include any explanations or other text. Ensure the constraint about recent items is respected.\n\nExample Output: [123, 456, 789]\n\nJSON Output:`;
                 const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                 try {
                     const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);
                     if (response.error) throw new Error(response.error.message);
                     const resultText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '[]';
                     let suggestedIds = [];
                     try {
                         const jsonMatch = resultText.match(/\[.*?\]/s); // Match JSON array more robustly
                         if (jsonMatch) { suggestedIds = JSON.parse(jsonMatch[0]).map(id => Number(id)).filter(id => !isNaN(id)); }
                         else { console.warn("AI did not return a valid JSON array for cleanup suggestions.", resultText); }
                     } catch (jsonError) { console.error('Error parsing cleanup suggestions JSON:', jsonError, resultText); throw new Error("AI returned invalid format for suggestions."); }
                     return books.filter(book => suggestedIds.includes(book.id));
                 } catch (error) { console.error('Error generating cleanup suggestions:', error); throw error; }
            }

            function populateAiCleanupModal(suggestedBooks) {
                DOM.aiCleanupList.innerHTML = '';
                if (!suggestedBooks || suggestedBooks.length === 0) { DOM.aiCleanupList.innerHTML = '<p>AI didn\'t find any items matching the cleanup criteria. Your library looks tidy!</p>'; DOM.aiCleanupConfirmBtn.disabled = true; DOM.aiCleanupConfirmBtn.classList.remove('loading'); return; }
                const introText = document.createElement('p');
                introText.textContent = `AI suggests removing the following ${suggestedBooks.length} items. Uncheck any you want to keep:`;
                DOM.aiCleanupList.appendChild(introText);
                suggestedBooks.forEach(book => {
                    const itemDiv = document.createElement('div'); itemDiv.className = 'cleanup-item';
                    const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.checked = true; checkbox.value = book.id; checkbox.id = `cleanup-book-${book.id}`;
                    const detailsDiv = document.createElement('div'); detailsDiv.className = 'cleanup-item-details';
                    const titleDiv = document.createElement('div'); titleDiv.className = 'cleanup-item-title'; titleDiv.textContent = book.title; titleDiv.title = book.title;
                    const metaDiv = document.createElement('div'); metaDiv.className = 'cleanup-item-meta'; const progress = calculateOverallProgress(book); const lastRead = book.last_position?.timestamp ? `Last read: ${new Date(book.last_position.timestamp).toLocaleDateString()}` : `Added: ${new Date(book.updated_at).toLocaleDateString()}`; metaDiv.textContent = `Progress: ${progress}% • ${lastRead}`;
                    detailsDiv.appendChild(titleDiv); detailsDiv.appendChild(metaDiv);
                    const label = document.createElement('label'); label.htmlFor = checkbox.id; label.style.display = 'flex'; label.style.alignItems = 'center'; label.style.width = '100%'; label.style.cursor = 'pointer'; label.appendChild(checkbox); label.appendChild(detailsDiv);
                    itemDiv.appendChild(label); DOM.aiCleanupList.appendChild(itemDiv);
                });
                DOM.aiCleanupConfirmBtn.disabled = false;
                DOM.aiCleanupConfirmBtn.classList.remove('loading');
            }

            async function handleAiCleanupConfirm() {
                const checkboxes = DOM.aiCleanupList.querySelectorAll('input[type="checkbox"]:checked');
                const idsToDelete = Array.from(checkboxes).map(cb => parseInt(cb.value, 10));
                if (idsToDelete.length === 0) { showToast("No items selected for deletion.", 2000); hideAiCleanupModal(); return; }
                if (!confirm(`Are you sure you want to permanently delete ${idsToDelete.length} selected item(s)?`)) return;
                DOM.aiCleanupConfirmBtn.disabled = true;
                DOM.aiCleanupConfirmBtn.classList.add('loading');
                showToast(`Deleting ${idsToDelete.length} items...`, 3000);
                try {
                    const { error } = await supabase.from('ebooks').delete().in('id', idsToDelete);
                    if (error) throw error;
                    showToast(`Successfully deleted ${idsToDelete.length} items.`, 3000);
                    hideAiCleanupModal();
                    loadUserLibrary();
                } catch (error) { console.error("Error deleting books:", error); showToast(`Error deleting items: ${error.message}`, 4000); DOM.aiCleanupConfirmBtn.disabled = false; DOM.aiCleanupConfirmBtn.classList.remove('loading'); }
            }

            function goToHome() {
                DOM.welcomeScreen.style.display = 'flex';
                DOM.navbar.classList.remove('visible');
                closeAllPanels();
                DOM.fileInput.value = '';
                DOM.textInput.value = '';
                DOM.textInputTitle.value = '';
                state.bookData = { title: '', content: '', chapters: [], currentPosition: 0, sourceUrl: null, rawContent: null };
                state.selectedListId = 'all';
                state.bookLists = [];
                DOM.sourceUrlDisplay.style.display = 'none';
                // Re-check auth and reload library/lists
                 checkAuthAndLoadApiSettings(); // This now handles library load if signed in
            }

            function handleContentClick(e) {
                // --- START: Intercept Link Clicks ---
                 // Links should only be interactive when NOT in raw HTML view
                 if (!state.settings.viewRawHtmlEnabled) {
                     const link = e.target.closest('a'); // Find the nearest ancestor anchor tag

                     if (link && link.href && DOM.contentArea.contains(link)) { // Ensure link is within content area
                         // It's a click on a link within the content area in Markdown/HTML mode
                         e.preventDefault(); // Stop the browser from following the link immediately
                         const url = link.href;

                         // Check if it's a scrapable URL (http/https)
                         if (url.startsWith('http://') || url.startsWith('https://')) {
                             const linkText = link.textContent || url;
                             showLinkActionConfirmation(url, linkText);
                         } else {
                             // For non-http links (e.g., mailto:, javascript:, internal anchors #), open normally or ignore
                             console.warn(`Link is not directly scrapable or is internal: ${url}`);
                              // Optionally open non-http links
                              // window.open(url, '_blank', 'noopener noreferrer');
                             showToast(`Cannot scrape this type of link: ${url.substring(0, 30)}...`, 3000);
                         }
                         return; // Handled click, exit
                     }
                 }
                 // --- END: Intercept Link Clicks ---

                // Existing Navbar toggle logic
                const selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) return; // Don't toggle UI if selecting text
                const clickY = e.clientY;
                const viewportHeight = window.innerHeight;
                if (DOM.navbar.classList.contains('visible')) { if (!DOM.navbar.contains(e.target)) DOM.navbar.classList.remove('visible'); }
                else if (clickY <= viewportHeight * 0.15) { toggleNavbar(); }

                // Close translation popup on click away
                if (!DOM.translationPopup.contains(e.target)) {
                     DOM.translationPopup.classList.remove('visible');
                     setTimeout(() => { DOM.translationPopup.style.display = 'none'; }, 200);
                }
            }

            function handleTextSelection() {
                const translationEnabled = DOM.translationToggle.checked;
                if (!translationEnabled) return;
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                if (!selectedText) { DOM.translationPopup.style.display = 'none'; clearTimeout(state.translationTimer); return; }
                if (selectedText.length > 1 && selectedText.length < 500) {
                    clearTimeout(state.translationTimer);
                    state.translationTimer = setTimeout(() => {
                        if (window.getSelection().toString().trim() !== selectedText) return; // Selection changed
                        const range = selection.getRangeAt(0);
                        const rect = range.getBoundingClientRect();
                        state.lastSelectionRect = rect;
                        positionTranslationPopup(rect);
                        DOM.translationContent.textContent = 'Translating...';
                        DOM.translationLoading.style.display = 'flex';
                        if (state.settings.speakSelectionEnabled) speakText(selectedText);
                        translateText(selectedText);
                    }, 750);
                } else {
                     // Selection too short or too long, hide popup
                     DOM.translationPopup.classList.remove('visible');
                     setTimeout(() => { DOM.translationPopup.style.display = 'none'; }, 200);
                     clearTimeout(state.translationTimer);
                }
            }

            function positionTranslationPopup(rect) {
                const popup = DOM.translationPopup;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                popup.style.display = 'block';
                popup.classList.remove('visible'); // Ensure it's hidden before calculating size

                // Calculate position after making it visible but transparent
                requestAnimationFrame(() => {
                    popup.style.opacity = '0'; // Hide while calculating
                    popup.style.transform = 'translateY(10px)'; // Reset transform

                    const popupWidth = popup.offsetWidth;
                    const popupHeight = popup.offsetHeight;
                    let leftPos = rect.left + window.scrollX + (rect.width / 2) - (popupWidth / 2); // Center below selection
                    let topPos = rect.bottom + window.scrollY + 10; // Below selection

                    // Adjust horizontal position
                    leftPos = Math.max(10, Math.min(leftPos, viewportWidth - popupWidth - 10));

                    // Adjust vertical position if it goes off screen
                    if (topPos + popupHeight > viewportHeight + window.scrollY - 10) {
                        topPos = rect.top + window.scrollY - popupHeight - 10; // Try above selection
                         // If still off screen (selection very high), position beside (less ideal)
                        if (topPos < window.scrollY) {
                            topPos = rect.top + window.scrollY;
                             if (rect.right + popupWidth < viewportWidth - 10) {
                                leftPos = rect.right + window.scrollX + 10; // Right of selection
                            } else {
                                leftPos = rect.left + window.scrollX - popupWidth - 10; // Left of selection
                                leftPos = Math.max(10, leftPos); // Ensure stays on screen left
                            }
                        }
                    }

                    popup.style.left = `${leftPos}px`;
                    popup.style.top = `${topPos}px`;

                    // Make visible with animation
                    requestAnimationFrame(() => {
                         popup.style.opacity = '1';
                         popup.style.transform = 'translateY(0)';
                         popup.classList.add('visible');
                    });
                });
            }

            function decreaseFontSize() { if (state.settings.fontSize > 70) { state.settings.fontSize -= 10; updateFontSize(); } else { showToast('Minimum font size reached'); } }
            function increaseFontSize() { if (state.settings.fontSize < 200) { state.settings.fontSize += 10; updateFontSize(); } else { showToast('Maximum font size reached'); } }
            function updateFontSize() { DOM.fontSizeValue.textContent = `${state.settings.fontSize}%`; localStorage.setItem('ebook-font-size', state.settings.fontSize); updateCssVariables(); /* Update CSS immediately */ }
            function decreaseLineHeight() { if (state.settings.lineHeight > 1.2) { state.settings.lineHeight = Math.round((state.settings.lineHeight - 0.1) * 10) / 10; updateLineHeight(); } else { showToast('Minimum line height reached'); } }
            function increaseLineHeight() { if (state.settings.lineHeight < 2.4) { state.settings.lineHeight = Math.round((state.settings.lineHeight + 0.1) * 10) / 10; updateLineHeight(); } else { showToast('Maximum line height reached'); } }
            function updateLineHeight() { DOM.lineHeightValue.textContent = state.settings.lineHeight; localStorage.setItem('ebook-line-height', state.settings.lineHeight); updateCssVariables(); /* Update CSS immediately */ }

            function setTheme(theme) { document.body.className = `${theme}-theme`; // Replace all classes DOM.themeOptions.forEach(option => { option.classList.remove('active'); if (option.getAttribute('data-theme') === theme) option.classList.add('active'); }); state.settings.theme = theme; localStorage.setItem('ebook-theme', theme); }

            function updateProgressBar() {
                 if (!DOM.contentArea || !DOM.progressBar || !state.bookData.chapters || state.bookData.chapters.length === 0) {
                     if(DOM.progressBar) DOM.progressBar.style.width = '0%';
                     return;
                 }

                 const scrollTop = DOM.contentArea.scrollTop;
                 const scrollHeight = DOM.contentArea.scrollHeight;
                 const clientHeight = DOM.contentArea.clientHeight;

                 // Calculate progress within the current chapter
                 let chapterProgress = 0;
                 if (scrollHeight > clientHeight) {
                     chapterProgress = scrollTop / (scrollHeight - clientHeight);
                 } else if (scrollTop >= 0) {
                    // If content is shorter than viewport, consider it 0% unless scrolled fully down (edge case)
                    chapterProgress = (scrollHeight <= clientHeight && scrollTop === 0) ? 0 : 1;
                 }
                 chapterProgress = Math.max(0, Math.min(1, chapterProgress)); // Clamp between 0 and 1

                 // Calculate overall progress based on chapter position and within-chapter progress
                 const totalChapters = state.bookData.chapters.length;
                 const currentChapterIndex = state.bookData.currentPosition;

                 let overallProgress = 0;
                 if (totalChapters > 0) {
                     // Progress based on completed chapters + progress in current chapter
                     overallProgress = (currentChapterIndex / totalChapters) + (chapterProgress / totalChapters);
                 }

                 overallProgress = Math.max(0, Math.min(1, overallProgress)); // Clamp final progress

                 DOM.progressBar.style.width = `${overallProgress * 100}%`;

                 // Debounce saving the detailed position
                 debounce(saveReadingProgress, 1500)();
            }

            function saveReadingProgress() {
                 if (!state.bookData.chapters || state.bookData.chapters.length === 0) return; // Don't save if no book loaded

                 const percentComplete = calculatePercentageComplete();
                 const currentPosition = {
                     chapter: state.bookData.currentPosition,
                     percentComplete: percentComplete,
                     scroll: DOM.contentArea.scrollTop || 0,
                     timestamp: new Date().getTime(),
                     textAnchor: findVisibleTextAnchor() // Store text anchor for better restore
                 };
                 state.lastPosition = currentPosition;
                 saveBookToLibrary(); // Update the book record in the database
            }

            function calculatePercentageComplete() {
                const scrollTop = DOM.contentArea.scrollTop;
                const scrollHeight = DOM.contentArea.scrollHeight;
                const clientHeight = DOM.contentArea.clientHeight;
                if (scrollHeight <= clientHeight) {
                    // If content fits entirely, progress is 0% if at top, 100% if scrolled at all (even 1px)
                    // However, for consistency, let's call it 0% if at the very top, 1 otherwise.
                    // updateProgressBar handles the overall progress better.
                     return scrollTop === 0 ? 0 : 1;
                }
                return Math.max(0, Math.min(1, scrollTop / (scrollHeight - clientHeight))); // Clamp between 0 and 1
            }

            function findVisibleTextAnchor() {
                 const paragraphs = DOM.contentArea.querySelectorAll('p[data-p-index]');
                 const scrollTop = DOM.contentArea.scrollTop;
                 const contentTop = DOM.contentArea.getBoundingClientRect().top; // Top of the scrollable area
                 const viewportHeight = DOM.contentArea.clientHeight;

                 if (paragraphs.length === 0) return null;

                 for (let i = 0; i < paragraphs.length; i++) {
                     const p = paragraphs[i];
                     const rect = p.getBoundingClientRect(); // Position relative to viewport
                     const pTopInViewport = rect.top;
                     const pBottomInViewport = rect.bottom;

                     // Check if the paragraph is at least partially visible within the content area's viewport
                     // A common heuristic: the top of the paragraph is within the top 1/3rd of the viewport
                      if (pTopInViewport >= contentTop && pTopInViewport < contentTop + viewportHeight / 3) {
                         const text = p.textContent?.substring(0, 50).trim() || '';
                         // Calculate offset based on how much of the paragraph top is scrolled past
                          const offset = Math.max(0, Math.min(1, (contentTop - pTopInViewport) / rect.height));
                         return { index: parseInt(p.getAttribute('data-p-index')), text: text, offset: offset };
                     }
                 }

                 // Fallback: If no paragraph found in the top third, return the first paragraph's info
                  const firstP = paragraphs[0];
                  const firstPRect = firstP.getBoundingClientRect();
                 return {
                     index: parseInt(firstP.getAttribute('data-p-index')),
                     text: firstP.textContent?.substring(0, 50).trim() || '',
                     offset: 0 // Assume starting at the top of the first paragraph
                 };
            }


            function showLoading() { DOM.loading.classList.add('visible'); }
            function hideLoading() { DOM.loading.classList.remove('visible'); }
            function showToast(message, duration = 3000) { const toast = DOM.toast; toast.textContent = message; toast.classList.add('visible'); setTimeout(() => { toast.classList.remove('visible'); }, duration); }
            function debounce(func, delay) { const context = this; return function() { const args = arguments; const functionName = func.name || 'anonymous'; clearTimeout(state.debounceTimers[functionName]); state.debounceTimers[functionName] = setTimeout(() => { func.apply(context, args); delete state.debounceTimers[functionName]; }, delay); }; }

            async function checkAuthAndLoadApiSettings() {
                const { data: { session } } = await supabase.auth.getSession();
                state.session = session;
                if (!session) {
                    // Not logged in: Show login, hide library
                    DOM.loginBtn.classList.remove('hidden');
                    DOM.authSection.innerHTML = `<p>Sign in to save books to your library.</p>`;
                    DOM.librarySection.style.display = 'none';
                    renderListBadges(); // Show default badges like "All", "Unlisted"
                    updateAiFeatureAvailability(null); // Disable AI features visually
                    return; // Stop here if not logged in
                }

                 // Logged in: Update UI, fetch settings & library
                 DOM.loginBtn.classList.add('hidden');
                 DOM.authSection.innerHTML = `<p>Signed in as ${session.user.email}</p>`;
                 DOM.librarySection.style.display = 'flex'; // Use flex for proper layout

                 // Fetch API settings first
                 state.userApiSettings = await getUserApiSettings();
                 updateAiFeatureAvailability(state.userApiSettings); // Update UI based on keys

                 // Then fetch lists and the library content for the default view ('all')
                 await fetchBookLists(); // Fetch lists first to populate listInfoMap
                 loadUserLibrary(); // Load library items for the current filter
            }

            // New helper to update UI based on API key availability
            function updateAiFeatureAvailability(apiSettings) {
                let canUseAi = false;
                let canUseFirecrawl = false;
                 let apiStatusHtml = '<div id="api-status-container">';

                if (apiSettings) {
                    canUseAi = !!(apiSettings.api_key && apiSettings.model);
                    canUseFirecrawl = !!apiSettings.firecrawl_api_key;

                    apiStatusHtml += `<div class="api-status-item"><span class="status-icon">${canUseAi ? '✅' : '❌'}</span><span class="status-text">Gemini API ${canUseAi ? `configured (Model: ${escapeHTML(apiSettings.model)})` : `not configured. <a href="index.html" target="_blank">Set up</a>.`}</span></div>`;
                    apiStatusHtml += `<div class="api-status-item"><span class="status-icon">${canUseFirecrawl ? '✅' : '❌'}</span><span class="status-text">Firecrawl API ${canUseFirecrawl ? 'configured' : `not configured. <a href="index.html" target="_blank">Set up</a>.`}</span></div>`;
                 } else {
                     // Case where user is logged in but no settings found or error fetching
                     apiStatusHtml += `<div class="api-status-item"><span class="status-icon">⚠️</span><span class="status-text">Sign in and <a href="index.html" target="_blank">configure API keys</a> in the dashboard to enable AI features.</span></div>`;
                 }
                apiStatusHtml += '</div>';

                DOM.aiSettingsContent.innerHTML = apiStatusHtml;

                 // Enable/Disable UI elements
                 DOM.translationToggle.disabled = !canUseAi;
                 DOM.chatBtn.disabled = !canUseAi;
                 DOM.summarizeChapterBtn.style.display = canUseAi ? 'block' : 'none';
                 DOM.aiCleanupBtn.style.display = canUseAi ? 'inline-flex' : 'none';
                 DOM.aiCleanupBtn.disabled = !canUseAi;

                 DOM.processUrlBtn.disabled = !canUseFirecrawl;
                 DOM.urlInput.disabled = !canUseFirecrawl;
                 DOM.urlInput.placeholder = canUseFirecrawl ? "Enter a URL to read" : "Firecrawl API key needed";


                 // Visual cues (opacity, tooltips)
                 const setDisabledStyle = (el, disabled, title) => {
                     el.style.opacity = disabled ? "0.5" : "1";
                     el.style.cursor = disabled ? "not-allowed" : "pointer";
                     el.title = disabled ? title : (el.dataset.originalTitle || ''); // Use original title if exists
                 };

                 setDisabledStyle(DOM.chatBtn, !canUseAi, "Gemini API key needed for chat.");
                 setDisabledStyle(DOM.aiCleanupBtn, !canUseAi, "Gemini API key needed for AI Cleanup.");
                 setDisabledStyle(DOM.summarizeChapterBtn, !canUseAi, "Gemini API key needed for Summarization.");
                 DOM.translationToggle.closest('.settings-row').title = !canUseAi ? "Gemini API key needed for translation." : "";
                 DOM.translationToggle.style.cursor = !canUseAi ? "not-allowed" : "pointer";

                 setDisabledStyle(DOM.processUrlBtn, !canUseFirecrawl, "Firecrawl API key needed to process URLs.");
                 DOM.urlInputContainer.title = !canUseFirecrawl ? "Firecrawl API key needed. Set it up in the main dashboard." : "";

                 // Save original titles if not already done
                 if (!DOM.chatBtn.dataset.originalTitle) DOM.chatBtn.dataset.originalTitle = DOM.chatBtn.title;
                 if (!DOM.aiCleanupBtn.dataset.originalTitle) DOM.aiCleanupBtn.dataset.originalTitle = DOM.aiCleanupBtn.title;
                 if (!DOM.summarizeChapterBtn.dataset.originalTitle) DOM.summarizeChapterBtn.dataset.originalTitle = DOM.summarizeChapterBtn.title;
            }


            async function getUserApiSettings() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return null;
                try {
                    const { data, error } = await supabase.from('user_settings').select('api_key, model, firecrawl_api_key').eq('user_id', session.user.id).maybeSingle();
                    if (error) { console.error('Error fetching API settings:', error); return null; }
                    return data;
                } catch (err) {
                    console.error('Exception fetching API settings:', err);
                    return null;
                }
            }

            function toggleCreateListInput() {
                if (!state.isCreatingList) { DOM.newListNameInput.style.display = 'block'; DOM.newListNameInput.focus(); DOM.createListBtn.textContent = '✓'; state.isCreatingList = true; }
                else { handleCreateList(); }
            }

            function cancelListCreation() { DOM.newListNameInput.style.display = 'none'; DOM.newListNameInput.value = ''; DOM.createListBtn.textContent = '+'; state.isCreatingList = false; }

            async function loadUserLibrary() {
                 const { data: { session } } = await supabase.auth.getSession();
                 if (!session) return; // Should not happen if called after auth check, but safety first

                 const libraryList = document.getElementById('library-list');
                 libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Loading books...</div>';

                 // Ensure listInfoMap is populated before rendering books
                 const listInfoMap = new Map(state.bookLists.map((list, index) => [list.id, { name: list.name, index: index }]));
                 const badgeColors = 5;

                 try {
                     let query = supabase.from('ebooks')
                         .select('id, title, file_type, metadata, list_id, last_position, updated_at, raw_content') // Select necessary fields
                         .eq('user_id', session.user.id);

                     // Apply list filter
                     if (state.selectedListId === 'all') {
                         // No list filter needed
                     } else if (state.selectedListId === null || state.selectedListId === '') { // Filter for unlisted
                         query = query.is('list_id', null);
                     } else { // Filter for a specific list
                         query = query.eq('list_id', state.selectedListId);
                     }

                     query = query.order('updated_at', { ascending: false }); // Order by last updated

                     const { data: books, error } = await query;
                     if (error) throw error;

                     if (!books || books.length === 0) {
                         const filterText = state.selectedListId === 'all' ? 'library' :
                                            (state.selectedListId === null ? '"Unlisted"' : `"${listInfoMap.get(parseInt(state.selectedListId))?.name || 'Selected'}" list`);
                         libraryList.innerHTML = `<div style="text-align: center; padding: 20px;">Your ${filterText} is empty</div>`;
                         return;
                     }

                     libraryList.innerHTML = ''; // Clear loading message
                     books.forEach(book => {
                         const date = new Date(book.last_position?.timestamp || book.updated_at).toLocaleDateString();
                         const progress = calculateOverallProgress(book);
                         const listInfo = book.list_id ? listInfoMap.get(book.list_id) : null;
                         const listName = listInfo ? listInfo.name : null;
                         let listBadgeHtml = '';

                         if (listName) {
                             const colorIndex = (listInfo.index + 1) % badgeColors; // +1 to shift colors from 'All'
                             listBadgeHtml = `<span class="library-item-list-badge" data-color-index="${colorIndex}" title="List: ${escapeHTML(listName)}">${escapeHTML(listName)}</span>`;
                         } else {
                             listBadgeHtml = `<span class="library-item-list-badge" title="Unlisted">Unlisted</span>`;
                         }

                         const item = document.createElement('div');
                         item.className = 'library-item';
                         item.innerHTML = `
                            <div class="library-item-details">
                                <div class="library-item-title-container">
                                    <div class="library-item-title">${escapeHTML(book.title)}</div>
                                    ${listBadgeHtml}
                                </div>
                                <div class="library-item-meta">${book.file_type?.toUpperCase() || 'BOOK'} • Last interaction: ${date} • ${progress}%</div>
                                <div class="progress-bar-container">
                                    <div class="progress-bar" style="width: ${progress}%"></div>
                                </div>
                            </div>
                            <div class="library-item-actions" style="position: relative;">
                                <button class="library-item-move" data-id="${book.id}" data-current-list-id="${book.list_id || ''}" style="display: none;">Move</button>
                                <div class="move-list-dropdown"></div>
                                <button class="library-item-delete" data-id="${book.id}" aria-label="Delete Book">×</button>
                            </div>`;

                         // Add click listener to load the book (ignore clicks on buttons)
                         item.addEventListener('click', (event) => {
                             if (event.target.closest('.library-item-delete, .library-item-move, .move-list-dropdown')) return;
                             loadBookFromLibrary(book);
                         });

                         libraryList.appendChild(item);

                         // Setup "Move" button and dropdown logic
                         const moveButton = item.querySelector('.library-item-move');
                         const dropdownContainer = item.querySelector('.move-list-dropdown');
                         if (moveButton && dropdownContainer && state.bookLists.length > 0) {
                             moveButton.style.display = 'inline-block';
                             moveButton.addEventListener('click', (event) => {
                                 event.stopPropagation();
                                 // Close other dropdowns
                                 document.querySelectorAll('.move-list-dropdown.visible').forEach(dd => {
                                     if (dd !== dropdownContainer) dd.classList.remove('visible');
                                 });
                                 // Toggle and populate current dropdown
                                 const isVisible = dropdownContainer.classList.toggle('visible');
                                 if (isVisible) {
                                     const bookId = moveButton.getAttribute('data-id');
                                     const currentListId = moveButton.getAttribute('data-current-list-id') || null; // Ensure null for empty string
                                     renderMoveToListDropdown(dropdownContainer, bookId, currentListId);
                                 }
                             });
                         }

                         // Setup "Delete" button listener
                         const deleteButton = item.querySelector('.library-item-delete');
                         deleteButton.addEventListener('click', async (event) => {
                             event.stopPropagation();
                             const bookId = deleteButton.getAttribute('data-id');
                             if (confirm('Remove this book from your library? This cannot be undone.')) {
                                 await deleteBookFromLibrary(bookId);
                             }
                         });
                     });

                 } catch (error) {
                     console.error('Error loading library:', error);
                     libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Error loading library</div>';
                 }
            }

            async function fetchBookLists() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                try {
                    const { data, error } = await supabase.from('book_lists').select('id, name').eq('user_id', session.user.id).order('name', { ascending: true });
                    if (error) throw error;
                    state.bookLists = data || [];
                    renderListBadges(); // Re-render badges with fetched lists
                } catch (error) { console.error('Error fetching book lists:', error); showToast('Could not load book lists'); state.bookLists = []; renderListBadges(); }
            }

            function renderListBadges() {
                DOM.listBadgeContainer.innerHTML = '';
                const badgeColors = 5; // Number of distinct badge colors

                // Helper to create badges
                 const createBadge = (text, listId, isSpecial = false, colorIndex = -1) => {
                     const badge = document.createElement('div');
                     badge.className = 'list-badge';
                     badge.textContent = text;
                     // Use empty string for 'Unlisted' (null ID), 'all' for 'All', otherwise the ID
                     const dataListIdValue = listId === null ? '' : String(listId);
                     badge.setAttribute('data-list-id', dataListIdValue);

                     // Determine active state
                     const currentIdStr = state.selectedListId === null ? '' : String(state.selectedListId);
                     if (currentIdStr === dataListIdValue) {
                         badge.classList.add('active');
                     }

                     // Assign color index if it's a regular list
                     if (!isSpecial && colorIndex >= 0) {
                         badge.setAttribute('data-color-index', colorIndex % badgeColors);
                     } else if (isSpecial && listId === 'all') {
                          // Give 'All' a default color (optional)
                          badge.setAttribute('data-color-index', 0); // e.g., use the first color
                     }

                     return badge;
                 };

                 // Add 'All' badge
                 DOM.listBadgeContainer.appendChild(createBadge('All', 'all', true, 0));

                 // Add 'Unlisted' badge
                 DOM.listBadgeContainer.appendChild(createBadge('Unlisted', null, true)); // listId null is handled correctly

                 // Add badges for user-created lists
                 state.bookLists.forEach((list, index) => {
                     // Use index + 1 for color to avoid reusing 'All' color index immediately
                     DOM.listBadgeContainer.appendChild(createBadge(list.name, list.id, false, index + 1));
                 });
            }


            function handleListBadgeClick(event) {
                 const clickedBadge = event.target.closest('.list-badge');
                 if (!clickedBadge || clickedBadge.classList.contains('active')) return;

                 const selectedValue = clickedBadge.getAttribute('data-list-id');

                 // Convert attribute value back to appropriate type for state
                 if (selectedValue === 'all') {
                     state.selectedListId = 'all';
                 } else if (selectedValue === '') { // Empty string represents Unlisted (null ID)
                     state.selectedListId = null;
                 } else {
                     state.selectedListId = parseInt(selectedValue, 10); // Parse specific list ID
                 }

                 // Update UI
                 DOM.listBadgeContainer.querySelectorAll('.list-badge').forEach(badge => badge.classList.remove('active'));
                 clickedBadge.classList.add('active');

                 // Reload library view
                 loadUserLibrary();
            }

            async function handleCreateList() {
                const listName = DOM.newListNameInput.value.trim();
                if (!listName) { showToast('Please enter a name for the new list.'); DOM.newListNameInput.focus(); return; }
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) { showToast('Please sign in to create lists.'); return; }
                DOM.createListBtn.disabled = true; DOM.createListBtn.classList.add('loading'); DOM.createListBtn.textContent = '...';
                try {
                    const { data, error } = await supabase.from('book_lists').insert({ user_id: session.user.id, name: listName }).select().single();
                    if (error) { if (error.code === '23505') throw new Error(`List "${listName}" already exists.`); else throw error; }
                    showToast(`List "${listName}" created.`);
                    cancelListCreation();
                    await fetchBookLists(); // Refresh the list badges and state.bookLists
                } catch (error) { console.error('Error creating list:', error); showToast(`Error: ${error.message}`); DOM.createListBtn.disabled = false; DOM.createListBtn.classList.remove('loading'); DOM.createListBtn.textContent = '✓'; DOM.newListNameInput.focus(); }
                finally {
                    // Ensure button state is reset even on error
                     if (DOM.createListBtn.classList.contains('loading')) {
                         DOM.createListBtn.disabled = false;
                         DOM.createListBtn.classList.remove('loading');
                         // Reset text based on whether input is visible
                         DOM.createListBtn.textContent = state.isCreatingList ? '✓' : '+';
                     }
                }
            }

            function renderMoveToListDropdown(dropdownElement, bookId, currentListIdStr) {
                dropdownElement.innerHTML = ''; // Clear previous options

                 // Convert string ID (potentially empty) to number or null
                 const currentListId = (currentListIdStr === '' || currentListIdStr === 'null' || currentListIdStr === null)
                     ? null
                     : parseInt(currentListIdStr, 10);

                 // Add 'Unlisted' option
                 const unlistedOption = document.createElement('div');
                 unlistedOption.className = 'move-list-option';
                 unlistedOption.textContent = 'Unlisted';
                 unlistedOption.setAttribute('data-target-list-id', ''); // Empty string for null ID target
                 if (currentListId === null) {
                     unlistedOption.classList.add('disabled');
                     unlistedOption.title = 'Already Unlisted';
                 } else {
                     unlistedOption.addEventListener('click', (e) => {
                         e.stopPropagation();
                         moveBookToList(bookId, null); // Pass null for Unlisted
                         dropdownElement.classList.remove('visible');
                     });
                 }
                 dropdownElement.appendChild(unlistedOption);

                 // Add separator if there are other lists
                 if (state.bookLists.length > 0) {
                     const separator = document.createElement('hr');
                     separator.style.margin = '2px 0';
                     separator.style.borderColor = 'var(--border-color)';
                     dropdownElement.appendChild(separator);
                 }

                 // Add user-created lists
                 state.bookLists.forEach(list => {
                     const option = document.createElement('div');
                     option.className = 'move-list-option';
                     option.textContent = list.name;
                     option.setAttribute('data-target-list-id', list.id);
                     if (list.id === currentListId) {
                         option.classList.add('disabled');
                         option.title = 'Already in this list';
                     } else {
                         option.addEventListener('click', (e) => {
                             e.stopPropagation();
                             moveBookToList(bookId, list.id);
                             dropdownElement.classList.remove('visible');
                         });
                     }
                     dropdownElement.appendChild(option);
                 });
            }

            async function moveBookToList(bookId, targetListId) {
                 showLoading();
                 try {
                     const { error } = await supabase.from('ebooks').update({
                         list_id: targetListId, // Use null directly if targetListId is null
                         updated_at: new Date() // Update timestamp on move
                     }).eq('id', bookId);
                     if (error) throw error;
                     showToast("Book moved successfully.");
                     loadUserLibrary(); // Refresh the current view
                 } catch (error) {
                     console.error('Error moving book:', error);
                     showToast("Error moving book.");
                 } finally {
                     hideLoading();
                 }
            }

            async function deleteBookFromLibrary(bookId) {
                showLoading();
                try {
                    const { error } = await supabase.from('ebooks').delete().eq('id', bookId);
                    if (error) throw error;
                    loadUserLibrary(); // Refresh library view
                    showToast('Book removed from library');
                } catch (error) { console.error('Error deleting book:', error); showToast('Could not delete the book'); }
                finally { hideLoading(); }
            }

             async function saveBookToLibrary() {
                 const { data: { session } } = await supabase.auth.getSession();
                 // Only save if logged in and there's a valid book title/data
                 if (!session || !state.bookData.title || !state.bookData.chapters || state.bookData.chapters.length === 0) {
                      console.log("Save skipped: No session or book data.");
                      return false;
                 }

                 try {
                     // Determine file type (less critical now, but keep for consistency)
                     let fileType = 'unknown';
                     if (state.bookData.sourceUrl) {
                         fileType = 'url';
                     } else if (state.bookData.title.includes('.')) {
                         fileType = state.bookData.title.split('.').pop().toLowerCase();
                     } else {
                          // Guess based on content? Might be unreliable. Default to 'text'.
                          fileType = 'text';
                     }


                     // Prepare metadata, including chapters with both Markdown and raw HTML (if available)
                     const metadata = {
                         chapters: state.bookData.chapters.map(chapter => ({
                             title: chapter.title,
                             // Include both content types if they exist
                             content: chapter.content || null, // Raw HTML content
                             markdownContent: chapter.markdownContent || null, // Markdown content
                             startLine: chapter.startLine,
                             endLine: chapter.endLine
                         })),
                         viewRawHtmlEnabled: state.settings.viewRawHtmlEnabled, // Persist view preference
                         sourceUrl: state.bookData.sourceUrl
                     };

                     // Get the latest reading position
                     const lastPosition = state.lastPosition || {
                         chapter: state.bookData.currentPosition,
                         scroll: DOM.contentArea.scrollTop || 0,
                         percentComplete: calculatePercentageComplete(),
                         timestamp: new Date().getTime(),
                         textAnchor: findVisibleTextAnchor()
                     };

                     // Prepare data for upsert
                     const bookRecord = {
                         user_id: session.user.id,
                         title: state.bookData.title,
                         content: null, // Deprecate direct content saving for large text
                         raw_content: state.bookData.rawContent || null, // Store raw HTML content
                         file_type: fileType,
                         metadata: metadata,
                         last_position: lastPosition,
                         list_id: state.bookData.currentListId || null, // Ensure null is used for unlisted
                         updated_at: new Date() // Always update timestamp
                     };

                     // Use upsert to either insert or update based on title and list_id
                     // Note: A unique constraint on (user_id, title, list_id) might be useful in Supabase
                     // For simplicity here, we'll upsert based on title primarily, assuming titles are unique enough *within a list/unlisted* for a user.
                     // A more robust approach might involve querying first, then updating or inserting.
                     // Let's try upsert with conflict resolution on (user_id, title, list_id IF NOT NULL) - tricky constraint setup.
                     // Simpler: Query first.

                     let existingBookQuery = supabase.from('ebooks')
                         .select('id')
                         .eq('user_id', session.user.id)
                         .eq('title', state.bookData.title);

                     if (state.bookData.currentListId === null) {
                         existingBookQuery = existingBookQuery.is('list_id', null);
                     } else {
                         existingBookQuery = existingBookQuery.eq('list_id', state.bookData.currentListId);
                     }

                     const { data: existingBook, error: checkError } = await existingBookQuery.maybeSingle();

                     if (checkError) {
                         console.error("Error checking for existing book:", checkError);
                         throw checkError; // Let the catch block handle it
                     }

                     if (existingBook && existingBook.id) {
                         // --- UPDATE existing book ---
                         const { error: updateError } = await supabase
                             .from('ebooks')
                             .update({
                                 // Only update fields that change frequently or structure
                                 raw_content: bookRecord.raw_content, // Update if raw content changed
                                 metadata: bookRecord.metadata,
                                 last_position: bookRecord.last_position,
                                 updated_at: bookRecord.updated_at,
                                 file_type: bookRecord.file_type // Update file type if it changed (unlikely)
                             })
                             .eq('id', existingBook.id);

                         if (updateError) {
                             console.error("Error updating book:", updateError);
                             throw updateError;
                         }
                         // console.log("Book updated in library:", bookRecord.title);
                     } else {
                         // --- INSERT new book ---
                          // Remove updated_at from insert object as Supabase handles it
                          delete bookRecord.updated_at;
                         const { error: insertError } = await supabase
                             .from('ebooks')
                             .insert(bookRecord);

                         if (insertError) {
                             console.error("Error inserting book:", insertError);
                             throw insertError;
                         }
                          console.log("Book saved to library:", bookRecord.title);
                     }

                     return true; // Indicate success
                 } catch (error) {
                     console.error('Error saving book to library:', error);
                      showToast("Error saving progress.", 2000); // Notify user
                     return false; // Indicate failure
                 }
             }

             async function loadBookFromLibrary(book) {
                 showLoading();
                 try {
                     state.bookData.title = book.title;
                     state.bookData.currentListId = book.list_id || null;
                     state.bookData.rawContent = book.raw_content || null; // Load raw content
                     DOM.bookTitle.textContent = book.title;

                     if (book.metadata && book.metadata.chapters && book.metadata.chapters.length > 0) {
                         // Load chapters from metadata
                         state.bookData.chapters = book.metadata.chapters.map(chapter => ({
                             title: chapter.title,
                             content: chapter.content || null, // Raw HTML from metadata
                             markdownContent: chapter.markdownContent || null, // Markdown from metadata
                             startLine: chapter.startLine,
                             endLine: chapter.endLine
                         }));
                         state.bookData.sourceUrl = book.metadata.sourceUrl || null;
                     } else {
                         // Fallback if metadata structure is missing/old
                         state.bookData.chapters = [{ title: book.title, markdownContent: "[Content structure not found in metadata]", content: null, startLine: 0, endLine: 1 }];
                         state.bookData.sourceUrl = null;
                         console.warn("Book metadata missing or incomplete for:", book.title);
                     }

                     // Load view setting from metadata
                     state.settings.viewRawHtmlEnabled = (book.metadata && book.metadata.viewRawHtmlEnabled !== undefined)
                         ? book.metadata.viewRawHtmlEnabled
                         : false; // Default to Markdown view if not set
                     DOM.viewRawHtmlToggle.checked = state.settings.viewRawHtmlEnabled;

                     const lastPosition = book.last_position || {};
                     state.bookData.currentPosition = lastPosition.chapter !== undefined ? lastPosition.chapter : 0;

                     showBook(); // Display the first/saved chapter

                     // Restore position *after* showing the book (content needs to be rendered)
                     restoreReadingPosition(lastPosition);

                 } catch (error) {
                     console.error('Error loading book from library:', error);
                     showToast('Error loading book: ' + error.message);
                     goToHome(); // Go home if loading fails
                 } finally {
                     hideLoading();
                 }
             }


            function restoreReadingPosition(lastPosition) {
                 if (!lastPosition || !DOM.contentArea) return;

                 // Ensure the correct chapter is displayed *before* attempting to scroll
                 // displayCurrentChapter() should have handled this already if called correctly

                 showToast('Restoring reading position...', 1500);

                 // Use requestAnimationFrame to allow the browser to render the chapter content first
                 requestAnimationFrame(() => {
                     // Maybe even a double frame for complex layouts
                     requestAnimationFrame(() => {
                         let restored = false;
                         const isPositionRecent = lastPosition.timestamp && (Date.now() - lastPosition.timestamp < 90 * 24 * 60 * 60 * 1000); // ~3 months

                         // 1. Try restoring by text anchor (most reliable if structure matches)
                         if (isPositionRecent && lastPosition.textAnchor && lastPosition.textAnchor.index !== undefined) {
                             restored = restoreByTextAnchor(lastPosition.textAnchor);
                             if (restored) {
                                 console.log(`Restored position using text anchor (Index: ${lastPosition.textAnchor.index}).`);
                                 updateProgressBar(); // Update progress bar after scroll
                                 return;
                             } else {
                                 console.warn("Failed to restore using text anchor, trying percentage.");
                             }
                         } else if (isPositionRecent && lastPosition.textAnchor) {
                              console.warn("Text anchor data seems incomplete, skipping.", lastPosition.textAnchor);
                         }

                         // 2. Try restoring by percentage complete (good fallback)
                         if (lastPosition.percentComplete !== undefined && lastPosition.percentComplete >= 0 && lastPosition.percentComplete <= 1) {
                             const scrollHeight = DOM.contentArea.scrollHeight;
                             const clientHeight = DOM.contentArea.clientHeight;
                             if (scrollHeight > clientHeight) {
                                 const targetPosition = lastPosition.percentComplete * (scrollHeight - clientHeight);
                                 DOM.contentArea.scrollTo({ top: targetPosition, behavior: 'auto' });
                                 console.log(`Restored position using percentage: ${Math.round(lastPosition.percentComplete * 100)}%`);
                                 restored = true;
                                 updateProgressBar(); // Update progress bar after scroll
                                 return;
                             }
                         }

                         // 3. As a last resort, use the raw scroll value (least reliable)
                         if (lastPosition.scroll !== undefined && lastPosition.scroll >= 0) {
                             // Check if scroll value is plausible
                             if (lastPosition.scroll < DOM.contentArea.scrollHeight) {
                                 DOM.contentArea.scrollTo({ top: lastPosition.scroll, behavior: 'auto' });
                                 console.warn("Restored position using raw scroll value (fallback).");
                                 restored = true;
                                 updateProgressBar(); // Update progress bar after scroll
                                 return;
                             } else {
                                 console.warn("Saved scroll position exceeds current scroll height, ignoring.");
                             }
                         }

                         // If nothing worked, scroll to top
                         if (!restored) {
                             console.warn("Could not restore reading position from saved data. Scrolling to top.");
                             DOM.contentArea.scrollTo({ top: 0, behavior: 'auto' });
                             updateProgressBar(); // Update progress bar after scroll
                         }
                     });
                 });
             }


             function restoreByTextAnchor(textAnchor) {
                 if (!textAnchor || textAnchor.index === undefined || textAnchor.index < 0) return false;

                 // Ensure paragraphs have the data-p-index attribute (might be missing if content was loaded differently)
                 DOM.contentArea.querySelectorAll('p:not([data-p-index])').forEach((p, index) => {
                      // This simple re-indexing might be wrong if called multiple times,
                      // it's better to ensure it's set correctly during displayCurrentChapter
                      // For robustness, we'll just try to find the element.
                      // p.setAttribute('data-p-index', index); // Avoid re-indexing here
                 });


                 let targetParagraph = DOM.contentArea.querySelector(`p[data-p-index="${textAnchor.index}"]`);

                 // If the exact index isn't found, try to find by text similarity (less reliable but good fallback)
                  if (!targetParagraph && textAnchor.text) {
                     console.warn(`Paragraph at index ${textAnchor.index} not found. Searching by text...`);
                     const paragraphs = DOM.contentArea.querySelectorAll('p[data-p-index]'); // Get potentially re-indexed paragraphs
                     for (let i = 0; i < paragraphs.length; i++) {
                         if (isTextSimilar(paragraphs[i].textContent, textAnchor.text)) {
                             targetParagraph = paragraphs[i];
                             console.log(`Found similar text in paragraph index ${paragraphs[i].getAttribute('data-p-index')}`);
                             break; // Found a likely match
                         }
                     }
                 }

                 if (!targetParagraph) {
                     console.error("Could not find target paragraph for text anchor restoration.");
                     return false; // Still couldn't find it
                 }

                 // Scroll the target paragraph into view near the top
                  targetParagraph.scrollIntoView({ behavior: 'auto', block: 'start' });

                  // Optional: Adjust slightly based on offset if needed, but start is often good enough
                  if (textAnchor.offset && textAnchor.offset > 0.1) { // Only adjust if significantly offset
                       const rect = targetParagraph.getBoundingClientRect();
                       const scrollAdjustment = rect.height * textAnchor.offset;
                       DOM.contentArea.scrollTop += scrollAdjustment; // Fine-tune scroll based on offset
                  }


                 console.log(`Scrolled to anchor paragraph (Index: ${targetParagraph.getAttribute('data-p-index')})`);
                 return true;
             }

            // Helper function for text similarity check (simple prefix match)
            function isTextSimilar(text1, text2) {
                if (!text1 || !text2) return false;
                const t1 = text1.substring(0, 50).trim().toLowerCase();
                const t2 = text2.substring(0, 50).trim().toLowerCase();
                return t1.startsWith(t2) || t2.startsWith(t1); // Check if one starts with the other
            }


            function displayChatMessage(sender, message, isLoading = false) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message', sender);
                if (sender === 'assistant') {
                     // Basic Markdown handling for chat (Bold and Links)
                     let processedMessage = escapeHTML(message);
                     processedMessage = processedMessage.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                     processedMessage = processedMessage.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                     // Handle simple unordered lists (lines starting with * or -)
                      processedMessage = processedMessage.replace(/^([*-])\s+(.*)$/gm, '<li>$2</li>');
                      // Wrap consecutive list items in <ul>
                      processedMessage = processedMessage.replace(/(<li>.*?<\/li>\s*)+/g, '<ul>$1</ul>');
                     // Basic newline handling
                     processedMessage = processedMessage.replace(/\n/g, '<br>'); // Convert remaining newlines
                      // Clean up potential extra <br> around list tags
                      processedMessage = processedMessage.replace(/<br>\s*<ul>/g, '<ul>');
                      processedMessage = processedMessage.replace(/<\/ul>\s*<br>/g, '</ul>');
                     messageElement.innerHTML = processedMessage;
                }
                else { messageElement.textContent = message; }
                if (isLoading) messageElement.classList.add('loading');
                DOM.chatMessages.appendChild(messageElement);
                DOM.chatMessages.scrollTop = DOM.chatMessages.scrollHeight;
                return messageElement;
            }

            function clearChat() {
                state.chatHistory = [];
                DOM.chatMessages.innerHTML = '';
                const initialGreeting = state.chatUseFullDocument ? "Chat cleared. Ask me anything about the full document." : "Chat cleared. Ask me anything about the current chapter.";
                displayChatMessage('assistant', initialGreeting);
                renderSuggestedQuestions(initialSuggestedQuestions);
            }

            async function handleSendMessage() {
                const userMessage = DOM.chatInput.value.trim();
                if (!userMessage) return;
                if (!state.userApiSettings || !state.userApiSettings.api_key) { displayChatMessage('assistant', 'Sorry, the Gemini API key is not configured. Please set it up in the main dashboard.'); return; }
                displayChatMessage('user', userMessage);
                state.chatHistory.push({ role: 'user', parts: [{ text: userMessage }] });
                DOM.chatInput.value = '';
                DOM.chatInput.style.height = 'auto'; // Reset height
                const loadingElement = displayChatMessage('assistant', '', true);
                DOM.chatSendBtn.disabled = true;
                renderSuggestedQuestions([]);
                processAndSendChat(userMessage, loadingElement);
            }

             // Auto-resize textarea
            DOM.chatInput.addEventListener('input', () => {
                DOM.chatInput.style.height = 'auto'; // Reset height
                DOM.chatInput.style.height = `${Math.min(DOM.chatInput.scrollHeight, 80)}px`; // Set new height up to max
            });


            async function processAndSendChat(userMessage, loadingElement) {
                 try {
                     let contextContent = ""; let contextSource = "";
                     const currentChapter = state.bookData.chapters[state.bookData.currentPosition];

                     if (state.chatUseFullDocument) {
                         contextSource = "the full document";
                         // Join Markdown content preferentially
                         contextContent = state.bookData.chapters
                             .map(ch => ch.markdownContent || ch.content || '') // Use MD, fallback to HTML, then empty
                             .join("\n\n---\n\n");
                     } else {
                         contextSource = "the current chapter";
                         // Use Markdown preferentially for the current chapter
                         contextContent = currentChapter ? (currentChapter.markdownContent || currentChapter.content || "No chapter content available.") : "No chapter loaded.";
                     }

                     const maxContextLength = 15000; // Keep context reasonable
                     const fullContext = contextContent.length > maxContextLength ? contextContent.substring(0, maxContextLength) + "\n... [Context Truncated]" : contextContent;

                     const historyToSend = state.chatHistory.slice(-10); // Limit history
                     const language = localStorage.getItem('speech-language') || 'en-US';
                     const languageName = language.startsWith('fr') ? 'French' : 'English';

                      const systemPrompt = `You are a helpful AI assistant integrated into an ebook reader. The user is reading a book and will provide context (either the current chapter or the full document).\nYour primary goal is to help the user **explore and understand** the provided text. Answer questions, summarize, explain concepts, and identify key points based *strictly* on the context.\nBe concise and accurate. \nUse basic Markdown for formatting (like **bold**, *italic*, and simple lists starting with * or -). Use new lines for paragraphs.\nRemember the user might be learning ${languageName}, so explain complex ideas simply if appropriate.\n\n**IMPORTANT - Follow-up Questions:**\nAt the VERY END of your response, provide **up to 3 concrete, specific follow-up questions** (max 7-10 words each) that directly relate to the content just discussed or the provided context. These questions should encourage deeper exploration of the text.\nFormat these questions EXACTLY like this, with no extra text before or after the block:\n[SUGGESTIONS]\n1. Explore the next section\n2. What is the main argument in section X?\n3. Can you explain the term Y mentioned earlier?\n[/SUGGESTIONS]`;

                    // Construct the conversation history for the API call
                     const requestPayloadContents = [
                         { role: 'user', parts: [{ text: systemPrompt }] },
                         { role: 'model', parts: [{ text: "Understood. I will focus on exploring and explaining the provided text using basic Markdown and suggest concrete follow-up questions based on the content." }] },
                         // Include previous turns if any
                         ...historyToSend.slice(0, -1),
                          // Inject the context before the latest user question
                         { role: 'user', parts: [{ text: `Here is the context from ${contextSource}:\n\n---\n${fullContext}\n---\n\nMy question is:` }] },
                          // The actual user question
                         historyToSend[historyToSend.length - 1]
                     ];


                     const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                     const response = await geminiChatRequest(state.userApiSettings.api_key, requestPayloadContents, modelToUse);

                     loadingElement.remove(); // Remove the loading indicator

                     let assistantResponseText = 'Sorry, I could not generate a response.';
                     let extractedSuggestions = [];

                     if (response.error) {
                         assistantResponseText = `Sorry, there was an error: ${response.error.message}`;
                     } else {
                         const rawResponse = response?.candidates?.[0]?.content?.parts?.[0]?.text || '';
                         const suggestionBlockRegex = /\[SUGGESTIONS\]([\s\S]*?)\[\/SUGGESTIONS\]\s*$/; // Matches end of string
                         const match = rawResponse.match(suggestionBlockRegex);

                         if (match && match[1]) {
                             const questionsText = match[1].trim();
                             extractedSuggestions = questionsText.split('\n')
                                 .map(q => q.trim().replace(/^\d+\.\s*/, '')) // Remove numbering
                                 .filter(q => q.length > 0 && q.length < 100); // Basic filtering
                             assistantResponseText = rawResponse.replace(suggestionBlockRegex, '').trim();
                         } else {
                             assistantResponseText = rawResponse.trim();
                         }

                         if (!assistantResponseText) {
                             assistantResponseText = "Okay, I've processed that. What would you like to explore next?";
                         }
                     }

                     displayChatMessage('assistant', assistantResponseText);
                     state.chatHistory.push({ role: 'assistant', parts: [{ text: assistantResponseText }] }); // Save assistant response to history
                     renderSuggestedQuestions(extractedSuggestions);

                 } catch (error) {
                     console.error('Error handling chat message:', error);
                     if (loadingElement && loadingElement.parentNode) {
                        loadingElement.remove();
                     }
                     displayChatMessage('assistant', 'An unexpected error occurred while processing your request.');
                     state.chatHistory.push({ role: 'assistant', parts: [{ text: `Unexpected Error: ${error.message}` }] });
                 } finally {
                     DOM.chatSendBtn.disabled = false;
                     // Limit chat history size
                     if (state.chatHistory.length > 20) {
                         // Keep system prompts + last N turns. Find first non-system prompt to keep context.
                         const systemPromptsCount = state.chatHistory.findIndex(msg => msg.role !== 'user' && msg.role !== 'model'); // Find where real convo starts
                         const startIndex = Math.max(systemPromptsCount >= 0 ? systemPromptsCount : 0, state.chatHistory.length - 16); // Keep ~8 turns + system prompts
                         state.chatHistory = state.chatHistory.slice(startIndex);
                     }
                     DOM.chatInput.style.height = 'auto'; // Reset height after send
                 }
            }


            const getApiUrl = (model) =>
`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=`;

            async function geminiSingleRequest(apiKey, promptText, model) {
                 if (!apiKey || !model) return { error: { message: 'API key or model not configured' } };
                 try {
                     const res = await fetch(`${getApiUrl(model)}${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] }) });
                     if (!res.ok) { const errorData = await res.json(); throw new Error(errorData.error?.message || `API request failed with status ${res.status}`); }
                     return res.json();
                 } catch (error) { console.error('Error calling Gemini API (single request):', error); return { error: { message: error.message || 'Failed to connect to Gemini API' } }; }
            }
            async function geminiChatRequest(apiKey, contents, model) {
                  if (!apiKey || !model) return { error: { message: 'API key or model not configured' } };
                  try {
                     const res = await fetch(`${getApiUrl(model)}${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: contents }) });
                     if (!res.ok) { const errorData = await res.json(); throw new Error(errorData.error?.message || `API request failed with status ${res.status}`); }
                     return res.json();
                 } catch (error) { console.error('Error calling Gemini API (chat):', error); return { error: { message: error.message || 'Failed to connect to Gemini API' } }; }
            }

            async function translateText(text) {
                if (!state.userApiSettings || !state.userApiSettings.api_key) { DOM.translationContent.textContent = 'Please configure Gemini API key to use translation.'; DOM.translationLoading.style.display = 'none'; return; }
                DOM.translationContent.textContent = ''; DOM.translationLoading.style.display = 'flex';
                const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                try {
                    const prompt = `Translate the following English text to Vietnamese. Only return the translation without any explanation or additional text.\n\nText: "${text}"`;
                    const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);
                    DOM.translationLoading.style.display = 'none';
                    if (response.error) { DOM.translationContent.textContent = `Error: ${response.error.message}`; return; }
                    const translation = response?.candidates?.[0]?.content?.parts?.[0]?.text || 'Translation failed.';
                    DOM.translationContent.textContent = translation.trim(); // Trim potential whitespace
                    generateFlashcard(text);
                } catch (error) { console.error('Error translating text:', error); DOM.translationLoading.style.display = 'none'; DOM.translationContent.textContent = 'An error occurred during translation.'; }
            }

             async function generateFlashcard(text) {
                 if (!state.userApiSettings || !state.userApiSettings.api_key) return;
                 const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                 try {
                     const prompt = `Extract a single useful vocabulary word or short phrase from this text that would be good for an English language learner focusing on Vietnamese translation. Choose the most salient or potentially difficult word/phrase.\n\nText: "${text}"\n\nReturn ONLY a JSON object in this exact format, with no extra text, comments, or markdown formatting around it:\n{\n    "word": "the extracted word or short phrase in English",\n    "phrase": "An example English sentence using the word/phrase in context, with the <b>word/phrase</b> wrapped in <b> tags.",\n    "translation_answer": "Vietnamese translation of the word/phrase\\nA brief definition or explanation in English"\n}`;

                     const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);

                     if (response.error) { console.error('Error generating flashcard:', response.error); return; }

                     const flashcardText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '';
                     try {
                         // Find the JSON part more reliably
                         const jsonMatch = flashcardText.match(/\{[\s\S]*\}/);
                         if (jsonMatch) {
                             const flashcardData = JSON.parse(jsonMatch[0]);
                             // Basic validation
                             if (flashcardData && flashcardData.word && flashcardData.phrase && flashcardData.translation_answer) {
                                showFlashcardToast(flashcardData);
                             } else {
                                 console.warn('Parsed flashcard JSON missing required fields:', flashcardData);
                             }
                         } else {
                              console.warn('Could not find valid JSON in flashcard response:', flashcardText);
                         }
                     } catch (jsonError) {
                         console.error('Error parsing flashcard JSON:', jsonError, flashcardText);
                     }
                 } catch (error) {
                     console.error('Error in generateFlashcard function:', error);
                 }
             }


            function formatTranslation(translation) {
                const parts = translation.split('\n');
                if (parts.length > 1) return `<b>${escapeHTML(parts[0])}</b><br><i>${escapeHTML(parts.slice(1).join('; '))}</i>`; // Join definitions with semicolon
                return `<b>${escapeHTML(translation)}</b>`; // Default if only one line
            }

             function showFlashcardToast(flashcardData) {
                 const existingToast = document.querySelector('.flashcard-toast');
                 if (existingToast) existingToast.remove(); // Remove previous toast immediately

                 const toast = document.createElement('div');
                 toast.className = 'flashcard-toast visible'; // Start visible

                 toast.innerHTML = `
                     <div class="flashcard-header">
                         <div class="flashcard-word">${escapeHTML(flashcardData.word)}</div>
                         <button type="button" class="flashcard-close-btn" aria-label="Close">×</button>
                     </div>
                     <div class="flashcard-translation">${formatTranslation(flashcardData.translation_answer)}</div>
                     <div class="flashcard-actions">
                         <button type="button" class="flashcard-speak-btn" aria-label="Speak">🔊</button>
                         <button type="button" class="flashcard-save-btn">Save</button>
                     </div>`;

                 document.body.appendChild(toast);

                 // Position the toast relative to the selection if possible
                 if (state.lastSelectionRect) {
                     const toastRect = toast.getBoundingClientRect(); // Get size after adding to DOM
                     const selRect = state.lastSelectionRect;
                     const viewportWidth = window.innerWidth;
                     const viewportHeight = window.innerHeight;
                     const margin = 10;

                      let top = selRect.bottom + margin;
                      let left = selRect.left + (selRect.width / 2) - (toastRect.width / 2);

                      // Adjust horizontal
                      left = Math.max(margin, Math.min(left, viewportWidth - toastRect.width - margin));

                      // Adjust vertical
                      if (top + toastRect.height > viewportHeight - margin) {
                           top = selRect.top - toastRect.height - margin; // Try above
                      }
                      // Ensure it's not off-screen top
                      top = Math.max(margin, top);


                     toast.style.position = 'fixed'; // Ensure fixed positioning
                     toast.style.top = `${top}px`;
                     toast.style.left = `${left}px`;
                     toast.style.bottom = 'auto'; // Override default bottom/right
                     toast.style.right = 'auto';
                 } else {
                     // Fallback to default bottom-right position
                     toast.style.bottom = "20px";
                     toast.style.right = "20px";
                     toast.style.top = 'auto';
                     toast.style.left = 'auto';
                 }


                 const removeToast = () => {
                     toast.classList.add('fade-out');
                     setTimeout(() => {
                         if (toast.parentNode) toast.parentNode.removeChild(toast);
                     }, 500);
                 };

                 toast.querySelector('.flashcard-close-btn').addEventListener('click', removeToast);
                 toast.querySelector('.flashcard-speak-btn').addEventListener('click', () => speakText(flashcardData.word));

                 const autoSpeakEnabled = localStorage.getItem('auto-speak-enabled') !== 'false';
                 const speakSelectionEnabled = state.settings.speakSelectionEnabled;
                 if (autoSpeakEnabled && !speakSelectionEnabled) {
                     setTimeout(() => speakText(flashcardData.word), 300);
                 }

                 toast.querySelector('.flashcard-save-btn').addEventListener('click', async () => {
                     const saveButton = toast.querySelector('.flashcard-save-btn');
                     saveButton.textContent = 'Saving...';
                     saveButton.disabled = true;
                     const { data: { session } } = await supabase.auth.getSession();
                     if (!session) { showToast('Please sign in to save flashcards'); saveButton.textContent = 'Save'; saveButton.disabled = false; return; }
                     try {
                         // Use upsert to avoid duplicates based on word and user_id
                         const { error } = await supabase.from('flashcards').upsert({
                             user_id: session.user.id,
                             word: flashcardData.word, // Primary key part 1
                             phrase: flashcardData.phrase,
                             translation_answer: flashcardData.translation_answer,
                             state: "new", // Default state
                             due: new Date().toISOString(), // Default due date
                             // Default FSRS parameters (adjust as needed)
                             stability: 0.5,
                             difficulty: 5,
                             elapsed_days: 0,
                             scheduled_days: 0,
                             reps: 0,
                             lapses: 0
                         }, { onConflict: 'user_id, word' }); // Define conflict target

                         if (error) throw error;
                         saveButton.textContent = 'Saved!';
                         setTimeout(removeToast, 1000); // Remove after save confirmation
                     } catch (error) {
                         console.error('Error saving/upserting flashcard:', error);
                         saveButton.textContent = 'Failed';
                          showToast(`Save failed: ${error.message}`, 3000);
                         setTimeout(() => { saveButton.textContent = 'Retry'; saveButton.disabled = false; }, 1500);
                     }
                 });

                 // Auto-remove toast after a longer delay
                 setTimeout(removeToast, 20000);
             }

            function speakText(text) {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel(); // Stop previous speech
                    const utterance = new SpeechSynthesisUtterance(text);
                    const language = localStorage.getItem('speech-language') || 'en-US';
                    utterance.lang = language;

                    // Attempt to select a voice matching the language
                    const voices = window.speechSynthesis.getVoices();
                    let selectedVoice = voices.find(voice => voice.lang === language); // Exact match first
                    if (!selectedVoice) {
                         selectedVoice = voices.find(voice => voice.lang.startsWith(language.split('-')[0])); // Match primary language
                    }
                     if (!selectedVoice && language.startsWith('en')) { // Fallback for English variants
                         selectedVoice = voices.find(voice => voice.lang.startsWith('en-'));
                     }
                    if (selectedVoice) {
                        utterance.voice = selectedVoice;
                         // console.log(`Using voice: ${selectedVoice.name} (${selectedVoice.lang})`);
                    } else {
                         console.warn(`No voice found for language: ${language}. Using default.`);
                    }

                    utterance.rate = 0.9; // Slightly slower
                    utterance.pitch = 1.0;
                    window.speechSynthesis.speak(utterance);
                } else {
                    console.error('Text-to-speech not supported in this browser');
                    showToast('Text-to-speech not supported in this browser');
                }
            }
            // Ensure voices are loaded (needed for some browsers)
            if ('speechSynthesis' in window && window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = () => { window.speechSynthesis.getVoices(); };
            }


            async function saveUserPreferences() {
                 const preferences = {
                     fontSize: state.settings.fontSize,
                     lineHeight: state.settings.lineHeight,
                     theme: state.settings.theme,
                     viewRawHtmlEnabled: state.settings.viewRawHtmlEnabled,
                     translationEnabled: DOM.translationToggle.checked,
                     autoSpeakEnabled: DOM.autoSpeakToggle.checked,
                     speakSelectionEnabled: state.settings.speakSelectionEnabled,
                     speechLanguage: DOM.speechLanguage.value
                 };

                 // Save to localStorage immediately for persistence
                 for (const key in preferences) {
                     localStorage.setItem(`ebook-${key.toLowerCase().replace(/enabled/,'')}`, preferences[key]);
                 }
                  localStorage.setItem('ebook-viewrawhtml', preferences.viewRawHtmlEnabled); // Keep separate key for raw view maybe


                 // Save to Supabase if logged in
                 const { data: { session } } = await supabase.auth.getSession();
                 if (!session) return;

                 try {
                     const { error } = await supabase
                         .from('user_settings')
                         .update({ preferences: preferences }) // Update the JSONB column
                         .eq('user_id', session.user.id);

                     if (error) {
                          // If the row doesn't exist (e.g., new user), try inserting
                          if (error.code === 'PGRST116') { // Code for "JSON object requested, multiple (or no) rows returned"
                              const { error: insertError } = await supabase
                                  .from('user_settings')
                                  .insert({ user_id: session.user.id, preferences: preferences });
                              if (insertError) throw insertError; // Throw insert error if it fails
                          } else {
                              throw error; // Throw original update error
                          }
                      }
                 } catch (error) {
                     console.error('Error saving user preferences to DB:', error);
                      // Don't show toast for background saves unless critical
                 }
             }


             async function loadUserPreferences() {
                 // Load from localStorage first as defaults/fallback
                 state.settings.fontSize = parseInt(localStorage.getItem('ebook-fontsize') || '100', 10);
                 state.settings.lineHeight = parseFloat(localStorage.getItem('ebook-lineheight') || '1.6');
                 state.settings.theme = localStorage.getItem('ebook-theme') || 'dark';
                 state.settings.viewRawHtmlEnabled = localStorage.getItem('ebook-viewrawhtml') === 'true';
                 state.settings.speakSelectionEnabled = localStorage.getItem('ebook-speakselection') === 'true';

                 DOM.translationToggle.checked = localStorage.getItem('ebook-translation') !== 'false';
                 DOM.autoSpeakToggle.checked = localStorage.getItem('ebook-autospeak') !== 'false';
                 DOM.speechLanguage.value = localStorage.getItem('ebook-speechlanguage') || 'en-US';

                 // Apply initial settings loaded from localStorage
                 updateFontSize();
                 updateLineHeight();
                 setTheme(state.settings.theme);
                 DOM.viewRawHtmlToggle.checked = state.settings.viewRawHtmlEnabled;
                 DOM.speakSelectionToggle.checked = state.settings.speakSelectionEnabled;

                 // Attempt to load from Supabase if logged in
                 const { data: { session } } = await supabase.auth.getSession();
                 if (!session) return; // Don't try loading from DB if not logged in

                 try {
                     const { data, error } = await supabase
                         .from('user_settings')
                         .select('preferences')
                         .eq('user_id', session.user.id)
                         .maybeSingle(); // Use maybeSingle to handle no settings row gracefully

                     if (error) {
                         console.error('Error loading user preferences from DB:', error);
                         return; // Use localStorage values if DB load fails
                     }

                     if (data && data.preferences) {
                         const prefs = data.preferences;
                         console.log("Loaded preferences from DB:", prefs);

                         // Override localStorage with DB values if they exist
                         if (prefs.fontSize !== undefined) state.settings.fontSize = prefs.fontSize;
                         if (prefs.lineHeight !== undefined) state.settings.lineHeight = prefs.lineHeight;
                         if (prefs.theme) state.settings.theme = prefs.theme;
                         if (prefs.viewRawHtmlEnabled !== undefined) state.settings.viewRawHtmlEnabled = prefs.viewRawHtmlEnabled;
                         if (prefs.speakSelectionEnabled !== undefined) state.settings.speakSelectionEnabled = prefs.speakSelectionEnabled;
                         if (prefs.translationEnabled !== undefined) DOM.translationToggle.checked = prefs.translationEnabled;
                         if (prefs.autoSpeakEnabled !== undefined) DOM.autoSpeakToggle.checked = prefs.autoSpeakEnabled;
                         if (prefs.speechLanguage) DOM.speechLanguage.value = prefs.speechLanguage;

                         // Re-apply settings from DB values
                         updateFontSize();
                         updateLineHeight();
                         setTheme(state.settings.theme);
                         DOM.viewRawHtmlToggle.checked = state.settings.viewRawHtmlEnabled;
                         DOM.speakSelectionToggle.checked = state.settings.speakSelectionEnabled;
                         // Checkbox and select values are already updated directly above

                          // Persist the potentially merged settings back to localStorage
                          saveUserPreferences(); // This ensures localStorage matches DB or initial defaults
                     } else {
                          // No settings found in DB, save current (localStorage or default) settings to DB
                          console.log("No preferences found in DB for user, saving current settings.");
                          saveUserPreferences();
                     }

                 } catch (error) {
                     console.error('Exception loading/processing user preferences:', error);
                 }
             }


            async function generateTitleAndCategory(content, modelName) {
                 if (!state.userApiSettings || !state.userApiSettings.api_key) { console.warn("Gemini API key not available for title/category generation."); return { generatedTitle: null, listId: null }; }
                 if (!state.bookLists) { console.warn("Book lists not loaded yet for categorization."); } // Check if lists are loaded

                 const maxContentLength = 5000;
                 const truncatedContent = content.length > maxContentLength ? content.substring(0, maxContentLength) + "..." : content;

                 // Ensure list options are correctly formatted, handle empty list case
                 const listOptions = (state.bookLists && state.bookLists.length > 0)
                     ? state.bookLists.map(list => `- ${list.name} (ID: ${list.id})`).join('\n')
                     : "No lists available.";

                 const prompt = `Analyze the following text content scraped from a webpage.\n\nContent Snippet:\n---\n${truncatedContent}\n---\n\nBased on the content, perform the following tasks:\n1.  **Generate a concise and relevant title** for this content (max 10 words).\n2.  **Categorize the content** into ONE of the following existing lists. Choose the list that best fits the topic. If none fit well, choose null.\n\nAvailable Lists:\n${listOptions}\n- Unlisted (ID: null)\n\nReturn the result ONLY in this exact JSON format. The value for "list_id" MUST be either the numeric ID of the chosen list (e.g., 6) or the literal value null (not the string "null"). Do not include the list name in the "list_id" field.\n\nExample Output 1:\n{\n  "title": "Example Title About AI",\n  "list_id": 6 \n}\n\nExample Output 2 (if no list fits):\n{\n  "title": "Example Title About Something Else",\n  "list_id": null\n}\n\nActual Output JSON:\n`; // Removed the potentially confusing last line structure

                 const modelToUse = modelName || state.userApiSettings?.model || 'gemini-1.5-flash-latest';

                 try {
                     const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);
                     if (response.error) throw new Error(response.error.message);

                     const resultText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
                     let parsedResult = { title: null, list_id: null }; // Default

                     try {
                         // Find JSON block more reliably
                         const jsonMatch = resultText.match(/\{[\s\S]*\}/);
                         if (jsonMatch) {
                             parsedResult = JSON.parse(jsonMatch[0]);
                         } else {
                             console.warn("AI did not return valid JSON for title/category.", resultText);
                         }
                     } catch (jsonError) {
                         console.error('Error parsing title/category JSON:', jsonError, resultText);
                         // Keep default parsedResult
                     }

                     // Validate and sanitize list_id
                     let listId = parsedResult.list_id;
                      if (listId === 'null' || listId === undefined) { // Check for string "null" or undefined
                         listId = null;
                     } else if (typeof listId === 'string' && !isNaN(parseInt(listId, 10))) {
                         listId = parseInt(listId, 10); // Convert numeric string to number
                     } else if (typeof listId !== 'number' && listId !== null) { // Allow null or number
                          console.warn(`Received unexpected list_id type: ${typeof listId}, value: ${listId}. Defaulting to null.`);
                         listId = null;
                     }
                      // Ensure the listId actually exists in the user's lists or is null
                      if(listId !== null && !state.bookLists.some(l => l.id === listId)) {
                         console.warn(`AI returned list_id ${listId} which does not exist. Defaulting to null.`);
                         listId = null;
                      }


                     return {
                         generatedTitle: (typeof parsedResult.title === 'string' ? parsedResult.title.trim() : null) || null, // Ensure title is string or null
                         listId: listId // Use sanitized listId
                     };

                 } catch (error) {
                     console.error('Error generating title and category:', error);
                     showToast(`AI title/category generation failed: ${error.message}`, 4000);
                     return { generatedTitle: null, listId: null }; // Return default on error
                 }
             }


             // AI feature: Summarize Chapter
            async function summarizeCurrentChapter() {
                 if (!state.userApiSettings || !state.userApiSettings.api_key) {
                     showToast("Gemini API key needed for summarization. Configure in dashboard.", 4000);
                     checkAuthAndLoadApiSettings();
                     return;
                 }

                 const chapter = state.bookData.chapters[state.bookData.currentPosition];
                 if (!chapter) { showToast("No chapter loaded to summarize.", 2000); return; }

                 // Prioritize Markdown content for summary context
                 const contentToSummarize = chapter.markdownContent || chapter.content || '';
                 if (!contentToSummarize.trim()) { showToast("Chapter content is empty, cannot summarize.", 2000); return; }

                 DOM.aiResponseArea.style.display = 'block';
                 DOM.aiResponseArea.innerHTML = '<p>Generating summary...</p>'; // Use innerHTML for potential styling
                 DOM.summarizeChapterBtn.disabled = true;
                 DOM.summarizeChapterBtn.classList.add('loading');

                 try {
                     const maxContentLength = 15000;
                     const truncatedContent = contentToSummarize.length > maxContentLength
                         ? contentToSummarize.substring(0, maxContentLength) + "\n... [Content Truncated]"
                         : contentToSummarize;

                     const prompt = `Summarize the following text from a book chapter titled "${chapter.title}":\n\n---\n${truncatedContent}\n---\n\nProvide a concise summary (about 3-5 sentences). Focus on the key points and main ideas presented in the text. Use basic Markdown for clarity (bold, italics).`;

                     const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                     const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);

                     if (response.error) throw new Error(response.error.message);

                     const summary = response?.candidates?.[0]?.content?.parts?.[0]?.text || 'Failed to generate summary.';
                      // Use the custom Markdown parser for the summary
                      DOM.aiResponseArea.innerHTML = markdownToHtml(summary);

                 } catch (error) {
                     console.error('Error generating summary:', error);
                     DOM.aiResponseArea.innerHTML = `<p>An error occurred: ${escapeHTML(error.message)}</p>`;
                 } finally {
                     DOM.summarizeChapterBtn.disabled = false;
                     DOM.summarizeChapterBtn.classList.remove('loading');
                     // Scroll the settings panel to show the response area if needed
                     DOM.settingsPanel.scrollTop = DOM.settingsPanel.scrollHeight;
                 }
            }


            return { init };
        })();

        document.addEventListener('DOMContentLoaded', function() {
            EbookApp.init();
        });

        function calculateOverallProgress(book) {
            if (!book || !book.last_position) return 0;

            const lastPos = book.last_position;
            const totalChapters = (book.metadata?.chapters?.length) || 1; // Assume 1 chapter if metadata missing
            const currentChapterIndex = lastPos.chapter !== undefined ? lastPos.chapter : 0;
            const chapterProgress = lastPos.percentComplete !== undefined ? lastPos.percentComplete : 0;

            // Clamp values to avoid errors
            const validTotalChapters = Math.max(1, totalChapters);
            const validCurrentChapterIndex = Math.max(0, Math.min(currentChapterIndex, validTotalChapters - 1));
            const validChapterProgress = Math.max(0, Math.min(1, chapterProgress));

            let overallProgress = 0;
            if (validTotalChapters > 0) {
                 overallProgress = (validCurrentChapterIndex / validTotalChapters) + (validChapterProgress / validTotalChapters);
            }

             // Ensure progress doesn't exceed 100% if the last chapter is fully read
             overallProgress = Math.min(1, overallProgress);

            return Math.round(overallProgress * 100);
        }
    </script>
</body>
</html>