<!-- Never write comments  -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Ebook Reader</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --light-bg: #f8f8f8;
            --light-text: #333;
            --light-panel-bg: #fff;
            --light-border: #eee;
            --light-panel-shadow: rgba(0, 0, 0, 0.08);
            --light-highlight: rgba(66, 133, 244, 0.3);

            --sepia-bg: #f8f1e3;
            --sepia-text: #5f4b32;
            --sepia-panel-bg: #f7f0e0;
            --sepia-border: rgba(95, 75, 50, 0.15);
            --sepia-panel-shadow: rgba(95, 75, 50, 0.1);
            --sepia-highlight: rgba(210, 180, 140, 0.3);

            --dark-bg: #222;
            --dark-text: #e0e0e0;
            --dark-panel-bg: #333;
            --dark-border: #444;
            --dark-panel-shadow: rgba(0, 0, 0, 0.2);
            --dark-highlight: rgba(66, 133, 244, 0.4);

            --primary-color: #4285f4;
            --success-color: #34a853;
            --danger-color: #d93025;
            --panel-radius: 12px;

            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
            --reader-line-height: 1.6;
        }

        body.light-theme {
            --bg-color: var(--light-bg);
            --text-color: var(--light-text);
            --panel-bg: var(--light-panel-bg);
            --border-color: var(--light-border);
            --panel-shadow: var(--light-panel-shadow);
            --highlight-color: var(--light-highlight);
            --input-bg: rgba(0, 0, 0, 0.05);
            --select-bg: rgba(0, 0, 0, 0.05);
            --modal-backdrop-color: rgba(0, 0, 0, 0.4);
            --text-muted: #666;
        }

        body.sepia-theme {
            --bg-color: var(--sepia-bg);
            --text-color: var(--sepia-text);
            --panel-bg: var(--sepia-panel-bg);
            --border-color: var(--sepia-border);
            --panel-shadow: var(--sepia-panel-shadow);
            --highlight-color: var(--sepia-highlight);
            --input-bg: rgba(95, 75, 50, 0.05);
            --select-bg: rgba(95, 75, 50, 0.05);
            --modal-backdrop-color: rgba(95, 75, 50, 0.4);
            --text-muted: #8c7a64;
        }

        body.dark-theme {
            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
            --input-bg: rgba(255, 255, 255, 0.05);
            --select-bg: rgba(255, 255, 255, 0.05);
            --modal-backdrop-color: rgba(0, 0, 0, 0.6);
            --text-muted: rgba(224, 224, 224, 0.7);
        }

        .hidden {
            display: none !important;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        ::selection {
            background-color: var(--highlight-color);
        }

        html {
            font-size: 16px;
        }

        @media (max-width: 768px) {
            html {
                font-size: 14px;
            }
        }

        #app {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
        }

        #welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background-color: var(--bg-color);
            z-index: 100;
            padding: 3vh 1rem 1rem;
            overflow-y: auto;
        }

        #welcome-screen h1 {
            margin-bottom: 1.5rem;
            text-align: center;
            font-size: 2.2rem;
        }

        .welcome-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            max-width: 650px;
            padding: 1rem;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .welcome-actions {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-top: 1rem;
            width: 100%;
            align-items: center;
        }

        .main-actions {
             display: flex;
             gap: 1rem;
             justify-content: center;
             flex-wrap: wrap;
             width: 100%;
        }

        #library-section {
            width: 100%;
            max-width: 600px;
            margin-top: 2.5rem;
            background-color: var(--panel-bg);
            border-radius: 8px;
            box-shadow: 0 2px 8px var(--panel-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #list-management {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            gap: 1rem;
            flex-wrap: wrap;
        }

        #list-filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #list-filter {
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.9rem;
        }

        #create-list-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        #new-list-name {
            display: none;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 0.9rem;
            flex: 1;
            margin-right: 0.5rem;
        }

        #create-list-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            min-width: 40px;
            height: 34px;
            line-height: 1;
            text-align: center;
        }

        #list-controls-wrapper {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            flex-shrink: 0;
            padding: 1.25rem 1.25rem 0.5rem;
        }

        #list-badge-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            flex-grow: 1;
        }

        .list-badge {
            padding: 0.3rem 0.8rem;
            border-radius: 12px;
            font-size: 0.85rem;
            cursor: pointer;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            white-space: nowrap;
        }

        .list-badge:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .list-badge.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            font-weight: 500;
        }

        .list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.2); border-color: rgba(52, 168, 83, 0.4); color: #6fbf73; }
        .list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.2); border-color: rgba(251, 188, 5, 0.4); color: #fdd663; }
        .list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.2); border-color: rgba(234, 67, 53, 0.4); color: #f28b82; }
        .list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.2); border-color: rgba(66, 133, 244, 0.4); color: #8ab4f8; }
        .list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.2); border-color: rgba(156, 39, 176, 0.4); color: #c58af9; }

        body.light-theme .list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.1); border-color: rgba(52, 168, 83, 0.2); color: #0d652d; }
        body.light-theme .list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.1); border-color: rgba(251, 188, 5, 0.2); color: #995200; }
        body.light-theme .list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.1); border-color: rgba(234, 67, 53, 0.2); color: #940a0a; }
        body.light-theme .list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.1); border-color: rgba(66, 133, 244, 0.2); color: #0b57d0; }
        body.light-theme .list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.1); border-color: rgba(156, 39, 176, 0.2); color: #58117a; }

        .list-badge.active[data-color-index="0"],
        .list-badge.active[data-color-index="1"],
        .list-badge.active[data-color-index="2"],
        .list-badge.active[data-color-index="3"],
        .list-badge.active[data-color-index="4"] {
             background-color: var(--primary-color);
             border-color: var(--primary-color);
             color: white;
        }

        #create-list-group {
            flex-shrink: 0;
        }

        #new-list-name {
            width: 150px;
        }

        #create-list-btn {
        }

        #ai-cleanup-btn {
            padding: 0.4rem;
            font-size: 1.1rem;
            min-width: 34px;
            width: 34px;
            height: 34px;
            line-height: 1;
            margin-left: 0.5rem;
        }

        #library-list {
            flex: 1 1 auto;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            padding: 0 1.25rem 1.25rem;
            min-height: 0;
            position: relative;
            max-height: calc(100% - 50px);
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }

        #library-list::-webkit-scrollbar {
            width: 8px;
        }

        #library-list::-webkit-scrollbar-track {
            background: transparent;
        }

        #library-list::-webkit-scrollbar-thumb {
            background-color: rgba(155, 155, 155, 0.5);
            border-radius: 4px;
            border: 2px solid transparent;
        }

        #library-list::-webkit-scrollbar-thumb:hover {
            background-color: rgba(155, 155, 155, 0.8);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .input-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .input-field,
        .select-field {
            flex: 1;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            font-size: 1rem;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .input-field:focus,
        .select-field:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color), 0.2);
        }

        #text-input {
            width: 100%;
            min-height: 120px;
            margin-bottom: 0;
        }

        #toggle-text-input-container {
            text-align: center;
            margin-top: 0.5rem;
        }

        #toggle-text-input {
            font-size: 0.9rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        #toggle-text-input:hover {
            text-decoration: underline;
        }

        #text-input-container {
            width: 100%;
        }

        .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1rem;
            margin-bottom: 0.6rem;
            background-color: transparent;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .library-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .library-item-details {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }

        .library-item-title {
            display: inline;
            font-weight: 500;
            /* margin-bottom: 0.25rem; /* Handled by container */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1; /* Allow title to take space */
        }

        .library-item-list-badge {
            font-size: 0.65rem;
            padding: 0.1rem 0.4rem;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            margin-left: 0.5rem;
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0;
        }
        .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.15); border: 1px solid rgba(52, 168, 83, 0.3); color: #6fbf73; }
        .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.15); border: 1px solid rgba(251, 188, 5, 0.3); color: #fdd663; }
        .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.15); border: 1px solid rgba(234, 67, 53, 0.3); color: #f28b82; }
        .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.15); border: 1px solid rgba(66, 133, 244, 0.3); color: #8ab4f8; }
        .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.15); border: 1px solid rgba(156, 39, 176, 0.3); color: #c58af9; }

        body.light-theme .library-item-list-badge[data-color-index="0"] { background-color: rgba(52, 168, 83, 0.1); border-color: rgba(52, 168, 83, 0.2); color: #0d652d; }
        body.light-theme .library-item-list-badge[data-color-index="1"] { background-color: rgba(251, 188, 5, 0.1); border-color: rgba(251, 188, 5, 0.2); color: #995200; }
        body.light-theme .library-item-list-badge[data-color-index="2"] { background-color: rgba(234, 67, 53, 0.1); border-color: rgba(234, 67, 53, 0.2); color: #940a0a; }
        body.light-theme .library-item-list-badge[data-color-index="3"] { background-color: rgba(66, 133, 244, 0.1); border-color: rgba(66, 133, 244, 0.2); color: #0b57d0; }
        body.light-theme .library-item-list-badge[data-color-index="4"] { background-color: rgba(156, 39, 176, 0.1); border-color: rgba(156, 39, 176, 0.2); color: #58117a; }

        .library-item-title-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
            min-width: 0; /* Prevent overflow issues with flex children */
        }

        .library-item-meta {
            font-size: 0.75rem;
            color: rgba(var(--text-color), 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .library-item-move {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            margin-right: 0.5rem;
            transition: background-color 0.2s;
        }
        .library-item-move:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .move-list-dropdown {
            position: absolute;
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 2px 8px var(--panel-shadow);
            z-index: 10;
            min-width: 150px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            margin-top: 2px;
            right: 0;
        }

        .move-list-dropdown.visible {
            display: block;
        }

        .move-list-option {
            padding: 0.5rem 0.8rem;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-bottom: 1px solid var(--border-color);
        }
        .move-list-option:last-child {
            border-bottom: none;
        }

        .move-list-option:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .move-list-option.disabled {
            color: var(--text-muted);
            cursor: default;
            background-color: transparent;
        }


        .progress-bar-container {
            height: 4px;
            background-color: rgba(var(--text-color), 0.1);
            border-radius: 2px;
            margin-top: 0.3rem;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .library-item-actions {
            display: flex;
            gap: 0.5rem;
            margin-left: 0.5rem;
            flex-shrink: 0;
        }

        .library-item-delete {
            color: var(--danger-color);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.125rem;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
        }

        .library-item-delete:hover {
            background-color: rgba(217, 48, 37, 0.1);
        }

        .auth-section {
            margin-top: 1.875rem;
            text-align: center;
        }

        .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 0.8rem 1.6rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 1px 3px var(--panel-shadow);
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
        }

        .button:hover {
            background-color: #3367d6;
            box-shadow: 0 2px 6px var(--panel-shadow);
        }

        .button:active {
            transform: translateY(1px);
        }

        .button-secondary {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            box-shadow: none;
        }

        .button-secondary:hover {
            background-color: rgba(66, 133, 244, 0.1);
            border-color: #3367d6;
            box-shadow: none;
        }

        body.light-theme .button-secondary {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }
        body.light-theme .button-secondary:hover {
            background-color: rgba(66, 133, 244, 0.05);
            border-color: #0b57d0;
        }

        .button.loading {
            position: relative;
            color: transparent !important;
            pointer-events: none;
        }

        .button.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1rem;
            height: 1rem;
            margin-top: -0.5rem;
            margin-left: -0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: button-spin 0.8s linear infinite;
        }

        @keyframes button-spin {
            to { transform: rotate(360deg); }
        }

        .success-button {
            background-color: var(--success-color);
        }

        .success-button:hover {
            background-color: #2e9549;
        }

        .example-book-section {
            margin-top: 1.875rem;
            text-align: center;
            padding: 1.25rem;
            background-color: rgba(66, 133, 244, 0.1);
            border-radius: 8px;
            margin-bottom: 1.25rem;
        }

        .example-book-section p {
            margin-bottom: 0.75rem;
        }

        #navbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3.5rem;
            background-color: var(--panel-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            z-index: 20;
        }

        #navbar.visible {
            transform: translateY(0);
        }

        #book-title {
            font-size: 1.125rem;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 40%;
        }

        #navbar-buttons {
            display: flex;
            gap: 1rem;
        }

        .navbar-btn {
            background-color: transparent;
            border: none;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
            font-size: 1.25rem;
            transition: background-color 0.2s;
        }

        .navbar-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #reader-container {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #content-area {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
            padding-top: 2rem;
            padding-bottom: 4rem;
            -webkit-overflow-scrolling: touch;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
            transition: background-color 0.3s ease, color 0.3s ease;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: var(--reader-line-height);
            font-size: calc(1rem * var(--settings-font-size, 1));
            font-family: inherit;
            word-wrap: break-word;
            position: relative;
        }

        #content-area img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1rem auto;
            border-radius: 4px;
        }

        #content-area p {
            margin-bottom: 1rem;
        }

        #content-area h1,
        #content-area h2,
        #content-area h3,
        #content-area h4,
        #content-area h5,
        #content-area h6 {
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            line-height: 1.4;
            padding-bottom: 0.2em;
            border-bottom: 1px solid var(--border-color);
        }

        #content-area h1 { font-size: 1.3em; border-bottom-width: 2px; }
        #content-area h2 { font-size: 1.2em; }
        #content-area h3 { font-size: 1.1em; border-bottom: none;}
        #content-area h4, #content-area h5, #content-area h6 { font-size: 1em; border-bottom: none; }

        #content-area ul,
        #content-area ol {
            margin-bottom: 1rem;
            padding-left: 1.5em;
        }

        #content-area li {
            margin-bottom: 0.5rem;
        }
        #content-area li > p {
             margin-bottom: 0;
        }
        #content-area li > ul,
        #content-area li > ol {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        #content-area blockquote {
            margin-left: 1em;
            margin-right: 1em;
            margin-bottom: 1rem;
            padding: 0.5em 1em;
            border-left: 3px solid var(--primary-color);
            background-color: rgba(255, 255, 255, 0.03);
            color: var(--text-muted, rgba(224, 224, 224, 0.8));
            font-style: italic;
        }
        body.light-theme #content-area blockquote { background-color: rgba(0, 0, 0, 0.03); color: var(--text-muted, #555); }
        body.sepia-theme #content-area blockquote { background-color: rgba(95, 75, 50, 0.04); color: var(--text-muted, #7a6853); }

         #content-area blockquote p {
              margin-bottom: 0.5rem;
         }
         #content-area blockquote p:last-child {
              margin-bottom: 0;
         }

        #content-area code {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }
        body.light-theme #content-area code { background-color: rgba(0, 0, 0, 0.05); }
        body.sepia-theme #content-area code { background-color: rgba(95, 75, 50, 0.08); }


        #content-area pre {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0.8em 1em;
            border-radius: 4px;
            overflow-x: auto;
            margin-bottom: 1rem;
            font-family: monospace;
            line-height: 1.4;
            border: 1px solid var(--border-color);
        }
        body.light-theme #content-area pre { background-color: rgba(0, 0, 0, 0.03); border: 1px solid #ddd; }
        body.sepia-theme #content-area pre { background-color: rgba(95, 75, 50, 0.05); border: 1px solid rgba(95, 75, 50, 0.1); }


        #content-area pre code {
            background-color: transparent;
            padding: 0;
            font-size: inherit;
            border: none;
        }

        #content-area hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 1.5rem 0;
        }

        #settings-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--panel-bg);
            padding: 1.5rem;
            border-top-left-radius: var(--panel-radius);
            border-top-right-radius: var(--panel-radius);
            box-shadow: 0 -2px 10px var(--panel-shadow);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 30;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.25rem;
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-grid > .settings-section {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        #settings-panel > .settings-grid:last-of-type {
             border-bottom: none;
        }

        #settings-panel.visible {
            transform: translateY(0);
        }

        .settings-section {
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .settings-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
        }

        #ai-settings-content {
            margin-bottom: 1rem;
        }

        .settings-row.ai-toggle {
            margin-top: 0.75rem;
        }

        #ai-response-area {
            display: none; /* Controlled by JS */
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            padding: 0.75rem;
            margin-top: 0.75rem;
            font-size: 0.875rem;
            max-height: 12.5rem; /* From CSS, inline style had 15rem */
            overflow-y: auto;
            border: 1px solid var(--border-color);
        }
        #ai-response-area p { margin-bottom: 0.5rem; }
        #ai-response-area ul, #ai-response-area ol { padding-left: 1.2em; margin-bottom: 0.5rem; }
        #ai-response-area li { margin-bottom: 0.25rem; }
        #ai-response-area strong { font-weight: bold; }
        #ai-response-area em { font-style: italic; }


        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .font-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
        }

        .theme-options {
            display: flex;
            gap: 1rem;
        }

        .theme-option {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .theme-option.active {
            border-color: var(--primary-color);
        }

        .light-option {
            background-color: var(--light-bg);
            border: 1px solid var(--light-border);
        }

        .sepia-option {
            background-color: var(--sepia-bg);
        }

        .dark-option {
            background-color: var(--dark-bg);
        }

        #nav-controls {
            position: fixed;
            bottom: 1.25rem;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 1.25rem;
            pointer-events: none;
            z-index: 15;
        }

        .nav-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background-color: var(--panel-bg);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transition: background-color 0.2s;
        }

        .nav-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        #toc-panel {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 80%;
            max-width: 20rem;
            background-color: var(--panel-bg);
            z-index: 30;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px var(--panel-shadow);
        }

        #toc-panel.visible {
            transform: translateX(0);
        }

        #toc-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #toc-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
        }

        .toc-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .toc-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .toc-item.toc-active {
            font-weight: bold;
            background-color: rgba(var(--primary-color), 0.1);
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.4);
            z-index: 25;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #overlay.visible {
            display: block;
            opacity: 1;
        }

        #progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background-color: var(--primary-color);
            transition: width 0.2s ease;
            z-index: 10;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #loading.visible {
            display: flex;
            opacity: 1;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-left-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #translation-popup {
            position: fixed;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            padding: 16px;
            min-width: 220px;
            max-width: 320px;
            z-index: 100;
            display: none;
            border: 1px solid rgba(0,0,0,0.08);
            transform: translateY(10px);
            opacity: 0;
            transition: transform 0.2s ease, opacity 0.2s ease;
            font-style: italic;
            color: #4285f4;
        }

        #translation-popup.visible {
            transform: translateY(0);
            opacity: 1;
        }

        body.light-theme #translation-popup {
            background-color: #ffffff;
            color: #4285f4;
        }

        body.sepia-theme #translation-popup {
            background-color: #f7f0e0;
            color: #4285f4;
            border-color: rgba(95, 75, 50, 0.15);
        }

        body.dark-theme #translation-popup {
            background-color: #2d2d2d;
            color: #4285f4;
            border-color: rgba(255,255,255,0.1);
        }

        #translation-popup:before {
            content: '';
            position: absolute;
            top: -8px;
            left: 20px;
            width: 14px;
            height: 14px;
            background-color: inherit;
            border-top: 1px solid rgba(0,0,0,0.08);
            border-left: 1px solid rgba(0,0,0,0.08);
            transform: rotate(45deg);
        }

        body.dark-theme #translation-popup:before {
            border-color: rgba(255,255,255,0.1);
        }

        body.sepia-theme #translation-popup:before {
            border-color: rgba(95, 75, 50, 0.15);
        }

        #translation-content {
            margin-bottom: 10px;
            font-size: 15px;
            line-height: 1.5;
        }

        #translation-loading {
            display: none;
            align-items: center;
            justify-content: center;
            height: 30px;
        }

        #translation-loading .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-left-color: #4285f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        body.dark-theme #translation-loading .spinner {
            border-color: rgba(255,255,255,0.1);
            border-left-color: #4285f4;
        }

        .flashcard-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            padding: 8px 12px;
            width: 240px;
            z-index: 1000;
            font-size: 14px;
            opacity: 1;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        body.dark-theme .flashcard-toast {
            background-color: #333;
            color: #e0e0e0;
        }

        .flashcard-toast.visible {
            display: block;
        }

        .flashcard-toast.fade-out {
            opacity: 0;
            transform: translateY(10px);
        }

        .flashcard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .flashcard-close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #888;
            padding: 0;
            margin: 0;
        }

        .flashcard-word {
            font-weight: bold;
            font-size: 16px;
        }

        .flashcard-translation {
            margin-bottom: 8px;
            line-height: 1.3;
            font-size: 13px;
        }

        .flashcard-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .flashcard-speak-btn {
            background-color: #34a853;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 0 0 auto;
        }

        .flashcard-save-btn {
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 1;
        }

        .flashcard-save-btn:disabled {
            background-color: #a4c2f4;
        }

        .button.icon-btn {
            padding: 0;
            width: 2.5rem;
            height: 2.5rem;
            font-size: 1.5rem;
            line-height: 2.5rem;
            text-align: center;
            flex-shrink: 0;
        }

        #url-input-container {
            width: 50%;
            max-width: 550px;
            margin-left: auto;
            margin-right: auto;
        }

        @media (max-width: 768px) {
            #toc-panel {
                width: 100%;
                max-width: none;
            }

            .welcome-buttons {
                flex-direction: column;
                width: 100%;
            }

            .welcome-buttons .button {
                width: 100%;
                text-align: center;
            }

            #book-title {
                max-width: 60%;
            }

            #navbar-buttons {
                gap: 0.5rem;
            }

            .flashcard-toast {
                left: 1.25rem;
                right: 1.25rem;
                width: auto;
            }

            #chat-panel {
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                max-width: none;
                max-height: none;
                border-radius: 0;
                transform: translate(0, 0) scale(1);
                border: none;
            }

            #chat-panel:not(.visible) {
                 transform: translateY(100%);
                 opacity: 0;
            }
            #chat-panel.visible {
                 transform: translateY(0);
                 opacity: 1;
            }

        }

        button, input[type="checkbox"] {
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        #content-area a {
            text-decoration: underline;
            font-style: italic;
            color: var(--primary-color);
            cursor: pointer;
        }

        #content-area a:hover {
            color: #3367d6;
        }
        #toast {
            position: fixed;
            bottom: 1.25rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: var(--panel-bg);
            color: var(--text-color);
            padding: 0.75rem 1.25rem;
            border-radius: 4px;
            box-shadow: 0 4px 12px var(--panel-shadow);
            z-index: 1000;
            transition: transform 0.3s ease;
            text-align: center;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
        }

        .link-action-toast {
            position: fixed;
            bottom: 1.25rem;
            left: 50%;
            transform: translateX(-50%) translateY(150px);
            background-color: var(--panel-bg);
            color: var(--text-color);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--panel-shadow);
            z-index: 1001;
            transition: transform 0.3s ease;
            width: 90%;
            max-width: 400px;
            text-align: left;
        }

        .link-action-toast.visible {
            transform: translateX(-50%) translateY(0);
        }

        .link-action-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .link-action-close-btn {
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
            line-height: 1;
        }

        .link-action-url {
            font-size: 0.9rem;
            margin-bottom: 1rem;
            word-break: break-word;
        }

        .link-action-target-url {
            font-size: 0.8rem;
            margin-bottom: 1rem;
            word-break: break-all;
            color: var(--text-muted);
            max-height: 4.8em;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .link-action-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .link-action-btn {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: transparent;
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .link-action-btn.scrape {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .link-action-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .link-action-btn.scrape:hover {
            background-color: #3367d6;
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--modal-backdrop-color);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal-backdrop.visible {
            display: block;
            opacity: 1;
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background-color: var(--panel-bg);
            color: var(--text-color);
            border-radius: var(--panel-radius);
            box-shadow: 0 8px 25px var(--panel-shadow);
            z-index: 1000;
            display: none;
            flex-direction: column;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .modal.visible {
            display: flex;
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .modal-header {
            padding: 0.8rem 1.2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.3rem;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0.2rem;
            line-height: 1;
        }

        .modal-body {
            padding: 1rem 1.2rem;
            overflow-y: auto;
            flex-grow: 1;
            font-size: 0.9rem;
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }
        .modal-body::-webkit-scrollbar { width: 6px; }
        .modal-body::-webkit-scrollbar-track { background: transparent; }
        .modal-body::-webkit-scrollbar-thumb { background-color: rgba(155, 155, 155, 0.5); border-radius: 3px; }

        .modal-body p {
            margin-bottom: 1rem;
            color: var(--text-muted);
        }

        .cleanup-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        .cleanup-item:last-child {
            border-bottom: none;
        }

        .cleanup-item input[type="checkbox"] {
            margin-right: 0.8rem;
            flex-shrink: 0;
            width: 18px;
            height: 18px;
        }

        .cleanup-item-details {
            flex-grow: 1;
            min-width: 0;
        }

        .cleanup-item-title {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 0.1rem;
        }

        .cleanup-item-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .modal-footer {
            padding: 0.8rem 1.2rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            flex-shrink: 0;
        }

        .modal-footer .button {
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
        }

        .modal-footer .button.danger {
            background-color: var(--danger-color);
        }
        .modal-footer .button.danger:hover {
            background-color: #c5221f;
        }

        .line-height-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        #source-url-display {
            display: none;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        #source-url-content-link {
            word-break: break-all;
            color: var(--primary-color);
            text-decoration: none;
        }
        #source-url-content-link:hover {
            text-decoration: underline;
        }

        #api-status-container {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .api-status-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.4rem;
        }

        .api-status-item .status-icon {
            margin-right: 0.5rem;
            font-size: 1rem;
        }

        .api-status-item .status-text a {
            color: var(--primary-color);
            text-decoration: underline;
        }
        .panel {
            position: fixed;
            background-color: var(--panel-bg);
            color: var(--text-color);
            border-radius: var(--panel-radius);
            box-shadow: 0 5px 20px var(--panel-shadow);
            z-index: 1001;
            display: none;
            flex-direction: column;
            border: 1px solid var(--border-color);
        }

        .settings-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 18px 25px;
            padding: 20px;
            max-height: 75vh;
            overflow-y: auto;
            align-items: start;
        }

        .settings-content > .settings-divider,
        .settings-content > .ai-features-section,
        .settings-content > .api-status-section {
            grid-column: 1 / -1;
            margin-top: 0;
            margin-bottom: 0;
        }
        .settings-content > .settings-divider {
            margin-top: 3px;
            margin-bottom: 3px;
        }


        .settings-section { /* This is a general rule, also used by #ai-features-section */
            margin-bottom: 0; /* Reset by .settings-grid > .settings-section or specific overrides */
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* .settings-section:last-child is handled by the more generic one */

        .settings-section > label {
            display: block;
            margin-bottom: 0px;
            font-weight: bold;
            color: var(--text-color);
            font-size: 0.95em;
        }

        .setting-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-control.font-size-control,
        .setting-control.line-height-control {
            justify-content: space-between;
        }

        .setting-control.font-size-control span,
        .setting-control.line-height-control span {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            flex-grow: 1;
        }

        .theme-control {
            justify-content: flex-start;
            gap: 10px;
        }

        .theme-option { /* This is for the options in the new .settings-content panel, different from #settings-panel theme options */
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: border-color 0.3s ease, transform 0.2s ease;
        }
        .theme-option:hover {
            transform: scale(1.1);
        }
        .theme-option.active {
             border-color: var(--primary-color);
             border-width: 3px;
        }
        .theme-option[data-theme="light"] { background-color: var(--light-panel-bg); }
        .theme-option[data-theme="sepia"] { background-color: var(--sepia-panel-bg); }
        .theme-option[data-theme="dark"] { background-color: var(--dark-panel-bg); }


        .setting-control.checkbox-control {
            justify-content: space-between;
            width: 100%;
            padding: 1px 0;
        }

        .setting-control.checkbox-control label {
            margin-bottom: 0;
            font-weight: normal;
            flex-grow: 1;
            cursor: pointer;
        }

        .setting-control.checkbox-control input[type="checkbox"] {
            margin: 0;
            flex-shrink: 0;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }

        .settings-section:has(#markdownModeToggle) > label {
            margin-bottom: 5px;
        }
        .settings-section:has(#markdownModeToggle) .setting-control.checkbox-control {
        }

        .setting-control:has(#speechLanguageSelect) {
            justify-content: space-between;
            width: 100%;
            padding: 1px 0;
        }
        .setting-control:has(#speechLanguageSelect) label {
             margin-bottom: 0;
             font-weight: normal;
             flex-shrink: 0;
             cursor: default;
        }
        #speechLanguageSelect {
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            color: var(--text-color);
            max-width: 160px;
            font-size: 0.9em;
        }

        #chat-suggestions {
            display: none;
            padding: 0.25rem 0 0.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
            flex-shrink: 0;
        }

        .suggestion-chip {
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            cursor: pointer;
            border: 1px solid var(--border-color);
            background-color: rgba(255, 255, 255, 0.08);
            color: var(--text-muted);
            transition: background-color 0.2s, color 0.2s;
            white-space: nowrap;
        }

        .suggestion-chip:hover {
            background-color: rgba(255, 255, 255, 0.15);
            color: var(--text-color);
        }

        .api-status-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 5px;
        }

        .api-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        .icon-btn {
            padding: 0;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
            font-size: 1.1em;
            flex-shrink: 0;
        }
        .icon-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-color);
        }
        .icon-btn:active {
            transform: scale(0.95);
        }

        #chat-panel {
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%) scale(0.9);
             width: 90%;
             max-width: 700px;
             height: 80vh;
             max-height: 700px;
             opacity: 0;
             transition: transform 0.3s ease, opacity 0.3s ease;
             overflow: hidden;
         }

        #chat-panel.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            display: flex;
        }

        #chat-header {
            padding: 0.6rem 1.1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .chat-header-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        #chat-header h3 {
            margin: 0;
            font-size: 1.1rem;
            flex-grow: 1;
        }

        .chat-clear-btn {
            font-size: 1rem;
            width: 28px;
            height: 28px;
        }

        .chat-context-toggle {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        #chat-messages {
            flex: 1 1 auto;
            overflow-y: auto;
            padding: 1rem 1.1rem;
            display: flex;
            flex-direction: column;
            gap: 0.85rem;
            min-height: 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
        }

        #chat-messages::-webkit-scrollbar { width: 6px; }
        #chat-messages::-webkit-scrollbar-track { background: transparent; }
        #chat-messages::-webkit-scrollbar-thumb { background-color: rgba(155, 155, 155, 0.5); border-radius: 3px; }

        .chat-message {
            padding: 0.6rem 0.9rem;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
            line-height: 1.5;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .chat-message.user {
            background-color: var(--primary-color);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 2px;
        }

        .chat-message.assistant {
            background-color: var(--panel-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            align-self: flex-start;
            border-bottom-left-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            max-width: 100%;
        }
        .chat-message.assistant p { margin-bottom: 0.5em; }
        .chat-message.assistant p:last-child { margin-bottom: 0; }
        .chat-message.assistant ul { list-style: disc; margin-left: 1.5em; margin-bottom: 0.5em; }
        .chat-message.assistant ol { list-style: decimal; margin-left: 1.5em; margin-bottom: 0.5em; }
        .chat-message.assistant li { margin-bottom: 0.25em; }
        .chat-message.assistant strong { font-weight: bold; }
        .chat-message.assistant em { font-style: italic; }
        .chat-message.assistant code {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .chat-message.assistant a {
            color: var(--primary-color);
            text-decoration: underline;
        }
        .chat-message.assistant a:hover {
            color: #66a3ff;
        }

        .chat-message.assistant.loading::after {
            content: '...';
            display: inline-block;
            animation: loading-dots 1.5s infinite;
        }

        @keyframes loading-dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }


        #chat-input-area {
            flex-direction: column;
            display: flex;
            padding: 0.4rem 0.6rem;
            border-top: 1px solid var(--border-color);
            gap: 0.5rem;
            align-items: stretch;
            flex-shrink: 0;
        }

        .chat-input-row {
            display: flex;
            align-items: flex-end;
            gap: 0.5rem;
            width: 100%;
        }

        #chat-input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            font-size: 0.95rem;
            resize: none;
            line-height: 1.4;
            min-height: 36px;
            max-height: 80px;
            overflow-y: auto;
        }

        #chat-send-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.95rem;
            height: 36px;
            flex-shrink: 0;
        }

    </style>
</head>
<body class="dark-theme">
    <div id="app">
        <div id="welcome-screen">
            <div class="welcome-content">
                <h1>Enhanced Ebook Reader</h1>
                <p>Read from a URL, paste text, or open a local file.</p>

                <div class="welcome-actions">
                    <div class="input-group" id="url-input-container">
                        <div class="input-row">
                            <input id="url-input" type="url" placeholder="Enter a URL to read" class="input-field">
                            <button type="button" id="process-url-btn" class="button icon-btn" aria-label="Read URL">➔</button>
                        </div>
                    </div>

                    <div id="toggle-text-input-container">
                        <a href="#" id="toggle-text-input">or paste text directly</a>
                    </div>
                    <div class="input-group" id="text-input-container" style="display: none;">
                        <textarea id="text-input" class="input-field" placeholder="Paste your text here..."></textarea>
                        <div class="input-row">
                            <input id="text-input-title" type="text" placeholder="Enter a title (optional)" class="input-field">
                            <button type="button" id="process-text-btn" class="button">Read Text</button>
                        </div>
                    </div>

                     <div style="margin-top: 1.5rem; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 1rem;">
                        <button type="button" id="open-file-btn" class="button button-secondary">Open Local File</button>
                        <div class="example-book-section" style="margin-top: 0.2rem; margin-bottom: 0;">
                            <p style="margin-bottom: 0.5rem;">Don't have an ebook? Try our example:</p>
                            <a id="example-book-btn" class="button success-button" href="https://raw.githubusercontent.com/dat-lequoc/apps/refs/heads/main/ebooks/Kundera%2C%20Milan%20-%20The%20Unbearable%20Lightness%20of%20Being%20(2017%2C%20Faber%20and%20Faber)%20-%20libgen.li.epub" target="_blank" rel="noopener">Download Sample Book</a>
                        </div>
                    </div>

                    <div class="main-actions" style="margin-top: 1rem;">
                         <button type="button" id="login-btn" class="button hidden">Sign In</button>
                    </div>
                </div>

                <div class="auth-section" id="auth-section" style="margin-top: auto; padding-top: 1rem;">
                    <p>Sign in to save books to your library.</p>
                </div>

                <div id="library-section" style="display: none;">
                    <div id="list-controls-wrapper">
                        <div id="list-badge-container">
                        </div>
                        <div id="create-list-group">
                            <input type="text" id="new-list-name" placeholder="New list name..." />
                            <button type="button" id="create-list-btn" class="button">+</button>
                            <button type="button" id="ai-cleanup-btn" class="button icon-btn" title="AI Library Cleanup" aria-label="AI Library Cleanup" style="display: none;">🧹</button>
                        </div>
                    </div>
                    <div id="library-list">
                    </div>
                </div>
            </div>
        </div>

        <div id="navbar">
            <div id="book-title">Ebook Title</div>
            <div id="navbar-buttons">
                <button type="button" class="navbar-btn" id="toc-btn" aria-label="Table of Contents">☰</button>
                <button type="button" class="navbar-btn" id="settings-btn" aria-label="Settings">⚙️</button>
                <button type="button" class="navbar-btn" id="chat-btn" aria-label="Chat">💬</button>
                <button type="button" class="navbar-btn" id="home-btn" aria-label="Home">⌂</button>
            </div>
        </div>

        <div id="reader-container">
            <div id="content-area">
                <div id="source-url-display" style="display: none; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); font-size: 0.9rem;">
                    Source: <a id="source-url-content-link" href="#" target="_blank" rel="noopener noreferrer" style="word-break: break-all; color: var(--primary-color);"></a>
                </div>
            </div>
            <div id="progress-bar"></div>
        </div>

        <div id="nav-controls">
            <button type="button" class="nav-btn" id="prev-btn" aria-label="Previous Chapter">←</button>
            <button type="button" class="nav-btn" id="next-btn" aria-label="Next Chapter">→</button>
        </div>

        <div id="toc-panel">
            <div id="toc-header">
                <h3>Table of Contents</h3>
                <button type="button" class="navbar-btn" id="close-toc-btn" aria-label="Close">✕</button>
            </div>
            <div id="toc-content"></div>
        </div>

        <div id="settings-panel">
            <div class="settings-grid">
                <div class="settings-section">
                    <div class="settings-title">Font Size</div>
                    <div class="font-size-controls">
                        <button type="button" class="font-btn" id="font-decrease-btn" aria-label="Decrease Font Size">A-</button>
                        <span id="font-size-value">100%</span>
                        <button type="button" class="font-btn" id="font-increase-btn" aria-label="Increase Font Size">A+</button>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="settings-title">Line Height</div>
                    <div class="line-height-controls">
                        <button type="button" class="font-btn" id="line-height-decrease-btn" aria-label="Decrease Line Height">-</button>
                        <span id="line-height-value">1.6</span>
                        <button type="button" class="font-btn" id="line-height-increase-btn" aria-label="Increase Line Height">+</button>
                    </div>
                </div>
            </div>

            <div class="settings-grid">
                <div class="settings-section">
                    <div class="settings-title">Theme</div>
                    <div class="theme-options">
                        <div class="theme-option light-option" data-theme="light" title="Light Theme"></div>
                        <div class="theme-option sepia-option" data-theme="sepia" title="Sepia Theme"></div>
                        <div class="theme-option dark-option active" data-theme="dark" title="Dark Theme"></div>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="settings-title">Content View</div>
                    <div class="settings-row">
                        <label for="view-raw-html-toggle">View Raw HTML (URLs/EPUBs)</label>
                        <input type="checkbox" id="view-raw-html-toggle">
                    </div>
                </div>
            </div>

            <div class="settings-section" id="ai-features-section">
                <div class="settings-title">AI Features</div>
                <div class="settings-row ai-toggle">
                    <label for="translation-toggle">Text Selection Translation</label>
                    <input type="checkbox" id="translation-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="auto-speak-toggle">Auto Speak Flashcard Words</label>
                    <input type="checkbox" id="auto-speak-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="speak-selection-toggle">Speak Full Selection (instead of just flashcard word)</label>
                    <input type="checkbox" id="speak-selection-toggle">
                </div>
                <div class="settings-row">
                    <label for="speech-language">Speech Language</label>
                    <select id="speech-language">
                        <option value="en-US">English</option>
                        <option value="fr-FR">French</option>
                    </select>
                </div>
                <div id="ai-settings-content">
                    <p>Loading API status...</p>
                </div>
                <button type="button" id="summarize-chapter-btn" class="button" style="margin-top: 0.75rem; display: none;">Summarize Chapter</button>
                <div id="ai-response-area"></div>
            </div>
        </div>

        <div id="chat-panel" class="panel">
            <div id="chat-header">
                <h3>Chat with AI</h3>
                <div class="chat-header-controls">
                    <button type="button" class="icon-btn chat-clear-btn" id="chat-clear-btn" aria-label="Clear Chat" title="Clear Chat History">🗑️</button>
                    <div class="chat-context-toggle">
                        <input type="checkbox" id="chat-full-doc-toggle" style="width: 16px; height: 16px; vertical-align: middle;" checked>
                        <label for="chat-full-doc-toggle" style="font-size: 0.85rem; vertical-align: middle; cursor: pointer;">Use Full Document</label>
                    </div>
                    <button type="button" class="navbar-btn" id="close-chat-btn" aria-label="Close">✕</button>
                </div>
            </div>
            <div id="chat-messages">
                <div class="chat-message assistant">Hello! Ask me anything about the full document <br> (or toggle 'Use Full Document' above to focus on the current chapter).</div>
            </div>
            <div id="chat-input-area">
                <div id="chat-suggestions">
                    <!-- Suggested questions will be rendered here -->
                </div>
                <div class="chat-input-row">
                    <textarea id="chat-input" placeholder="Type your message..." rows="1"></textarea>
                    <button type="button" id="chat-send-btn" class="button">Send</button>
                </div>
            </div>
        </div>

        <div id="overlay"></div>

        <div id="loading">
            <div class="spinner"></div>
        </div>

        <div id="translation-popup">
            <div id="translation-content"></div>
            <div id="translation-loading">
                <div class="spinner"></div>
            </div>
        </div>

        <div id="toast"></div>

        <input type="file" id="file-input" accept=".txt,.epub,.pdf" style="display: none;">
    </div>

    <div id="ai-cleanup-backdrop" class="modal-backdrop"></div>
    <div id="ai-cleanup-modal" class="modal">
        <div class="modal-header">
            <h3>AI Cleanup Suggestions</h3>
            <button type="button" id="ai-cleanup-close-btn" class="modal-close-btn" aria-label="Close">×</button>
        </div>
        <div class="modal-body" id="ai-cleanup-list">
            <p>Loading suggestions...</p>
        </div>
        <div class="modal-footer">
            <button type="button" id="ai-cleanup-cancel-btn" class="button">Cancel</button>
            <button type="button" id="ai-cleanup-confirm-btn" class="button danger">Delete Selected</button>
        </div>
    </div>

    <script>
        function escapeHTML(str) {
             if (!str) return '';
             return str.replace(/&/g, '&amp;')
                       .replace(/</g, '&lt;')
                       .replace(/>/g, '&gt;')
                       .replace(/"/g, '&quot;')
                       .replace(/'/g, '&#039;');
        }

        function processInlineMarkdown(text) {
            if (!text) return '';
            text = text.replace(/`([^`]+)`/g, (match, code) => `<code>${escapeHTML(code)}</code>`);
            text = text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, alt, src) =>
                `<img src="${escapeHTML(src)}" alt="${escapeHTML(alt)}">`
            );
            text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, linkText, href) =>
                `<a href="${escapeHTML(href)}" target="_blank" rel="noopener noreferrer">${processInlineMarkdown(linkText)}</a>`
            );
            text = text.replace(/\*\*(\S(?:[^*\n]|\*(?!\*))*\S)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/__(\S(?:[^_\n]|_(?!_))*\S)__/g, '<strong>$1</strong>');
            text = text.replace(/(?<!\w)(?<!\*)\*(\S(?:[^*\n]|\*(?!\*))*\S)\*(?!\w)(?!\*)/g, '<em>$1</em>');
            text = text.replace(/(?<!\w)(?<!_)_(\S(?:[^_\n]|_(?!_))*\S)_(?!\w)(?!_)/g, '<em>$1</em>');
            return text;
        }

        function markdownToHtml(md) {
            if (!md) return '';

            const lines = md.replace(/\r\n/g, '\n').split('\n');
            let html = '';
            let currentBlock = null;
            let blockContent = '';
            let listType = null;
            let codeLang = '';

            const closeCurrentBlock = () => {
                if (currentBlock === 'p') {
                    html += `<p>${processInlineMarkdown(blockContent.trim())}</p>\n`;
                } else if (currentBlock === 'ul' || currentBlock === 'ol') {
                    const itemsHtml = blockContent.split('<li>').slice(1).map(item =>
                        `<li>${processInlineMarkdown(item.replace(/<\/li>$/, '').trim())}</li>`
                    ).join('\n');
                    html += `<${listType}>\n${itemsHtml}\n</${listType}>\n`;
                } else if (currentBlock === 'bq') {
                    html += `<blockquote>${markdownToHtml(blockContent.trim())}</blockquote>\n`;
                } else if (currentBlock === 'pre') {
                    html += `<pre><code${codeLang ? ` class="language-${escapeHTML(codeLang)}"` : ''}>${escapeHTML(blockContent.replace(/\n$/, ''))}</code></pre>\n`;
                }
                currentBlock = null;
                blockContent = '';
                listType = null;
                codeLang = '';
            };

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();

                if (trimmedLine.startsWith('```')) {
                    if (currentBlock === 'pre') {
                        closeCurrentBlock();
                    } else {
                        closeCurrentBlock();
                        currentBlock = 'pre';
                        codeLang = trimmedLine.substring(3).trim();
                    }
                    continue;
                }
                if (currentBlock === 'pre') {
                    blockContent += line + '\n';
                    continue;
                }

                if (trimmedLine === '') {
                    closeCurrentBlock();
                    continue;
                }

                const headingMatch = line.match(/^(#{1,6})\s+(.*)/);
                if (headingMatch) {
                    closeCurrentBlock();
                    const level = headingMatch[1].length;
                    const headingText = headingMatch[2].trim();
                    html += `<h${level}>${processInlineMarkdown(escapeHTML(headingText))}</h${level}>\n`;
                    continue;
                }

                if (/^\s*([-*_])\s*\1\s*\1+\s*$/.test(trimmedLine)) {
                    closeCurrentBlock();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('>')) {
                    const quoteLine = line.replace(/^>\s?/, '');
                    if (currentBlock !== 'bq') {
                        closeCurrentBlock();
                        currentBlock = 'bq';
                        blockContent = quoteLine + '\n';
                    } else {
                        blockContent += quoteLine + '\n';
                    }
                    continue;
                 }
                 if (currentBlock === 'bq' && !line.startsWith('>')) {
                     closeCurrentBlock();
                 }

                const ulMatch = line.match(/^(\s*)([*+-])\s+(.*)/);
                const olMatch = line.match(/^(\s*)(\d+)\.\s+(.*)/);
                const isListItem = ulMatch || olMatch;

                if (isListItem) {
                    const currentListType = olMatch ? 'ol' : 'ul';
                    const itemContent = (ulMatch || olMatch)[ulMatch ? 3 : 3];
                    const startNumber = olMatch ? olMatch[2] : null;

                    if (currentBlock !== currentListType) {
                         closeCurrentBlock();
                         currentBlock = currentListType;
                         listType = currentListType;
                         const startAttr = (listType === 'ol' && startNumber !== '1') ? ` start="${startNumber}"` : '';
                         blockContent = `<li>${escapeHTML(itemContent)}</li>`;
                    } else {
                         blockContent += `<li>${escapeHTML(itemContent)}</li>`;
                    }
                    continue;
                }
                 if (currentBlock === 'ul' || currentBlock === 'ol') {
                     closeCurrentBlock();
                 }

                if (currentBlock !== 'p') {
                    closeCurrentBlock();
                    currentBlock = 'p';
                    blockContent = escapeHTML(line);
                } else {
                    blockContent += ' ' + escapeHTML(line);
                }
            }

            closeCurrentBlock();

            return html;
        }


        const EbookApp = (function() {
            const supabaseUrl = 'https://iioxqphxakvhhtyvdhrh.supabase.co';
            const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpb3hxcGh4YWt2aGh0eXZkaHJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg4MzQ5MjAsImV4cCI6MjA1NDQxMDkyMH0.7I2CaBH1DyiRYEtzunIM5-l3GaWYT15Mly39jW-ga5Q';
            const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);

            const DOM = {
                app: document.getElementById('app'),
                welcomeScreen: document.getElementById('welcome-screen'),
                readerContainer: document.getElementById('reader-container'),
                contentArea: document.getElementById('content-area'),
                navbar: document.getElementById('navbar'),
                bookTitle: document.getElementById('book-title'),
                tocBtn: document.getElementById('toc-btn'),
                settingsBtn: document.getElementById('settings-btn'),
                homeBtn: document.getElementById('home-btn'),
                tocPanel: document.getElementById('toc-panel'),
                closeTocBtn: document.getElementById('close-toc-btn'),
                tocContent: document.getElementById('toc-content'),
                settingsPanel: document.getElementById('settings-panel'),
                overlay: document.getElementById('overlay'),
                fileInput: document.getElementById('file-input'),
                openFileBtn: document.getElementById('open-file-btn'),
                exampleBookBtn: document.getElementById('example-book-btn'),
                textInput: document.getElementById('text-input'),
                textInputTitle: document.getElementById('text-input-title'),
                processTextBtn: document.getElementById('process-text-btn'),
                toggleTextInput: document.getElementById('toggle-text-input'),
                textInputContainer: document.getElementById('text-input-container'),
                urlInputContainer: document.getElementById('url-input-container'),
                urlInput: document.getElementById('url-input'),
                processUrlBtn: document.getElementById('process-url-btn'),
                fontDecreaseBtn: document.getElementById('font-decrease-btn'),
                fontIncreaseBtn: document.getElementById('font-increase-btn'),
                fontSizeValue: document.getElementById('font-size-value'),
                lineHeightDecreaseBtn: document.getElementById('line-height-decrease-btn'),
                lineHeightIncreaseBtn: document.getElementById('line-height-increase-btn'),
                lineHeightValue: document.getElementById('line-height-value'),
                themeOptions: document.querySelectorAll('.theme-option'),
                progressBar: document.getElementById('progress-bar'),
                prevBtn: document.getElementById('prev-btn'),
                nextBtn: document.getElementById('next-btn'),
                loading: document.getElementById('loading'),
                toast: document.getElementById('toast'),
                loginBtn: document.getElementById('login-btn'),
                librarySection: document.getElementById('library-section'),
                authSection: document.getElementById('auth-section'),
                translationToggle: document.getElementById('translation-toggle'),
                autoSpeakToggle: document.getElementById('auto-speak-toggle'),
                speakSelectionToggle: document.getElementById('speak-selection-toggle'),
                speechLanguage: document.getElementById('speech-language'),
                translationPopup: document.getElementById('translation-popup'),
                translationContent: document.getElementById('translation-content'),
                translationLoading: document.getElementById('translation-loading'),
                viewRawHtmlToggle: document.getElementById('view-raw-html-toggle'),
                sourceUrlDisplay: document.getElementById('source-url-display'),
                sourceUrlContentLink: document.getElementById('source-url-content-link'),
                listBadgeContainer: document.getElementById('list-badge-container'),
                createListBtn: document.getElementById('create-list-btn'),
                newListNameInput: document.getElementById('new-list-name'),
                createListGroup: document.getElementById('create-list-group'),
                aiCleanupBtn: document.getElementById('ai-cleanup-btn'),
                aiCleanupModal: document.getElementById('ai-cleanup-modal'),
                aiCleanupBackdrop: document.getElementById('ai-cleanup-backdrop'),
                aiCleanupList: document.getElementById('ai-cleanup-list'),
                aiCleanupCloseBtn: document.getElementById('ai-cleanup-close-btn'),
                aiCleanupCancelBtn: document.getElementById('ai-cleanup-cancel-btn'),
                aiCleanupConfirmBtn: document.getElementById('ai-cleanup-confirm-btn'),
                chatBtn: document.getElementById('chat-btn'),
                chatPanel: document.getElementById('chat-panel'),
                closeChatBtn: document.getElementById('close-chat-btn'),
                chatMessages: document.getElementById('chat-messages'),
                chatInput: document.getElementById('chat-input'),
                chatSendBtn: document.getElementById('chat-send-btn'),
                chatClearBtn: document.getElementById('chat-clear-btn'),
                chatFullDocToggle: document.getElementById('chat-full-doc-toggle'),
                chatSuggestions: document.getElementById('chat-suggestions'), // Container for suggestion chips
                aiSettingsContent: document.getElementById('ai-settings-content'),
                summarizeChapterBtn: document.getElementById('summarize-chapter-btn'),
                aiResponseArea: document.getElementById('ai-response-area')
            };

            let state = {
                bookData: {
                    title: '',
                    content: '',
                    chapters: [],
                    currentPosition: 0,
                    sourceUrl: null,
                    rawContent: null,
                    currentListId: null
                },
                settings: {
                    fontSize: 100,
                    lineHeight: 1.6,
                    theme: 'dark',
                    viewRawHtmlEnabled: false,
                    speakSelectionEnabled: false
                },
                session: null,
                userApiSettings: null,
                translationTimer: null,
                navbarHideTimer: null,
                debounceTimers: {},
                bookLists: [],
                selectedListId: 'all',
                isCreatingList: false,
                isAiCleanupModalOpen: false,
                lastSelectionRect: null,
                chatHistory: [],
                chatUseFullDocument: true,
                lastPosition: null
            };

            // Initial generic questions if chat is empty
            const initialSuggestedQuestions = [
                "Summarize this.",
                "What are the key points?",
                "Explain the main idea.",
            ];

            function init() {
                setupEventListeners();
                checkAuthAndLoadApiSettings();
                loadUserPreferences();
                updateCssVariables();
            }

             function updateCssVariables() {
                document.documentElement.style.setProperty('--reader-line-height', state.settings.lineHeight);
                DOM.contentArea.style.fontSize = `${state.settings.fontSize}%`;
            }

            function setupEventListeners() {
                DOM.openFileBtn.addEventListener('click', () => DOM.fileInput.click());
                DOM.fileInput.addEventListener('change', handleFileSelected);
                DOM.processTextBtn.addEventListener('click', processInputText);
                DOM.exampleBookBtn.addEventListener('click', downloadExampleBook);
                DOM.toggleTextInput.addEventListener('click', (e) => {
                    e.preventDefault();
                    DOM.textInputContainer.style.display = DOM.textInputContainer.style.display === 'none' ? 'block' : 'none';
                });
                DOM.processUrlBtn.addEventListener('click', processUrlInput);

                DOM.tocBtn.addEventListener('click', toggleTocPanel);
                DOM.closeTocBtn.addEventListener('click', closeTocPanel);
                DOM.settingsBtn.addEventListener('click', toggleSettingsPanel);
                DOM.chatBtn.addEventListener('click', toggleChatPanel);
                DOM.homeBtn.addEventListener('click', goToHome);
                DOM.overlay.addEventListener('click', closeAllPanels);
                DOM.closeChatBtn.addEventListener('click', closeChatPanel);
                DOM.prevBtn.addEventListener('click', goToPrevious);
                DOM.nextBtn.addEventListener('click', goToNext);

                DOM.contentArea.addEventListener('click', handleContentClick);
                DOM.contentArea.addEventListener('scroll', debounce(updateProgressBar, 100));
                DOM.contentArea.addEventListener('touchstart', handleTouchStart);
                DOM.contentArea.addEventListener('touchend', handleTouchEnd);

                DOM.fontDecreaseBtn.addEventListener('click', () => { decreaseFontSize(); saveUserPreferences(); });
                DOM.fontIncreaseBtn.addEventListener('click', () => { increaseFontSize(); saveUserPreferences(); });
                DOM.lineHeightDecreaseBtn.addEventListener('click', () => { decreaseLineHeight(); saveUserPreferences(); });
                DOM.lineHeightIncreaseBtn.addEventListener('click', () => { increaseLineHeight(); saveUserPreferences(); });

                DOM.themeOptions.forEach(option => {
                    option.addEventListener('click', () => { setTheme(option.getAttribute('data-theme')); saveUserPreferences(); });
                });

                DOM.viewRawHtmlToggle.addEventListener('change', function() {
                    state.settings.viewRawHtmlEnabled = this.checked;
                    displayCurrentChapter();
                    saveUserPreferences();
                });

                DOM.translationToggle.addEventListener('change', function() { localStorage.setItem('translation-enabled', this.checked); saveUserPreferences(); });
                DOM.autoSpeakToggle.addEventListener('change', function() { localStorage.setItem('auto-speak-enabled', this.checked); saveUserPreferences(); });
                DOM.speakSelectionToggle.addEventListener('change', function() { state.settings.speakSelectionEnabled = this.checked; localStorage.setItem('speak-selection-enabled', this.checked); saveUserPreferences(); });
                DOM.speechLanguage.addEventListener('change', function() { localStorage.setItem('speech-language', this.value); saveUserPreferences(); });

                document.addEventListener('selectionchange', handleTextSelection);
                DOM.loginBtn.addEventListener('click', () => { window.open('index.html', '_blank'); });

                DOM.listBadgeContainer.addEventListener('click', handleListBadgeClick);
                DOM.createListBtn.addEventListener('click', toggleCreateListInput);

                DOM.aiCleanupBtn.addEventListener('click', showAiCleanupModal);
                DOM.aiCleanupCloseBtn.addEventListener('click', hideAiCleanupModal);
                DOM.aiCleanupCancelBtn.addEventListener('click', hideAiCleanupModal);
                DOM.aiCleanupConfirmBtn.addEventListener('click', handleAiCleanupConfirm);
                DOM.aiCleanupBackdrop.addEventListener('click', hideAiCleanupModal);

                document.addEventListener('keydown', handleKeyPress);
                document.addEventListener('selectionchange', debounce(handleTextSelection, 300));
                document.addEventListener('click', handleGlobalClick);

                DOM.chatSendBtn.addEventListener('click', handleSendMessage);
                DOM.chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } });
                DOM.chatClearBtn.addEventListener('click', clearChat);
                DOM.chatFullDocToggle.addEventListener('change', (e) => {
                    state.chatUseFullDocument = e.target.checked;
                    showToast(`Chat context set to: ${state.chatUseFullDocument ? 'Full Document' : 'Current Chapter'}`, 2000);
                    // Optionally clear suggestions or add default ones when context changes
                    renderSuggestedQuestions(initialSuggestedQuestions);
                });
                DOM.chatSuggestions.addEventListener('click', handleSuggestionClick); // Add listener for suggestion clicks
                DOM.summarizeChapterBtn.addEventListener('click', summarizeCurrentChapter);
            }

            function downloadExampleBook() { console.log('Example book link clicked.'); }

             function handleGlobalClick(event) {
                 const openDropdowns = document.querySelectorAll('.move-list-dropdown.visible');
                 openDropdowns.forEach(dropdown => {
                     const moveButton = dropdown.closest('.library-item-actions')?.querySelector('.library-item-move');
                     if (moveButton && !dropdown.contains(event.target) && !moveButton.contains(event.target)) {
                         dropdown.classList.remove('visible');
                     }
                 });

                 if (state.isCreatingList && !DOM.createListGroup.contains(event.target)) {
                     if (!DOM.createListBtn.contains(event.target)) {
                         cancelListCreation();
                     }
                 }

                 if (DOM.chatPanel.classList.contains('visible') && !DOM.chatPanel.contains(event.target) && !DOM.chatBtn.contains(event.target)) { closeChatPanel(); }
                 if (DOM.settingsPanel.classList.contains('visible') && !DOM.settingsPanel.contains(event.target) && !DOM.settingsBtn.contains(event.target)) { closeSettingsPanel(); }
                 if (DOM.tocPanel.classList.contains('visible') && !DOM.tocPanel.contains(event.target) && !DOM.tocBtn.contains(event.target)) { closeTocPanel(); }
             }

            function handleKeyPress(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.key === 'ArrowLeft' && e.altKey) { goToPrevious(); e.preventDefault(); }
                if (e.key === 'ArrowRight' && e.altKey) { goToNext(); e.preventDefault(); }

                if (e.key === 'Escape') {
                    if (state.isCreatingList) { cancelListCreation(); }
                    else if (state.isAiCleanupModalOpen) { hideAiCleanupModal(); }
                    else { closeAllPanels(); }
                    e.preventDefault();
                }

                if (e.key === 'Enter' && state.isCreatingList && e.target === DOM.newListNameInput) { handleCreateList(); e.preventDefault(); }
                if (e.key === 't' && !e.ctrlKey && !e.metaKey) { toggleTocPanel(); e.preventDefault(); }
                if (e.key === 's' && !e.ctrlKey && !e.metaKey) { toggleSettingsPanel(); e.preventDefault(); }
                if (e.key === 'h' && !e.ctrlKey && !e.metaKey) { goToHome(); e.preventDefault(); }
                if ((e.key === '+' || e.key === '=') && (e.ctrlKey || e.metaKey)) { increaseFontSize(); saveUserPreferences(); e.preventDefault(); }
                if (e.key === '-' && (e.ctrlKey || e.metaKey)) { decreaseFontSize(); saveUserPreferences(); e.preventDefault(); }
                if (e.key === 'c' && !e.ctrlKey && !e.metaKey && DOM.readerContainer.offsetParent !== null) { toggleChatPanel(); e.preventDefault(); }
            }

            function handleTouchStart(e) { state.touchStartY = e.touches[0].clientY; }
            function handleTouchEnd(e) {
                state.touchEndY = e.changedTouches[0].clientY;
                const distance = state.touchStartY - state.touchEndY;
                if (distance < -50 && DOM.contentArea.scrollTop <= 0) { toggleNavbar(); }
            }

            function handleFileSelected() {
                const file = DOM.fileInput.files[0];
                if (!file) return;
                showLoading();
                DOM.bookTitle.textContent = file.name;
                state.bookData.title = file.name;
                state.bookData.currentListId = null;
                state.bookData.sourceUrl = null;
                state.bookData.rawContent = null;
                const fileExtension = file.name.split('.').pop().toLowerCase();
                if (fileExtension === 'txt') { processTextFile(file); }
                else if (fileExtension === 'epub') { processEpubFile(file); }
                else if (fileExtension === 'pdf') { processPdfFile(file); }
                else { hideLoading(); showToast('Unsupported file format'); }
            }

            function processInputText() {
                const text = DOM.textInput.value.trim();
                if (!text) { showToast('Please enter some text'); return; }
                showLoading();
                let customTitle = DOM.textInputTitle.value.trim() || text.substring(0, 20).trim() + (text.length > 20 ? '...' : '');
                DOM.bookTitle.textContent = customTitle;
                state.bookData.title = customTitle;
                state.bookData.currentListId = null;
                state.bookData.sourceUrl = null;
                state.bookData.rawContent = null;
                try {
                    state.bookData.chapters = [{ title: customTitle, markdownContent: text, content: null, startLine: 0, endLine: text.split('\n').length }];
                    state.settings.viewRawHtmlEnabled = false;
                    DOM.viewRawHtmlToggle.checked = false;
                    showBook();
                } catch (error) { console.error('Error processing input text:', error); showToast('Error processing text'); }
                finally { hideLoading(); }
            }

            function processTextFile(file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        const chapters = splitIntoChapters(text, 1000);
                        state.bookData.chapters = chapters.map((chap, index) => ({
                            title: chap.title || `Chapter ${index + 1}`,
                            markdownContent: chap.content,
                            content: null,
                            startLine: chap.startLine,
                            endLine: chap.endLine
                        }));
                        state.settings.viewRawHtmlEnabled = false;
                        DOM.viewRawHtmlToggle.checked = false;
                        showBook();
                    } catch (error) { console.error('Error processing text file:', error); showToast('Error processing file'); }
                    finally { hideLoading(); }
                };
                reader.onerror = function(error) { console.error('Error reading file:', error); hideLoading(); showToast('Error reading file'); };
                reader.readAsText(file);
            }

            function splitIntoChapters(text, linesPerChapter = 1000) {
                const lines = text.split('\n');
                const chapters = [];
                let currentChapterLines = [];
                let chapterStartLine = 0;

                for (let i = 0; i < lines.length; i++) {
                    currentChapterLines.push(lines[i]);
                    if (currentChapterLines.length >= linesPerChapter || i === lines.length - 1) {
                        const chapterContent = currentChapterLines.join('\n');
                        let title = null;
                        for(let j=0; j<Math.min(5, currentChapterLines.length); j++) {
                            const trimmedLine = currentChapterLines[j].trim();
                            if (trimmedLine && trimmedLine.length < 80 && !trimmedLine.startsWith('#') && !trimmedLine.startsWith('>') && !trimmedLine.startsWith('*') && !trimmedLine.startsWith('-') && !trimmedLine.startsWith('+') && !/^\d+\./.test(trimmedLine) && !trimmedLine.startsWith('```') && !trimmedLine.startsWith('---')) {
                                title = trimmedLine;
                                break;
                            }
                        }
                        chapters.push({
                            title: title || `Part ${chapters.length + 1}`,
                            content: chapterContent,
                            startLine: chapterStartLine,
                            endLine: i + 1
                        });
                        currentChapterLines = [];
                        chapterStartLine = i + 1;
                    }
                }
                return chapters;
            }


            function processEpubFile(file) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const arrayBuffer = e.target.result;
                        if (typeof JSZip === 'undefined') { await loadExternalScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'); }
                        await extractEpubContent(arrayBuffer);
                    } catch (error) { console.error('Error processing EPUB:', error); hideLoading(); showToast('Error processing EPUB file'); }
                };
                reader.onerror = function(error) { console.error('Error reading EPUB file:', error); hideLoading(); showToast('Error reading EPUB file'); };
                reader.readAsArrayBuffer(file);
            }

            async function loadExternalScript(url) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = url;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
                    document.head.appendChild(script);
                });
            }

            async function extractEpubContent(arrayBuffer) {
                try {
                    const jszip = new JSZip();
                    const zip = await jszip.loadAsync(arrayBuffer);
                    const containerXml = await zip.file('META-INF/container.xml').async('text');
                    const parser = new DOMParser();
                    const containerDoc = parser.parseFromString(containerXml, 'application/xml');
                    const rootFile = containerDoc.querySelector('rootfile');
                    if (!rootFile) throw new Error('Invalid EPUB: container.xml doesn\'t contain a rootfile');
                    const rootFilePath = rootFile.getAttribute('full-path');
                    const rootDir = rootFilePath.substring(0, rootFilePath.lastIndexOf('/') + 1) || '';
                    const opfContent = await zip.file(rootFilePath).async('text');
                    const opfDoc = parser.parseFromString(opfContent, 'application/xml');
                    const metadataElem = opfDoc.querySelector('metadata');
                    if (metadataElem) {
                        const titleElem = metadataElem.querySelector('dc\\:title, title');
                        if (titleElem && titleElem.textContent) { state.bookData.title = titleElem.textContent.trim(); DOM.bookTitle.textContent = state.bookData.title; }
                    }
                    const spine = opfDoc.querySelector('spine');
                    const manifest = opfDoc.querySelector('manifest');
                    if (!spine || !manifest) throw new Error('Invalid EPUB: missing spine or manifest');
                    const manifestItems = {};
                    manifest.querySelectorAll('item').forEach(item => { manifestItems[item.getAttribute('id')] = { href: item.getAttribute('href'), mediaType: item.getAttribute('media-type') }; });
                    const spineItems = [];
                    spine.querySelectorAll('itemref').forEach(itemref => {
                        const idref = itemref.getAttribute('idref');
                        if (manifestItems[idref] && manifestItems[idref].mediaType.includes('html')) { spineItems.push({ id: idref, href: manifestItems[idref].href }); }
                    });

                    let combinedRawHtml = '';
                    state.bookData.chapters = [];

                    for (const item of spineItems) {
                         const fullPath = rootDir + item.href;
                         try {
                             const chapterHtmlContent = await zip.file(fullPath).async('text');
                             combinedRawHtml += chapterHtmlContent + "\n<!-- Chapter Break -->\n";

                             const htmlDoc = parser.parseFromString(chapterHtmlContent, 'text/html');
                             let title = item.href.split('/').pop().replace(/\.[^/.]+$/, "");
                             const titleTag = htmlDoc.querySelector('title');
                             const h1 = htmlDoc.querySelector('h1');
                             if (titleTag && titleTag.textContent.trim()) title = titleTag.textContent.trim();
                             else if (h1 && h1.textContent.trim()) title = h1.textContent.trim();

                             const bodyElement = htmlDoc.body;
                             let markdownContent = '';
                             if (bodyElement) {
                                 bodyElement.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote, pre').forEach(el => {
                                     const text = el.textContent?.trim();
                                     if (text) {
                                         let prefix = '';
                                         const tagName = el.tagName.toLowerCase();
                                         if (tagName.startsWith('h')) {
                                             prefix = '#'.repeat(parseInt(tagName.substring(1), 10)) + ' ';
                                         } else if (tagName === 'li') {
                                              prefix = el.closest('ol') ? '1. ' : '* ';
                                         } else if (tagName === 'blockquote') {
                                              prefix = '> ';
                                         } else if (tagName === 'pre') {
                                              prefix = '```\n';
                                              markdownContent += prefix + text + '\n```\n\n';
                                              return;
                                         }
                                         markdownContent += prefix + text + '\n\n';
                                     }
                                 });
                                 if (markdownContent.trim() === '') {
                                      markdownContent = bodyElement.textContent?.trim() || '';
                                 }

                             } else {
                                 markdownContent = "[Could not extract content body]";
                             }

                             state.bookData.chapters.push({
                                 title: title || `Chapter ${state.bookData.chapters.length + 1}`,
                                 markdownContent: markdownContent.trim(),
                                 content: chapterHtmlContent,
                                 startLine: 0,
                                 endLine: 0
                             });
                         } catch (error) {
                             console.error(`Error loading EPUB chapter ${item.href}:`, error);
                             state.bookData.chapters.push({ title: `Error Loading Chapter`, markdownContent: `[Error loading content: ${error.message}]`, content: null, startLine: 0, endLine: 0 });
                         }
                    }

                    state.bookData.rawContent = combinedRawHtml;

                    if (state.bookData.chapters.length === 0) {
                        state.bookData.chapters.push({ title: state.bookData.title || 'Content', markdownContent: "[Could not extract readable content from this EPUB file.]", content: null, startLine: 0, endLine: 1 });
                    }

                    state.settings.viewRawHtmlEnabled = false;
                    DOM.viewRawHtmlToggle.checked = false;
                    showBook();
                    hideLoading();
                } catch (error) { console.error('Error extracting EPUB content:', error); hideLoading(); showToast('Error processing EPUB file'); }
            }

            function processPdfFile(file) {
                const reader = new FileReader();
                reader.onload = function() {
                    showToast('PDF support is limited. For a better experience, use a dedicated PDF reader app.');
                    state.bookData.chapters = [{ title: state.bookData.title || 'PDF Content', markdownContent: "PDF content extraction is limited in this simple reader.\n\nFor a better experience with PDFs, consider using a dedicated PDF reader app.", content: null, startLine: 0, endLine: 2 }];
                     state.settings.viewRawHtmlEnabled = false;
                     DOM.viewRawHtmlToggle.checked = false;
                    showBook();
                    hideLoading();
                };
                reader.onerror = function(error) { console.error('Error reading PDF file:', error); hideLoading(); showToast('Error reading PDF file'); };
                reader.readAsArrayBuffer(file);
            }

            async function firecrawlScrapeRequest(apiKey, url) {
                console.log('Attempting to scrape URL:', url);
                try {
                    const response = await fetch('https://api.firecrawl.dev/v0/scrape', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({
                             url: url,
                             pageOptions: { onlyMainContent: false },
                             extractorOptions: { mode: 'markdown' }
                         })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || `Firecrawl API request failed with status ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Error calling Firecrawl API:', error);
                    return { error: { message: error.message || 'Failed to connect to Firecrawl API' } };
                }
            }

            async function processUrlInput() {
                const url = DOM.urlInput.value.trim();
                if (!url || !url.startsWith('http')) { showToast('Please enter a valid URL'); return; }
                if (!state.userApiSettings || !state.userApiSettings.firecrawl_api_key) { showToast('Firecrawl API key not configured. Please set it up in the main dashboard.'); return; }

                DOM.processUrlBtn.classList.add('loading');
                DOM.processUrlBtn.disabled = true;
                showLoading();
                DOM.bookTitle.textContent = `Reading: ${url}`;
                state.bookData.title = url;
                state.bookData.currentListId = null;

                try {
                    const response = await firecrawlScrapeRequest(state.userApiSettings.firecrawl_api_key, url);
                    if (response.error) throw new Error(response.error.message);
                    if (!response.data) throw new Error("No data received from Firecrawl.");

                    const rawMarkdownContent = response.data.markdown || "[No Markdown content extracted]";
                    const rawHtmlContent = response.data.content || "[No HTML content extracted]";

                    state.bookData.rawContent = rawHtmlContent;
                    state.bookData.sourceUrl = url;

                    showToast('Generating title & category with AI...', 3000);
                    let titleCategoryResult = { generatedTitle: null, listId: null };

                    try {
                        const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                        titleCategoryResult = await generateTitleAndCategory(rawMarkdownContent, modelToUse);
                        showToast(`Title/Category generated.`, 2000);
                    } catch (aiError) {
                        console.error(`AI title/category generation failed: ${aiError.message}.`);
                        showToast(`AI Title/Cat failed: ${aiError.message}.`, 3000);
                    }

                    const { generatedTitle, listId } = titleCategoryResult;
                    if (generatedTitle) { state.bookData.title = generatedTitle; DOM.bookTitle.textContent = state.bookData.title; showToast(`AI generated title: "${generatedTitle}"`, 3000); }
                    else if (response.data.metadata && response.data.metadata.title) { state.bookData.title = response.data.metadata.title; DOM.bookTitle.textContent = state.bookData.title; }
                    else { showToast('Could not determine title, using URL.', 2000); }

                    state.bookData.currentListId = listId;
                    if (listId !== null) { const listName = state.bookLists.find(l => l.id === listId)?.name || 'Unknown List'; showToast(`Categorized into: "${listName}"`, 3000); }
                    else { showToast('Categorized as Unlisted.', 2000); }

                    state.bookData.chapters = [{
                        title: 'Content',
                        markdownContent: rawMarkdownContent,
                        content: rawHtmlContent,
                        startLine: 0,
                        endLine: 0
                    }];

                    state.settings.viewRawHtmlEnabled = false;
                    DOM.viewRawHtmlToggle.checked = false;
                    showBook();

                } catch (error) {
                    console.error('Error processing URL:', error);
                    showToast(`Error reading URL: ${error.message}`);
                    goToHome();
                } finally {
                    DOM.urlInput.value = '';
                    DOM.processUrlBtn.classList.remove('loading');
                    DOM.processUrlBtn.disabled = false;
                    hideLoading();
                }
            }


            async function scrapeAndSaveLink(url) {
                 if (!state.userApiSettings || !state.userApiSettings.firecrawl_api_key) { showToast('Firecrawl API key needed to scrape. Configure in dashboard.', 4000); return; }
                 showToast(`Scraping "${url}"...`, 2000);
                 try {
                     const response = await firecrawlScrapeRequest(state.userApiSettings.firecrawl_api_key, url);
                     if (response.error) throw new Error(response.error.message || 'Firecrawl request failed');
                     if (!response.data) throw new Error('No data received from Firecrawl.');

                     const rawHtmlContent = response.data.content || "[No HTML content extracted]";
                     const markdownContent = response.data.markdown || "[No Markdown content extracted]";
                     const scrapedTitle = (response.data.metadata && response.data.metadata.title) || url;

                     const scrapedBookData = {
                         title: scrapedTitle,
                         content: null,
                         raw_content: rawHtmlContent,
                         file_type: 'url',
                         metadata: {
                             chapters: [{
                                 title: 'Content',
                                 content: rawHtmlContent,
                                 markdownContent: markdownContent,
                                 startLine: 0, endLine: 0
                             }],
                             viewRawHtmlEnabled: false,
                             sourceUrl: url
                         },
                         last_position: { chapter: 0, percentComplete: 0, scroll: 0, timestamp: new Date().getTime() }
                     };
                     await saveScrapedBook(scrapedBookData, state.bookData.currentListId);
                 } catch (error) { console.error('Error scraping and saving link:', error); showToast(`Error scraping "${url}": ${error.message}`, 5000); }
            }

            // Renders clickable suggestion chips in the chat input area
            function renderSuggestedQuestions(questions = []) {
                DOM.chatSuggestions.innerHTML = '';
                if (questions && questions.length > 0) {
                    DOM.chatSuggestions.style.display = 'flex';
                    questions.forEach(question => {
                        const chip = document.createElement('button');
                        chip.className = 'suggestion-chip';
                        chip.textContent = question;
                        chip.type = 'button'; // Important for accessibility and forms
                        DOM.chatSuggestions.appendChild(chip);
                    });
                } else {
                    DOM.chatSuggestions.style.display = 'none';
                }
            }

            // Handles clicks on suggestion chips
            function handleSuggestionClick(event) {
                const clickedChip = event.target.closest('.suggestion-chip');
                if (!clickedChip) return;

                // Send the clicked suggestion as a new message
                sendSuggestedQuestion(clickedChip.textContent);
            }

            // Sends a suggested question (similar to user sending a message)
            function sendSuggestedQuestion(question) {
                if (!state.userApiSettings || !state.userApiSettings.api_key) {
                    displayChatMessage('assistant', 'Sorry, the Gemini API key is not configured. Please set it up in the main dashboard.');
                    return;
                }
                displayChatMessage('user', question);
                state.chatHistory.push({ role: 'user', parts: [{ text: question }] });
                const loadingElement = displayChatMessage('assistant', '', true);
                DOM.chatSendBtn.disabled = true;
                renderSuggestedQuestions([]); // Clear suggestions after one is clicked
                processAndSendChat(question, loadingElement);
            }


            async function saveScrapedBook(scrapedBookData, targetListId = null) {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) { console.error('Cannot save scraped book: User not logged in.'); showToast('Please sign in to save scraped content.', 4000); return false; }
                try {
                    const { error } = await supabase.from('ebooks').insert({
                        user_id: session.user.id,
                        title: scrapedBookData.title,
                        content: scrapedBookData.content,
                        raw_content: scrapedBookData.raw_content,
                        file_type: scrapedBookData.file_type,
                        metadata: scrapedBookData.metadata,
                        last_position: scrapedBookData.last_position,
                        list_id: targetListId
                    });
                    if (error) { if (error.code === '23505') { console.warn(`Book with title "${scrapedBookData.title}" already exists. Skipping save.`); showToast(`Book "${scrapedBookData.title}" already in library.`, 3000); return true; } else { throw error; } }
                    console.log(`Successfully saved scraped book: "${scrapedBookData.title}"`);
                    showToast(`"${scrapedBookData.title}" saved to library!`, 3000);
                    if (DOM.welcomeScreen.style.display !== 'none') { loadUserLibrary(); }
                    return true;
                } catch (error) { console.error('Error saving scraped book to Supabase:', error); showToast(`Failed to save "${scrapedBookData.title}" to library. DB Error.`, 4000); return false; }
            }

            function showLinkActionConfirmation(url, linkText) {
                const existingToast = document.querySelector('.link-action-toast');
                if (existingToast) existingToast.remove();
                const toast = document.createElement('div');
                toast.className = 'link-action-toast';
                toast.innerHTML = `
                    <div class="link-action-header"><span>Action for Link:</span><button type="button" class="link-action-close-btn" aria-label="Close">×</button></div>
                    <div class="link-action-url" title="Clicked link text">${escapeHTML(linkText)}</div>
                    <div class="link-action-target-url" title="Target URL">URL: ${escapeHTML(url)}</div>
                    <div class="link-action-buttons"><button type="button" class="link-action-btn open">Open Link</button><button type="button" class="link-action-btn scrape">Scrape & Save</button></div>`;
                document.body.appendChild(toast);
                const closeBtn = toast.querySelector('.link-action-close-btn');
                const openBtn = toast.querySelector('.link-action-btn.open');
                const scrapeBtn = toast.querySelector('.link-action-btn.scrape');
                const removeToast = () => { toast.classList.remove('visible'); setTimeout(() => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, 300); };
                closeBtn.addEventListener('click', removeToast);
                openBtn.addEventListener('click', () => { window.open(url, '_blank', 'noopener noreferrer'); removeToast(); });
                scrapeBtn.addEventListener('click', () => { scrapeAndSaveLink(url); removeToast(); });
                requestAnimationFrame(() => { toast.classList.add('visible'); });
                setTimeout(removeToast, 15000);
            }


            function showBook() {
                DOM.welcomeScreen.style.display = 'none';
                DOM.navbar.classList.add('visible');
                clearTimeout(state.navbarHideTimer);
                state.navbarHideTimer = setTimeout(() => { DOM.navbar.classList.remove('visible'); }, 3000);

                displayCurrentChapter();
                populateToc();
                saveBookToLibrary();
            }

            function displayCurrentChapter() {
                const chapter = state.bookData.chapters[state.bookData.currentPosition];
                if (!chapter) {
                     console.error("Attempted to display non-existent chapter at index:", state.bookData.currentPosition);
                     DOM.contentArea.innerHTML = '<p>Error: Chapter not found.</p>';
                     return;
                }
                DOM.contentArea.innerHTML = '';

                const chapterTitleText = `${state.bookData.title || 'Book'} - ${chapter.title || `Chapter ${state.bookData.currentPosition + 1}`}`;
                if (state.bookData.sourceUrl) { DOM.bookTitle.innerHTML = `<a href="${escapeHTML(state.bookData.sourceUrl)}" target="_blank" rel="noopener noreferrer" title="Open Source URL" style="color: var(--primary-color); text-decoration: none;">${escapeHTML(chapterTitleText)}</a>`; DOM.bookTitle.style.cursor = 'pointer'; }
                else { DOM.bookTitle.innerHTML = escapeHTML(chapterTitleText); DOM.bookTitle.style.cursor = 'default'; }

                const canViewRaw = !!(state.bookData.rawContent || (chapter && chapter.content));
                DOM.viewRawHtmlToggle.disabled = !canViewRaw;
                DOM.viewRawHtmlToggle.closest('.settings-row').title = !canViewRaw ? "Raw HTML view only available for books added via URL or EPUB." : "View the original scraped/extracted HTML content.";
                 DOM.viewRawHtmlToggle.checked = canViewRaw && state.settings.viewRawHtmlEnabled;

                let contentToDisplay = '';
                let displayMode = 'markdown';

                if (canViewRaw && state.settings.viewRawHtmlEnabled) {
                    contentToDisplay = state.bookData.rawContent || chapter.content || "[Raw HTML not available]";
                    displayMode = 'raw';
                } else if (typeof chapter.markdownContent === 'string' && chapter.markdownContent.trim() !== '') {
                    contentToDisplay = chapter.markdownContent;
                    displayMode = 'markdown';
                } else if (typeof chapter.content === 'string' && chapter.content.trim() !== '') {
                     contentToDisplay = chapter.content;
                     displayMode = 'html_fallback';
                 } else {
                    contentToDisplay = '<p>[Content not available for this chapter.]</p>';
                    displayMode = 'html_fallback';
                }

                 if (displayMode === 'raw') {
                    const pre = document.createElement('pre');
                    pre.style.whiteSpace = 'pre-wrap';
                    pre.style.wordBreak = 'break-word';
                    pre.style.fontFamily = 'monospace';
                    pre.style.fontSize = 'inherit';
                    pre.style.lineHeight = 'inherit';
                    pre.textContent = contentToDisplay;
                    DOM.contentArea.appendChild(pre);
                    DOM.contentArea.style.fontFamily = 'monospace';
                } else if (displayMode === 'markdown') {
                    DOM.contentArea.innerHTML = markdownToHtml(contentToDisplay);
                    DOM.contentArea.style.fontFamily = 'inherit';
                    updateCssVariables();
                     DOM.contentArea.querySelectorAll('p').forEach((p, index) => {
                        p.setAttribute('data-p-index', index);
                    });
                } else {
                     DOM.contentArea.innerHTML = contentToDisplay;
                     DOM.contentArea.style.fontFamily = 'inherit';
                     updateCssVariables();
                      DOM.contentArea.querySelectorAll('p').forEach((p, index) => {
                         p.setAttribute('data-p-index', index);
                     });
                     if (displayMode === 'html_fallback' && chapter.markdownContent === null) {
                         console.warn("Displayed chapter using older 'content' field (HTML). Markdown was missing.");
                     }
                 }

                DOM.contentArea.scrollTop = 0;
                updateNavigationButtonsState();
                updateProgressBar();

                if (state.bookData.sourceUrl) { DOM.sourceUrlContentLink.href = state.bookData.sourceUrl; DOM.sourceUrlContentLink.textContent = state.bookData.sourceUrl; DOM.sourceUrlDisplay.style.display = 'block'; }
                else { DOM.sourceUrlDisplay.style.display = 'none'; }
            }

            function populateToc() {
                DOM.tocContent.innerHTML = '';
                if (!state.bookData.chapters || state.bookData.chapters.length === 0) {
                    DOM.tocContent.innerHTML = '<div class="toc-item">No chapters found</div>';
                    return;
                }
                state.bookData.chapters.forEach((chapter, index) => {
                    const item = document.createElement('div');
                    item.className = 'toc-item';
                    item.textContent = chapter.title || `Chapter ${index + 1}`;
                    item.setAttribute('data-index', index);
                    if (index === state.bookData.currentPosition) item.classList.add('toc-active');
                    item.addEventListener('click', () => {
                        state.bookData.currentPosition = index;
                        displayCurrentChapter();
                        closeTocPanel();
                        saveBookToLibrary();
                    });
                    DOM.tocContent.appendChild(item);
                });
            }

            function updateNavigationButtonsState() {
                const numChapters = state.bookData.chapters?.length || 0;
                DOM.prevBtn.style.opacity = state.bookData.currentPosition <= 0 ? '0.5' : '1';
                DOM.prevBtn.style.pointerEvents = state.bookData.currentPosition <= 0 ? 'none' : 'auto';
                DOM.nextBtn.style.opacity = state.bookData.currentPosition >= numChapters - 1 ? '0.5' : '1';
                DOM.nextBtn.style.pointerEvents = state.bookData.currentPosition >= numChapters - 1 ? 'none' : 'auto';
            }

            function goToPrevious() { if (state.bookData.currentPosition > 0) { state.bookData.currentPosition--; displayCurrentChapter(); saveBookToLibrary(); } }
            function goToNext() { const numChapters = state.bookData.chapters?.length || 0; if (state.bookData.currentPosition < numChapters - 1) { state.bookData.currentPosition++; displayCurrentChapter(); saveBookToLibrary(); } }

            function toggleNavbar() {
                DOM.navbar.classList.toggle('visible');
                if (DOM.navbar.classList.contains('visible')) { clearTimeout(state.navbarHideTimer); state.navbarHideTimer = setTimeout(() => { DOM.navbar.classList.remove('visible'); }, 3000); }
            }

            function toggleTocPanel() {
                const isVisible = !DOM.tocPanel.classList.contains('visible');
                DOM.tocPanel.classList.toggle('visible', isVisible);
                DOM.overlay.classList.toggle('visible', isVisible);
                if (isVisible) {
                    DOM.settingsPanel.classList.remove('visible');
                    DOM.chatPanel.classList.remove('visible');
                    const activeItem = DOM.tocContent.querySelector('.toc-active');
                    if (activeItem) {
                        setTimeout(() => activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' }), 150);
                    }
                }
            }
            function closeTocPanel() { DOM.tocPanel.classList.remove('visible'); if (!DOM.settingsPanel.classList.contains('visible') && !DOM.chatPanel.classList.contains('visible')) DOM.overlay.classList.remove('visible'); }

            function toggleSettingsPanel() {
                const isVisible = !DOM.settingsPanel.classList.contains('visible');
                DOM.settingsPanel.classList.toggle('visible', isVisible);
                DOM.overlay.classList.toggle('visible', isVisible);
                 if (isVisible) { DOM.tocPanel.classList.remove('visible'); DOM.chatPanel.classList.remove('visible'); }
            }
            function closeSettingsPanel() { DOM.settingsPanel.classList.remove('visible'); if (!DOM.tocPanel.classList.contains('visible') && !DOM.chatPanel.classList.contains('visible')) DOM.overlay.classList.remove('visible'); }

            function toggleChatPanel() {
                const isVisible = !DOM.chatPanel.classList.contains('visible');
                DOM.chatPanel.classList.toggle('visible', isVisible);
                DOM.overlay.classList.toggle('visible', isVisible);
                 if (isVisible) {
                     DOM.tocPanel.classList.remove('visible');
                     DOM.settingsPanel.classList.remove('visible');
                     // Show initial suggestions only if chat is empty/new
                     if (state.chatHistory.length <= 1) {
                         renderSuggestedQuestions(initialSuggestedQuestions);
                     } else {
                         // Otherwise, maybe show last suggestions or clear them
                         // For now, let's clear them if panel was closed and reopened without new message
                         // renderSuggestedQuestions([]); // Or keep the last ones? Let's keep them for now.
                     }
                     DOM.chatInput.focus();
                 } else {
                     // Clear suggestions when panel is explicitly closed
                     renderSuggestedQuestions([]);
                 }
            }
            function closeChatPanel() {
                DOM.chatPanel.classList.remove('visible');
                if (!DOM.tocPanel.classList.contains('visible') && !DOM.settingsPanel.classList.contains('visible')) {
                    DOM.overlay.classList.remove('visible');
                }
                renderSuggestedQuestions([]); // Clear suggestions on close
            }


            function closeAllPanels() {
                closeTocPanel();
                closeSettingsPanel();
                closeChatPanel();
            }

            function showAiCleanupModal() {
                if (!state.session) { showToast("Please sign in to use AI features.", 3000); return; }
                if (!state.userApiSettings || !state.userApiSettings.api_key) { showToast("Gemini API key needed for AI Cleanup. Configure in dashboard.", 4000); return; }
                DOM.aiCleanupList.innerHTML = '<p>Loading suggestions...</p>';
                DOM.aiCleanupModal.classList.add('visible');
                DOM.aiCleanupBackdrop.classList.add('visible');
                state.isAiCleanupModalOpen = true;
                DOM.aiCleanupConfirmBtn.disabled = true;
                DOM.aiCleanupConfirmBtn.classList.add('loading');
                fetchAllUserBooks()
                    .then(allBooks => {
                        if (!allBooks || allBooks.length === 0) { DOM.aiCleanupList.innerHTML = '<p>Your library is empty. Nothing to clean up!</p>'; DOM.aiCleanupConfirmBtn.disabled = true; DOM.aiCleanupConfirmBtn.classList.remove('loading'); return; }
                        return generateCleanupSuggestions(allBooks);
                    })
                    .then(suggestedBooks => { if (suggestedBooks) populateAiCleanupModal(suggestedBooks); })
                    .catch(error => { console.error("Error during AI Cleanup:", error); DOM.aiCleanupList.innerHTML = `<p>Error generating suggestions: ${error.message}</p>`; DOM.aiCleanupConfirmBtn.disabled = true; DOM.aiCleanupConfirmBtn.classList.remove('loading'); });
            }

            function hideAiCleanupModal() { DOM.aiCleanupModal.classList.remove('visible'); DOM.aiCleanupBackdrop.classList.remove('visible'); state.isAiCleanupModalOpen = false; }

            async function fetchAllUserBooks() {
                if (!state.session) return [];
                try {
                    const { data: books, error } = await supabase.from('ebooks').select('id, title, file_type, metadata, last_position, updated_at, raw_content').eq('user_id', state.session.user.id).order('updated_at', { ascending: true });
                    if (error) throw error;
                    return books || [];
                } catch (error) { console.error("Error fetching all user books:", error); showToast("Could not fetch library for cleanup.", 3000); return []; }
            }

            async function generateCleanupSuggestions(books) {
                 const today = new Date().toISOString().split('T')[0];
                 const bookDataForPrompt = books.map(book => ({ id: book.id, title: book.title.substring(0, 80), progress: calculateOverallProgress(book), last_read: book.last_position?.timestamp ? new Date(book.last_position.timestamp).toISOString().split('T')[0] : new Date(book.updated_at).toISOString().split('T')[0] }));
                 const maxBooksInPrompt = 150;
                 const booksToSend = bookDataForPrompt.slice(0, maxBooksInPrompt);
                 const prompt = `Analyze the following list of ebooks from a user's library. Identify books that are strong candidates for deletion based on these criteria:\n\nToday's date is: ${today}\n\n1.  **Old & Unread:** Books last read over 1 year ago (before ${today.substring(0, 4)}-${today.substring(5, 7)}-${today.substring(8)}) AND have less than 5% progress.\n2.  **Fully Read:** Books with 98% or more progress.\n3.  **Likely Test/Temporary Items:** Books with very short titles (e.g., "test", "untitled", "url", or just a raw URL) that haven't been read recently (e.g., last read > 3 months ago).\n4.  **Duplicates:** Books with identical or very similar titles where one has significantly less progress or hasn't been read for much longer. Prioritize keeping the one with more progress or more recent activity.\n5.  **Old News:** Books whose titles clearly indicate they are news articles (e.g., contain "News", "Daily", "Update") and were last read more than 1 week ago (before ${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}).\n\n**Constraint:** Do NOT suggest deleting items last read within the last 7 days (i.e., on or after ${new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}), regardless of other criteria, unless they are clearly fully read (>=98% progress).\n\nHere is the list of books (id, title, progress percentage, last read date YYYY-MM-DD):\n---\n${JSON.stringify(booksToSend, null, 2)}\n---\n\nReturn ONLY a JSON array containing the integer IDs of the books you suggest for deletion based *strictly* on the criteria above. Do not include any explanations or other text. Ensure the constraint about recent items is respected.\n\nExample Output: [123, 456, 789]\n\nJSON Output:`;
                 const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                 try {
                     const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);
                     if (response.error) throw new Error(response.error.message);
                     const resultText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '[]';
                     let suggestedIds = [];
                     try {
                         const jsonMatch = resultText.match(/\[.*?\]/s);
                         if (jsonMatch) { suggestedIds = JSON.parse(jsonMatch[0]).map(id => Number(id)).filter(id => !isNaN(id)); }
                         else { console.warn("AI did not return a valid JSON array for cleanup suggestions.", resultText); }
                     } catch (jsonError) { console.error('Error parsing cleanup suggestions JSON:', jsonError, resultText); throw new Error("AI returned invalid format for suggestions."); }
                     return books.filter(book => suggestedIds.includes(book.id));
                 } catch (error) { console.error('Error generating cleanup suggestions:', error); throw error; }
            }

            function populateAiCleanupModal(suggestedBooks) {
                DOM.aiCleanupList.innerHTML = '';
                if (!suggestedBooks || suggestedBooks.length === 0) { DOM.aiCleanupList.innerHTML = '<p>AI didn\'t find any items matching the cleanup criteria. Your library looks tidy!</p>'; DOM.aiCleanupConfirmBtn.disabled = true; DOM.aiCleanupConfirmBtn.classList.remove('loading'); return; }
                const introText = document.createElement('p');
                introText.textContent = `AI suggests removing the following ${suggestedBooks.length} items. Uncheck any you want to keep:`;
                DOM.aiCleanupList.appendChild(introText);
                suggestedBooks.forEach(book => {
                    const itemDiv = document.createElement('div'); itemDiv.className = 'cleanup-item';
                    const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.checked = true; checkbox.value = book.id; checkbox.id = `cleanup-book-${book.id}`;
                    const detailsDiv = document.createElement('div'); detailsDiv.className = 'cleanup-item-details';
                    const titleDiv = document.createElement('div'); titleDiv.className = 'cleanup-item-title'; titleDiv.textContent = book.title; titleDiv.title = book.title;
                    const metaDiv = document.createElement('div'); metaDiv.className = 'cleanup-item-meta'; const progress = calculateOverallProgress(book); const lastRead = book.last_position?.timestamp ? `Last read: ${new Date(book.last_position.timestamp).toLocaleDateString()}` : `Added: ${new Date(book.updated_at).toLocaleDateString()}`; metaDiv.textContent = `Progress: ${progress}% • ${lastRead}`;
                    detailsDiv.appendChild(titleDiv); detailsDiv.appendChild(metaDiv);
                    const label = document.createElement('label'); label.htmlFor = checkbox.id; label.style.display = 'flex'; label.style.alignItems = 'center'; label.style.width = '100%'; label.style.cursor = 'pointer'; label.appendChild(checkbox); label.appendChild(detailsDiv);
                    itemDiv.appendChild(label); DOM.aiCleanupList.appendChild(itemDiv);
                });
                DOM.aiCleanupConfirmBtn.disabled = false;
                DOM.aiCleanupConfirmBtn.classList.remove('loading');
            }

            async function handleAiCleanupConfirm() {
                const checkboxes = DOM.aiCleanupList.querySelectorAll('input[type="checkbox"]:checked');
                const idsToDelete = Array.from(checkboxes).map(cb => parseInt(cb.value, 10));
                if (idsToDelete.length === 0) { showToast("No items selected for deletion.", 2000); hideAiCleanupModal(); return; }
                if (!confirm(`Are you sure you want to permanently delete ${idsToDelete.length} selected item(s)?`)) return;
                DOM.aiCleanupConfirmBtn.disabled = true;
                DOM.aiCleanupConfirmBtn.classList.add('loading');
                showToast(`Deleting ${idsToDelete.length} items...`, 3000);
                try {
                    const { error } = await supabase.from('ebooks').delete().in('id', idsToDelete);
                    if (error) throw error;
                    showToast(`Successfully deleted ${idsToDelete.length} items.`, 3000);
                    hideAiCleanupModal();
                    loadUserLibrary();
                } catch (error) { console.error("Error deleting books:", error); showToast(`Error deleting items: ${error.message}`, 4000); DOM.aiCleanupConfirmBtn.disabled = false; DOM.aiCleanupConfirmBtn.classList.remove('loading'); }
            }

            function goToHome() {
                DOM.welcomeScreen.style.display = 'flex';
                DOM.navbar.classList.remove('visible');
                closeAllPanels();
                DOM.fileInput.value = '';
                DOM.textInput.value = '';
                DOM.textInputTitle.value = '';
                state.bookData = { title: '', content: '', chapters: [], currentPosition: 0, sourceUrl: null, rawContent: null };
                state.selectedListId = 'all';
                state.bookLists = [];
                DOM.sourceUrlDisplay.style.display = 'none';
                 checkAuthAndLoadApiSettings();
            }

            function handleContentClick(e) {
                 if (!state.settings.viewRawHtmlEnabled) {
                     const link = e.target.closest('a');

                     if (link && link.href && DOM.contentArea.contains(link)) {
                         e.preventDefault();
                         const url = link.href;

                         if (url.startsWith('http://') || url.startsWith('https://')) {
                             const linkText = link.textContent || url;
                             showLinkActionConfirmation(url, linkText);
                         } else {
                             console.warn(`Link is not directly scrapable or is internal: ${url}`);
                             showToast(`Cannot scrape this type of link: ${url.substring(0, 30)}...`, 3000);
                         }
                         return;
                     }
                 }

                const selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) return;
                const clickY = e.clientY;
                const viewportHeight = window.innerHeight;
                if (DOM.navbar.classList.contains('visible')) { if (!DOM.navbar.contains(e.target)) DOM.navbar.classList.remove('visible'); }
                else if (clickY <= viewportHeight * 0.15) { toggleNavbar(); }

                if (!DOM.translationPopup.contains(e.target)) {
                     DOM.translationPopup.classList.remove('visible');
                     setTimeout(() => { DOM.translationPopup.style.display = 'none'; }, 200);
                }
            }

            function handleTextSelection() {
                const translationEnabled = DOM.translationToggle.checked;
                if (!translationEnabled) return;
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                if (!selectedText) { DOM.translationPopup.style.display = 'none'; clearTimeout(state.translationTimer); return; }
                if (selectedText.length > 1 && selectedText.length < 500) {
                    clearTimeout(state.translationTimer);
                    state.translationTimer = setTimeout(() => {
                        if (window.getSelection().toString().trim() !== selectedText) return;
                        const range = selection.getRangeAt(0);
                        const rect = range.getBoundingClientRect();
                        state.lastSelectionRect = rect;
                        positionTranslationPopup(rect);
                        DOM.translationContent.textContent = 'Translating...';
                        DOM.translationLoading.style.display = 'flex';
                        if (state.settings.speakSelectionEnabled) speakText(selectedText);
                        translateText(selectedText);
                    }, 750);
                } else {
                     DOM.translationPopup.classList.remove('visible');
                     setTimeout(() => { DOM.translationPopup.style.display = 'none'; }, 200);
                     clearTimeout(state.translationTimer);
                }
            }

            function positionTranslationPopup(rect) {
                const popup = DOM.translationPopup;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                popup.style.display = 'block';
                popup.classList.remove('visible');

                requestAnimationFrame(() => {
                    popup.style.opacity = '0';
                    popup.style.transform = 'translateY(10px)';

                    const popupWidth = popup.offsetWidth;
                    const popupHeight = popup.offsetHeight;
                    let leftPos = rect.left + window.scrollX + (rect.width / 2) - (popupWidth / 2);
                    let topPos = rect.bottom + window.scrollY + 10;

                    leftPos = Math.max(10, Math.min(leftPos, viewportWidth - popupWidth - 10));

                    if (topPos + popupHeight > viewportHeight + window.scrollY - 10) {
                        topPos = rect.top + window.scrollY - popupHeight - 10;
                        if (topPos < window.scrollY) {
                            topPos = rect.top + window.scrollY;
                             if (rect.right + popupWidth < viewportWidth - 10) {
                                leftPos = rect.right + window.scrollX + 10;
                            } else {
                                leftPos = rect.left + window.scrollX - popupWidth - 10;
                                leftPos = Math.max(10, leftPos);
                            }
                        }
                    }

                    popup.style.left = `${leftPos}px`;
                    popup.style.top = `${topPos}px`;

                    requestAnimationFrame(() => {
                         popup.style.opacity = '1';
                         popup.style.transform = 'translateY(0)';
                         popup.classList.add('visible');
                    });
                });
            }

            function decreaseFontSize() { if (state.settings.fontSize > 70) { state.settings.fontSize -= 10; updateFontSize(); } else { showToast('Minimum font size reached'); } }
            function increaseFontSize() { if (state.settings.fontSize < 200) { state.settings.fontSize += 10; updateFontSize(); } else { showToast('Maximum font size reached'); } }
            function updateFontSize() { DOM.fontSizeValue.textContent = `${state.settings.fontSize}%`; localStorage.setItem('ebook-fontsize', state.settings.fontSize); updateCssVariables(); }
            function decreaseLineHeight() { if (state.settings.lineHeight > 1.2) { state.settings.lineHeight = Math.round((state.settings.lineHeight - 0.1) * 10) / 10; updateLineHeight(); } else { showToast('Minimum line height reached'); } }
            function increaseLineHeight() { if (state.settings.lineHeight < 2.4) { state.settings.lineHeight = Math.round((state.settings.lineHeight + 0.1) * 10) / 10; updateLineHeight(); } else { showToast('Maximum line height reached'); } }
            function updateLineHeight() { DOM.lineHeightValue.textContent = state.settings.lineHeight; localStorage.setItem('ebook-lineheight', state.settings.lineHeight); updateCssVariables(); }

            function setTheme(theme) { document.body.className = `${theme}-theme`; DOM.themeOptions.forEach(option => { option.classList.remove('active'); if (option.getAttribute('data-theme') === theme) option.classList.add('active'); }); state.settings.theme = theme; localStorage.setItem('ebook-theme', theme); }

            function updateProgressBar() {
                 if (!DOM.contentArea || !DOM.progressBar || !state.bookData.chapters || state.bookData.chapters.length === 0) {
                     if(DOM.progressBar) DOM.progressBar.style.width = '0%';
                     return;
                 }

                 const scrollTop = DOM.contentArea.scrollTop;
                 const scrollHeight = DOM.contentArea.scrollHeight;
                 const clientHeight = DOM.contentArea.clientHeight;

                 let chapterProgress = 0;
                 if (scrollHeight > clientHeight) {
                     chapterProgress = scrollTop / (scrollHeight - clientHeight);
                 } else if (scrollTop >= 0) {
                    chapterProgress = (scrollHeight <= clientHeight && scrollTop === 0) ? 0 : 1;
                 }
                 chapterProgress = Math.max(0, Math.min(1, chapterProgress));

                 const totalChapters = state.bookData.chapters.length;
                 const currentChapterIndex = state.bookData.currentPosition;

                 let overallProgress = 0;
                 if (totalChapters > 0) {
                     overallProgress = (currentChapterIndex / totalChapters) + (chapterProgress / totalChapters);
                 }

                 overallProgress = Math.max(0, Math.min(1, overallProgress));

                 DOM.progressBar.style.width = `${overallProgress * 100}%`;

                 debounce(saveReadingProgress, 1500)();
            }

            function saveReadingProgress() {
                 if (!state.bookData.chapters || state.bookData.chapters.length === 0) return;

                 const percentComplete = calculatePercentageComplete();
                 const currentPosition = {
                     chapter: state.bookData.currentPosition,
                     percentComplete: percentComplete,
                     scroll: DOM.contentArea.scrollTop || 0,
                     timestamp: new Date().getTime(),
                     textAnchor: findVisibleTextAnchor()
                 };
                 state.lastPosition = currentPosition;
                 saveBookToLibrary();
            }

            function calculatePercentageComplete() {
                const scrollTop = DOM.contentArea.scrollTop;
                const scrollHeight = DOM.contentArea.scrollHeight;
                const clientHeight = DOM.contentArea.clientHeight;
                if (scrollHeight <= clientHeight) {
                     return scrollTop === 0 ? 0 : 1;
                }
                return Math.max(0, Math.min(1, scrollTop / (scrollHeight - clientHeight)));
            }

            function findVisibleTextAnchor() {
                 const paragraphs = DOM.contentArea.querySelectorAll('p[data-p-index]');
                 const scrollTop = DOM.contentArea.scrollTop;
                 const contentTop = DOM.contentArea.getBoundingClientRect().top;
                 const viewportHeight = DOM.contentArea.clientHeight;

                 if (paragraphs.length === 0) return null;

                 for (let i = 0; i < paragraphs.length; i++) {
                     const p = paragraphs[i];
                     const rect = p.getBoundingClientRect();
                     const pTopInViewport = rect.top;
                      if (pTopInViewport >= contentTop && pTopInViewport < contentTop + viewportHeight / 3) {
                         const text = p.textContent?.substring(0, 50).trim() || '';
                         const offset = Math.max(0, Math.min(1, (contentTop - pTopInViewport) / rect.height));
                         return { index: parseInt(p.getAttribute('data-p-index')), text: text, offset: offset };
                     }
                 }

                  const firstP = paragraphs[0];
                 return {
                     index: parseInt(firstP.getAttribute('data-p-index')) || 0,
                     text: firstP.textContent?.substring(0, 50).trim() || '',
                     offset: 0
                 };
            }


            function showLoading() { DOM.loading.classList.add('visible'); }
            function hideLoading() { DOM.loading.classList.remove('visible'); }
            function showToast(message, duration = 3000) { const toast = DOM.toast; toast.textContent = message; toast.classList.add('visible'); setTimeout(() => { toast.classList.remove('visible'); }, duration); }
            function debounce(func, delay) { const context = this; return function() { const args = arguments; const functionName = func.name || 'anonymous'; clearTimeout(state.debounceTimers[functionName]); state.debounceTimers[functionName] = setTimeout(() => { func.apply(context, args); delete state.debounceTimers[functionName]; }, delay); }; }

            async function checkAuthAndLoadApiSettings() {
                const { data: { session } } = await supabase.auth.getSession();
                state.session = session;
                if (!session) {
                    DOM.loginBtn.classList.remove('hidden');
                    DOM.authSection.innerHTML = `<p>Sign in to save books to your library.</p>`;
                    DOM.librarySection.style.display = 'none';
                    renderListBadges();
                    updateAiFeatureAvailability(null);
                    return;
                }

                 DOM.loginBtn.classList.add('hidden');
                 DOM.authSection.innerHTML = `<p>Signed in as ${session.user.email}</p>`;
                 DOM.librarySection.style.display = 'flex';

                 state.userApiSettings = await getUserApiSettings();
                 updateAiFeatureAvailability(state.userApiSettings);

                 await fetchBookLists();
                 loadUserLibrary();
            }

            function updateAiFeatureAvailability(apiSettings) {
                let canUseAi = false;
                let canUseFirecrawl = false;
                 let apiStatusHtml = '<div id="api-status-container">';

                if (apiSettings) {
                    canUseAi = !!(apiSettings.api_key && apiSettings.model);
                    canUseFirecrawl = !!apiSettings.firecrawl_api_key;

                    apiStatusHtml += `<div class="api-status-item"><span class="status-icon">${canUseAi ? '✅' : '❌'}</span><span class="status-text">Gemini API ${canUseAi ? `configured (Model: ${escapeHTML(apiSettings.model)})` : `not configured. <a href="index.html" target="_blank">Set up</a>.`}</span></div>`;
                    apiStatusHtml += `<div class="api-status-item"><span class="status-icon">${canUseFirecrawl ? '✅' : '❌'}</span><span class="status-text">Firecrawl API ${canUseFirecrawl ? 'configured' : `not configured. <a href="index.html" target="_blank">Set up</a>.`}</span></div>`;
                 } else {
                     apiStatusHtml += `<div class="api-status-item"><span class="status-icon">⚠️</span><span class="status-text">Sign in and <a href="index.html" target="_blank">configure API keys</a> in the dashboard to enable AI features.</span></div>`;
                 }
                apiStatusHtml += '</div>';

                DOM.aiSettingsContent.innerHTML = apiStatusHtml;

                 DOM.translationToggle.disabled = !canUseAi;
                 DOM.chatBtn.disabled = !canUseAi;
                 DOM.summarizeChapterBtn.style.display = canUseAi ? 'block' : 'none';
                 DOM.aiCleanupBtn.style.display = canUseAi ? 'inline-flex' : 'none';
                 DOM.aiCleanupBtn.disabled = !canUseAi;

                 DOM.processUrlBtn.disabled = !canUseFirecrawl;
                 DOM.urlInput.disabled = !canUseFirecrawl;
                 DOM.urlInput.placeholder = canUseFirecrawl ? "Enter a URL to read" : "Firecrawl API key needed";

                 const setDisabledStyle = (el, disabled, title) => {
                     el.style.opacity = disabled ? "0.5" : "1";
                     el.style.cursor = disabled ? "not-allowed" : "pointer";
                     el.title = disabled ? title : (el.dataset.originalTitle || '');
                 };

                 setDisabledStyle(DOM.chatBtn, !canUseAi, "Gemini API key needed for chat.");
                 setDisabledStyle(DOM.aiCleanupBtn, !canUseAi, "Gemini API key needed for AI Cleanup.");
                 setDisabledStyle(DOM.summarizeChapterBtn, !canUseAi, "Gemini API key needed for Summarization.");
                 DOM.translationToggle.closest('.settings-row').title = !canUseAi ? "Gemini API key needed for translation." : "";
                 DOM.translationToggle.style.cursor = !canUseAi ? "not-allowed" : "pointer";

                 setDisabledStyle(DOM.processUrlBtn, !canUseFirecrawl, "Firecrawl API key needed to process URLs.");
                 DOM.urlInputContainer.title = !canUseFirecrawl ? "Firecrawl API key needed. Set it up in the main dashboard." : "";

                 if (!DOM.chatBtn.dataset.originalTitle) DOM.chatBtn.dataset.originalTitle = DOM.chatBtn.title;
                 if (!DOM.aiCleanupBtn.dataset.originalTitle) DOM.aiCleanupBtn.dataset.originalTitle = DOM.aiCleanupBtn.title;
                 if (!DOM.summarizeChapterBtn.dataset.originalTitle) DOM.summarizeChapterBtn.dataset.originalTitle = DOM.summarizeChapterBtn.title;
            }


            async function getUserApiSettings() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return null;
                try {
                    const { data, error } = await supabase.from('user_settings').select('api_key, model, firecrawl_api_key').eq('user_id', session.user.id).maybeSingle();
                    if (error) { console.error('Error fetching API settings:', error); return null; }
                    return data;
                } catch (err) {
                    console.error('Exception fetching API settings:', err);
                    return null;
                }
            }

            function toggleCreateListInput() {
                if (!state.isCreatingList) { DOM.newListNameInput.style.display = 'block'; DOM.newListNameInput.focus(); DOM.createListBtn.textContent = '✓'; state.isCreatingList = true; }
                else { handleCreateList(); }
            }

            function cancelListCreation() { DOM.newListNameInput.style.display = 'none'; DOM.newListNameInput.value = ''; DOM.createListBtn.textContent = '+'; state.isCreatingList = false; }

            async function loadUserLibrary() {
                 const { data: { session } } = await supabase.auth.getSession();
                 if (!session) return;

                 const libraryList = document.getElementById('library-list');
                 libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Loading books...</div>';

                 const listInfoMap = new Map(state.bookLists.map((list, index) => [list.id, { name: list.name, index: index }]));
                 const badgeColors = 5;

                 try {
                     let query = supabase.from('ebooks')
                         .select('id, title, file_type, metadata, list_id, last_position, updated_at, raw_content')
                         .eq('user_id', session.user.id);

                     if (state.selectedListId === 'all') {
                     } else if (state.selectedListId === null || state.selectedListId === '') {
                         query = query.is('list_id', null);
                     } else {
                         query = query.eq('list_id', state.selectedListId);
                     }

                     query = query.order('updated_at', { ascending: false });

                     const { data: books, error } = await query;
                     if (error) throw error;

                     if (!books || books.length === 0) {
                         const filterText = state.selectedListId === 'all' ? 'library' :
                                            (state.selectedListId === null ? '"Unlisted"' : `"${listInfoMap.get(parseInt(state.selectedListId))?.name || 'Selected'}" list`);
                         libraryList.innerHTML = `<div style="text-align: center; padding: 20px;">Your ${filterText} is empty</div>`;
                         return;
                     }

                     libraryList.innerHTML = '';
                     books.forEach(book => {
                         const date = new Date(book.last_position?.timestamp || book.updated_at).toLocaleDateString();
                         const progress = calculateOverallProgress(book);
                         const listInfo = book.list_id ? listInfoMap.get(book.list_id) : null;
                         const listName = listInfo ? listInfo.name : null;
                         let listBadgeHtml = '';

                         if (listName) {
                             const colorIndex = (listInfo.index + 1) % badgeColors;
                             listBadgeHtml = `<span class="library-item-list-badge" data-color-index="${colorIndex}" title="List: ${escapeHTML(listName)}">${escapeHTML(listName)}</span>`;
                         } else {
                             listBadgeHtml = `<span class="library-item-list-badge" title="Unlisted">Unlisted</span>`;
                         }

                         const item = document.createElement('div');
                         item.className = 'library-item';
                         item.innerHTML = `
                            <div class="library-item-details">
                                <div class="library-item-title-container">
                                    <div class="library-item-title">${escapeHTML(book.title)}</div>
                                    ${listBadgeHtml}
                                </div>
                                <div class="library-item-meta">${book.file_type?.toUpperCase() || 'BOOK'} • Last interaction: ${date} • ${progress}%</div>
                                <div class="progress-bar-container">
                                    <div class="progress-bar" style="width: ${progress}%"></div>
                                </div>
                            </div>
                            <div class="library-item-actions" style="position: relative;">
                                <button class="library-item-move" data-id="${book.id}" data-current-list-id="${book.list_id || ''}" style="display: none;">Move</button>
                                <div class="move-list-dropdown"></div>
                                <button class="library-item-delete" data-id="${book.id}" aria-label="Delete Book">×</button>
                            </div>`;

                         item.addEventListener('click', (event) => {
                             if (event.target.closest('.library-item-delete, .library-item-move, .move-list-dropdown')) return;
                             loadBookFromLibrary(book);
                         });

                         libraryList.appendChild(item);

                         const moveButton = item.querySelector('.library-item-move');
                         const dropdownContainer = item.querySelector('.move-list-dropdown');
                         if (moveButton && dropdownContainer && state.bookLists.length > 0) {
                             moveButton.style.display = 'inline-block';
                             moveButton.addEventListener('click', (event) => {
                                 event.stopPropagation();
                                 document.querySelectorAll('.move-list-dropdown.visible').forEach(dd => {
                                     if (dd !== dropdownContainer) dd.classList.remove('visible');
                                 });
                                 const isVisible = dropdownContainer.classList.toggle('visible');
                                 if (isVisible) {
                                     const bookId = moveButton.getAttribute('data-id');
                                     const currentListId = moveButton.getAttribute('data-current-list-id') || null;
                                     renderMoveToListDropdown(dropdownContainer, bookId, currentListId);
                                 }
                             });
                         }

                         const deleteButton = item.querySelector('.library-item-delete');
                         deleteButton.addEventListener('click', async (event) => {
                             event.stopPropagation();
                             const bookId = deleteButton.getAttribute('data-id');
                             if (confirm('Remove this book from your library? This cannot be undone.')) {
                                 await deleteBookFromLibrary(bookId);
                             }
                         });
                     });

                 } catch (error) {
                     console.error('Error loading library:', error);
                     libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Error loading library</div>';
                 }
            }

            async function fetchBookLists() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                try {
                    const { data, error } = await supabase.from('book_lists').select('id, name').eq('user_id', session.user.id).order('name', { ascending: true });
                    if (error) throw error;
                    state.bookLists = data || [];
                    renderListBadges();
                } catch (error) { console.error('Error fetching book lists:', error); showToast('Could not load book lists'); state.bookLists = []; renderListBadges(); }
            }

            function renderListBadges() {
                DOM.listBadgeContainer.innerHTML = '';
                const badgeColors = 5;

                 const createBadge = (text, listId, isSpecial = false, colorIndex = -1) => {
                     const badge = document.createElement('div');
                     badge.className = 'list-badge';
                     badge.textContent = text;
                     const dataListIdValue = listId === null ? '' : String(listId);
                     badge.setAttribute('data-list-id', dataListIdValue);

                     const currentIdStr = state.selectedListId === null ? '' : String(state.selectedListId);
                     if (currentIdStr === dataListIdValue) {
                         badge.classList.add('active');
                     }

                     if (!isSpecial && colorIndex >= 0) {
                         badge.setAttribute('data-color-index', colorIndex % badgeColors);
                     } else if (isSpecial && listId === 'all') {
                          badge.setAttribute('data-color-index', 0);
                     }

                     return badge;
                 };

                 DOM.listBadgeContainer.appendChild(createBadge('All', 'all', true, 0));
                 DOM.listBadgeContainer.appendChild(createBadge('Unlisted', null, true));

                 state.bookLists.forEach((list, index) => {
                     DOM.listBadgeContainer.appendChild(createBadge(list.name, list.id, false, index + 1));
                 });
            }


            function handleListBadgeClick(event) {
                 const clickedBadge = event.target.closest('.list-badge');
                 if (!clickedBadge || clickedBadge.classList.contains('active')) return;

                 const selectedValue = clickedBadge.getAttribute('data-list-id');

                 if (selectedValue === 'all') {
                     state.selectedListId = 'all';
                 } else if (selectedValue === '') {
                     state.selectedListId = null;
                 } else {
                     state.selectedListId = parseInt(selectedValue, 10);
                 }

                 DOM.listBadgeContainer.querySelectorAll('.list-badge').forEach(badge => badge.classList.remove('active'));
                 clickedBadge.classList.add('active');

                 loadUserLibrary();
            }

            async function handleCreateList() {
                const listName = DOM.newListNameInput.value.trim();
                if (!listName) { showToast('Please enter a name for the new list.'); DOM.newListNameInput.focus(); return; }
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) { showToast('Please sign in to create lists.'); return; }
                DOM.createListBtn.disabled = true; DOM.createListBtn.classList.add('loading'); DOM.createListBtn.textContent = '...';
                try {
                    const { data, error } = await supabase.from('book_lists').insert({ user_id: session.user.id, name: listName }).select().single();
                    if (error) { if (error.code === '23505') throw new Error(`List "${listName}" already exists.`); else throw error; }
                    showToast(`List "${listName}" created.`);
                    cancelListCreation();
                    await fetchBookLists();
                } catch (error) { console.error('Error creating list:', error); showToast(`Error: ${error.message}`); DOM.createListBtn.disabled = false; DOM.createListBtn.classList.remove('loading'); DOM.createListBtn.textContent = '✓'; DOM.newListNameInput.focus(); }
                finally {
                     if (DOM.createListBtn.classList.contains('loading')) {
                         DOM.createListBtn.disabled = false;
                         DOM.createListBtn.classList.remove('loading');
                         DOM.createListBtn.textContent = state.isCreatingList ? '✓' : '+';
                     }
                }
            }

            function renderMoveToListDropdown(dropdownElement, bookId, currentListIdStr) {
                dropdownElement.innerHTML = '';

                 const currentListId = (currentListIdStr === '' || currentListIdStr === 'null' || currentListIdStr === null)
                     ? null
                     : parseInt(currentListIdStr, 10);

                 const unlistedOption = document.createElement('div');
                 unlistedOption.className = 'move-list-option';
                 unlistedOption.textContent = 'Unlisted';
                 unlistedOption.setAttribute('data-target-list-id', '');
                 if (currentListId === null) {
                     unlistedOption.classList.add('disabled');
                     unlistedOption.title = 'Already Unlisted';
                 } else {
                     unlistedOption.addEventListener('click', (e) => {
                         e.stopPropagation();
                         moveBookToList(bookId, null);
                         dropdownElement.classList.remove('visible');
                     });
                 }
                 dropdownElement.appendChild(unlistedOption);

                 if (state.bookLists.length > 0) {
                     const separator = document.createElement('hr');
                     separator.style.margin = '2px 0';
                     separator.style.borderColor = 'var(--border-color)';
                     dropdownElement.appendChild(separator);
                 }

                 state.bookLists.forEach(list => {
                     const option = document.createElement('div');
                     option.className = 'move-list-option';
                     option.textContent = list.name;
                     option.setAttribute('data-target-list-id', list.id);
                     if (list.id === currentListId) {
                         option.classList.add('disabled');
                         option.title = 'Already in this list';
                     } else {
                         option.addEventListener('click', (e) => {
                             e.stopPropagation();
                             moveBookToList(bookId, list.id);
                             dropdownElement.classList.remove('visible');
                         });
                     }
                     dropdownElement.appendChild(option);
                 });
            }

            async function moveBookToList(bookId, targetListId) {
                 showLoading();
                 try {
                     const { error } = await supabase.from('ebooks').update({
                         list_id: targetListId,
                         updated_at: new Date()
                     }).eq('id', bookId);
                     if (error) throw error;
                     showToast("Book moved successfully.");
                     loadUserLibrary();
                 } catch (error) {
                     console.error('Error moving book:', error);
                     showToast("Error moving book.");
                 } finally {
                     hideLoading();
                 }
            }

            async function deleteBookFromLibrary(bookId) {
                showLoading();
                try {
                    const { error } = await supabase.from('ebooks').delete().eq('id', bookId);
                    if (error) throw error;
                    loadUserLibrary();
                    showToast('Book removed from library');
                } catch (error) { console.error('Error deleting book:', error); showToast('Could not delete the book'); }
                finally { hideLoading(); }
            }

             async function saveBookToLibrary() {
                 const { data: { session } } = await supabase.auth.getSession();
                 if (!session || !state.bookData.title || !state.bookData.chapters || state.bookData.chapters.length === 0) {
                      return false;
                 }

                 try {
                     let fileType = 'unknown';
                     if (state.bookData.sourceUrl) {
                         fileType = 'url';
                     } else if (state.bookData.title.includes('.')) {
                         fileType = state.bookData.title.split('.').pop().toLowerCase();
                          const knownTypes = ['txt', 'epub', 'pdf', 'url'];
                          if (!knownTypes.includes(fileType)) {
                             fileType = 'text';
                          }
                     } else {
                          fileType = 'text';
                     }

                     const metadata = {
                         chapters: state.bookData.chapters.map(chapter => ({
                             title: chapter.title,
                             content: chapter.content || null,
                             markdownContent: chapter.markdownContent || null,
                             startLine: chapter.startLine,
                             endLine: chapter.endLine
                         })),
                         viewRawHtmlEnabled: state.settings.viewRawHtmlEnabled,
                         sourceUrl: state.bookData.sourceUrl
                     };

                     const lastPosition = state.lastPosition || {
                         chapter: state.bookData.currentPosition,
                         scroll: DOM.contentArea.scrollTop || 0,
                         percentComplete: calculatePercentageComplete(),
                         timestamp: new Date().getTime(),
                         textAnchor: findVisibleTextAnchor()
                     };

                     const bookRecord = {
                         user_id: session.user.id,
                         title: state.bookData.title,
                         content: null,
                         raw_content: state.bookData.rawContent || null,
                         file_type: fileType,
                         metadata: metadata,
                         last_position: lastPosition,
                         list_id: state.bookData.currentListId || null,
                         updated_at: new Date()
                     };

                     let existingBookQuery = supabase.from('ebooks')
                         .select('id')
                         .eq('user_id', session.user.id)
                         .eq('title', state.bookData.title);

                     if (state.bookData.currentListId === null) {
                         existingBookQuery = existingBookQuery.is('list_id', null);
                     } else {
                         existingBookQuery = existingBookQuery.eq('list_id', state.bookData.currentListId);
                     }

                     const { data: existingBook, error: checkError } = await existingBookQuery.maybeSingle();

                     if (checkError) {
                         console.error("Error checking for existing book:", checkError);
                         throw checkError;
                     }

                     if (existingBook && existingBook.id) {
                         const { error: updateError } = await supabase
                             .from('ebooks')
                             .update({
                                 raw_content: bookRecord.raw_content,
                                 metadata: bookRecord.metadata,
                                 last_position: bookRecord.last_position,
                                 updated_at: bookRecord.updated_at,
                                 file_type: bookRecord.file_type
                             })
                             .eq('id', existingBook.id);

                         if (updateError) {
                             console.error("Error updating book:", updateError);
                             throw updateError;
                         }
                     } else {
                         const { error: insertError } = await supabase
                             .from('ebooks')
                             .insert({
                                user_id: bookRecord.user_id,
                                title: bookRecord.title,
                                content: bookRecord.content,
                                raw_content: bookRecord.raw_content,
                                file_type: bookRecord.file_type,
                                metadata: bookRecord.metadata,
                                last_position: bookRecord.last_position,
                                list_id: bookRecord.list_id
                             });

                         if (insertError) {
                             console.error("Error inserting book:", insertError);
                             throw insertError;
                         }
                          console.log("Book saved to library:", bookRecord.title);
                     }

                     return true;
                 } catch (error) {
                     console.error('Error saving book to library:', error);
                     return false;
                 }
             }

             async function loadBookFromLibrary(book) {
                 showLoading();
                 try {
                     state.bookData.title = book.title;
                     state.bookData.currentListId = book.list_id || null;
                     state.bookData.rawContent = book.raw_content || null;
                     DOM.bookTitle.textContent = book.title;

                     if (book.metadata && book.metadata.chapters && book.metadata.chapters.length > 0) {
                         state.bookData.chapters = book.metadata.chapters.map(chapter => ({
                             title: chapter.title,
                             content: chapter.content || null,
                             markdownContent: chapter.markdownContent || null,
                             startLine: chapter.startLine,
                             endLine: chapter.endLine
                         }));
                         state.bookData.sourceUrl = book.metadata.sourceUrl || null;
                     } else {
                         state.bookData.chapters = [{ title: book.title, markdownContent: "[Content structure not found in metadata]", content: null, startLine: 0, endLine: 1 }];
                         state.bookData.sourceUrl = null;
                         console.warn("Book metadata missing or incomplete for:", book.title);
                     }

                     state.settings.viewRawHtmlEnabled = (book.metadata && book.metadata.viewRawHtmlEnabled !== undefined)
                         ? book.metadata.viewRawHtmlEnabled
                         : false;
                     DOM.viewRawHtmlToggle.checked = state.settings.viewRawHtmlEnabled;

                     const lastPosition = book.last_position || {};
                     state.bookData.currentPosition = lastPosition.chapter !== undefined ? lastPosition.chapter : 0;

                     showBook();

                     restoreReadingPosition(lastPosition);

                 } catch (error) {
                     console.error('Error loading book from library:', error);
                     showToast('Error loading book: ' + error.message);
                     goToHome();
                 } finally {
                     hideLoading();
                 }
             }


            function restoreReadingPosition(lastPosition) {
                 if (!lastPosition || !DOM.contentArea) return;

                 showToast('Restoring reading position...', 1500);

                 requestAnimationFrame(() => {
                     requestAnimationFrame(() => {
                         let restored = false;
                         const isPositionRecent = lastPosition.timestamp && (Date.now() - lastPosition.timestamp < 90 * 24 * 60 * 60 * 1000);

                         if (isPositionRecent && lastPosition.textAnchor && lastPosition.textAnchor.index !== undefined) {
                             restored = restoreByTextAnchor(lastPosition.textAnchor);
                             if (restored) {
                                 console.log(`Restored position using text anchor (Index: ${lastPosition.textAnchor.index}).`);
                                 updateProgressBar();
                                 return;
                             } else {
                                 console.warn("Failed to restore using text anchor, trying percentage.");
                             }
                         } else if (isPositionRecent && lastPosition.textAnchor) {
                              console.warn("Text anchor data seems incomplete, skipping.", lastPosition.textAnchor);
                         }

                         if (lastPosition.percentComplete !== undefined && lastPosition.percentComplete >= 0 && lastPosition.percentComplete <= 1) {
                             const scrollHeight = DOM.contentArea.scrollHeight;
                             const clientHeight = DOM.contentArea.clientHeight;
                             if (scrollHeight > clientHeight) {
                                 const targetPosition = lastPosition.percentComplete * (scrollHeight - clientHeight);
                                 DOM.contentArea.scrollTo({ top: targetPosition, behavior: 'auto' });
                                 console.log(`Restored position using percentage: ${Math.round(lastPosition.percentComplete * 100)}%`);
                                 restored = true;
                                 updateProgressBar();
                                 return;
                             }
                         }

                         if (lastPosition.scroll !== undefined && lastPosition.scroll >= 0) {
                             if (lastPosition.scroll < DOM.contentArea.scrollHeight) {
                                 DOM.contentArea.scrollTo({ top: lastPosition.scroll, behavior: 'auto' });
                                 console.warn("Restored position using raw scroll value (fallback).");
                                 restored = true;
                                 updateProgressBar();
                                 return;
                             } else {
                                 console.warn("Saved scroll position exceeds current scroll height, ignoring.");
                             }
                         }

                         if (!restored) {
                             console.warn("Could not restore reading position from saved data. Scrolling to top.");
                             DOM.contentArea.scrollTo({ top: 0, behavior: 'auto' });
                             updateProgressBar();
                         }
                     });
                 });
             }


             function restoreByTextAnchor(textAnchor) {
                 if (!textAnchor || textAnchor.index === undefined || textAnchor.index < 0) return false;

                 DOM.contentArea.querySelectorAll('p:not([data-p-index])').forEach((p, index) => {
                 });


                 let targetParagraph = DOM.contentArea.querySelector(`p[data-p-index="${textAnchor.index}"]`);

                  if (!targetParagraph && textAnchor.text) {
                     console.warn(`Paragraph at index ${textAnchor.index} not found. Searching by text...`);
                     const paragraphs = DOM.contentArea.querySelectorAll('p');
                     for (let i = 0; i < paragraphs.length; i++) {
                         if (paragraphs[i].hasAttribute('data-p-index') && isTextSimilar(paragraphs[i].textContent, textAnchor.text)) {
                             targetParagraph = paragraphs[i];
                             console.log(`Found similar text in paragraph index ${paragraphs[i].getAttribute('data-p-index')}`);
                             break;
                         }
                     }
                 }

                 if (!targetParagraph) {
                     console.error("Could not find target paragraph for text anchor restoration.");
                     return false;
                 }

                  targetParagraph.scrollIntoView({ behavior: 'auto', block: 'start' });

                  if (textAnchor.offset && textAnchor.offset > 0.1) {
                       const rect = targetParagraph.getBoundingClientRect();
                       const scrollAdjustment = rect.height * textAnchor.offset;
                       DOM.contentArea.scrollTop += scrollAdjustment;
                  }


                 console.log(`Scrolled to anchor paragraph (Index: ${targetParagraph.getAttribute('data-p-index')})`);
                 return true;
             }

            function isTextSimilar(text1, text2) {
                if (!text1 || !text2) return false;
                const t1 = text1.substring(0, 50).trim().toLowerCase();
                const t2 = text2.substring(0, 50).trim().toLowerCase();
                return t1.startsWith(t2) || t2.startsWith(t1);
            }


            function displayChatMessage(sender, message, isLoading = false) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message', sender);
                if (sender === 'assistant') {
                      messageElement.innerHTML = markdownToHtml(message);
                }
                else { messageElement.textContent = message; }
                if (isLoading) messageElement.classList.add('loading');
                DOM.chatMessages.appendChild(messageElement);
                DOM.chatMessages.scrollTop = DOM.chatMessages.scrollHeight;
                return messageElement;
            }

            function clearChat() {
                state.chatHistory = [];
                DOM.chatMessages.innerHTML = '';
                const initialGreeting = state.chatUseFullDocument ? "Chat cleared. Ask me anything about the full document." : "Chat cleared. Ask me anything about the current chapter.";
                displayChatMessage('assistant', initialGreeting);
                renderSuggestedQuestions(initialSuggestedQuestions); // Show initial suggestions after clearing
            }

            async function handleSendMessage() {
                const userMessage = DOM.chatInput.value.trim();
                if (!userMessage) return;
                if (!state.userApiSettings || !state.userApiSettings.api_key) { displayChatMessage('assistant', 'Sorry, the Gemini API key is not configured. Please set it up in the main dashboard.'); return; }
                displayChatMessage('user', userMessage);
                state.chatHistory.push({ role: 'user', parts: [{ text: userMessage }] });
                DOM.chatInput.value = '';
                DOM.chatInput.style.height = 'auto'; // Reset height after sending
                const loadingElement = displayChatMessage('assistant', '', true);
                DOM.chatSendBtn.disabled = true;
                renderSuggestedQuestions([]); // Clear suggestions when user sends a message
                processAndSendChat(userMessage, loadingElement);
            }

            DOM.chatInput.addEventListener('input', () => {
                DOM.chatInput.style.height = 'auto';
                DOM.chatInput.style.height = `${Math.min(DOM.chatInput.scrollHeight, 80)}px`;
            });


            async function processAndSendChat(userMessage, loadingElement) {
                 try {
                     let contextContent = ""; let contextSource = "";
                     const currentChapter = state.bookData.chapters[state.bookData.currentPosition];

                     if (state.chatUseFullDocument) {
                         contextSource = "the full document";
                         contextContent = state.bookData.chapters
                             .map(ch => ch.markdownContent || ch.content || '')
                             .join("\n\n---\n\n");
                     } else {
                         contextSource = "the current chapter";
                         contextContent = currentChapter ? (currentChapter.markdownContent || currentChapter.content || "No chapter content available.") : "No chapter loaded.";
                     }

                     const maxContextLength = 15000;
                     const fullContext = contextContent.length > maxContextLength ? contextContent.substring(0, maxContextLength) + "\n... [Context Truncated]" : contextContent;

                     const historyToSend = state.chatHistory.slice(-10);
                     const language = localStorage.getItem('speech-language') || 'en-US';
                     const languageName = language.startsWith('fr') ? 'French' : 'English';

                     // Updated system prompt to request suggestions
                     const systemPrompt = `You are a helpful AI assistant integrated into an ebook reader. The user is reading a book and will provide context (either the current chapter or the full document).\nYour primary goal is to help the user **explore and understand** the provided text. Answer questions, summarize, explain concepts, and identify key points based *strictly* on the context.\nBe concise and accurate. \nUse basic Markdown for formatting (like **bold**, *italic*, and simple lists starting with * or -). Use new lines for paragraphs.\nRemember the user might be learning ${languageName}, so explain complex ideas simply if appropriate.\n\n**IMPORTANT - Follow-up Questions:**\nAfter your main response, provide **exactly 3 concrete, specific follow-up questions** (max 7-10 words each) that directly relate to the content just discussed or the provided context. These questions should encourage deeper exploration of the text.\nFormat these questions EXACTLY like this, with no extra text before or after the block, and each question on a new line:\n[SUGGESTIONS]\nWhat is the significance of X?\nCan you elaborate on Y?\nHow does Z relate to the previous section?\n[/SUGGESTIONS]`;

                     const requestPayloadContents = [
                         { role: 'user', parts: [{ text: systemPrompt }] },
                         { role: 'model', parts: [{ text: "Understood. I will focus on exploring and explaining the provided text using basic Markdown and suggest concrete follow-up questions based on the content." }] },
                         ...historyToSend.slice(0, -1),
                         { role: 'user', parts: [{ text: `Here is the context from ${contextSource}:\n\n---\n${fullContext}\n---\n\nMy question is:` }] },
                         historyToSend[historyToSend.length - 1]
                     ];


                     const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                     const response = await geminiChatRequest(state.userApiSettings.api_key, requestPayloadContents, modelToUse);

                     loadingElement.remove();

                     let assistantResponseText = 'Sorry, I could not generate a response.';
                     let extractedSuggestions = []; // To store parsed suggestions

                     if (response.error) {
                         assistantResponseText = `Sorry, there was an error: ${response.error.message}`;
                     } else {
                         const rawResponse = response?.candidates?.[0]?.content?.parts?.[0]?.text || '';
                         // Regex to find the suggestion block at the end
                         const suggestionBlockRegex = /\[SUGGESTIONS\]([\s\S]*?)\[\/SUGGESTIONS\]\s*$/;
                         const match = rawResponse.match(suggestionBlockRegex);

                         if (match && match[1]) {
                             // Extract the text between the tags
                             const questionsText = match[1].trim();
                             // Split into lines, remove numbering/bullets, filter empty lines
                             extractedSuggestions = questionsText.split('\n')
                                 .map(q => q.trim().replace(/^[\d.*-]+\s*/, '')) // Remove potential list markers
                                 .filter(q => q.length > 0 && q.length < 100); // Basic validation
                             // Get the main response text by removing the suggestion block
                             assistantResponseText = rawResponse.replace(suggestionBlockRegex, '').trim();
                         } else {
                             // If no suggestion block found, use the whole response
                             assistantResponseText = rawResponse.trim();
                             console.warn("AI response did not contain the expected [SUGGESTIONS] block.");
                         }

                         // Handle cases where the main response might be empty after stripping suggestions
                         if (!assistantResponseText) {
                             assistantResponseText = "Okay, I've processed that. What would you like to explore next?";
                         }
                     }

                     displayChatMessage('assistant', assistantResponseText);
                     state.chatHistory.push({ role: 'assistant', parts: [{ text: assistantResponseText }] });
                     renderSuggestedQuestions(extractedSuggestions); // Render the extracted suggestions

                 } catch (error) {
                     console.error('Error handling chat message:', error);
                     if (loadingElement && loadingElement.parentNode) {
                        loadingElement.remove();
                     }
                     displayChatMessage('assistant', 'An unexpected error occurred while processing your request.');
                     state.chatHistory.push({ role: 'assistant', parts: [{ text: `Unexpected Error: ${error.message}` }] });
                 } finally {
                     DOM.chatSendBtn.disabled = false;
                     if (state.chatHistory.length > 20) {
                         const systemPromptsCount = state.chatHistory.findIndex(msg => msg.role !== 'user' && msg.role !== 'model');
                         const startIndex = Math.max(systemPromptsCount >= 0 ? systemPromptsCount : 0, state.chatHistory.length - 16);
                         state.chatHistory = state.chatHistory.slice(startIndex);
                     }
                     DOM.chatInput.style.height = 'auto';
                 }
            }


            const getApiUrl = (model) =>
`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=`;

            async function geminiSingleRequest(apiKey, promptText, model) {
                 if (!apiKey || !model) return { error: { message: 'API key or model not configured' } };
                 try {
                     const res = await fetch(`${getApiUrl(model)}${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] }) });
                     if (!res.ok) { const errorData = await res.json(); throw new Error(errorData.error?.message || `API request failed with status ${res.status}`); }
                     return res.json();
                 } catch (error) { console.error('Error calling Gemini API (single request):', error); return { error: { message: error.message || 'Failed to connect to Gemini API' } }; }
            }
            async function geminiChatRequest(apiKey, contents, model) {
                  if (!apiKey || !model) return { error: { message: 'API key or model not configured' } };
                  try {
                     const res = await fetch(`${getApiUrl(model)}${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: contents }) });
                     if (!res.ok) { const errorData = await res.json(); throw new Error(errorData.error?.message || `API request failed with status ${res.status}`); }
                     return res.json();
                 } catch (error) { console.error('Error calling Gemini API (chat):', error); return { error: { message: error.message || 'Failed to connect to Gemini API' } }; }
            }

            async function translateText(text) {
                if (!state.userApiSettings || !state.userApiSettings.api_key) { DOM.translationContent.textContent = 'Please configure Gemini API key to use translation.'; DOM.translationLoading.style.display = 'none'; return; }
                DOM.translationContent.textContent = ''; DOM.translationLoading.style.display = 'flex';
                const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                try {
                    const prompt = `Translate the following English text to Vietnamese. Only return the translation without any explanation or additional text.\n\nText: "${text}"`;
                    const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);
                    DOM.translationLoading.style.display = 'none';
                    if (response.error) { DOM.translationContent.textContent = `Error: ${response.error.message}`; return; }
                    const translation = response?.candidates?.[0]?.content?.parts?.[0]?.text || 'Translation failed.';
                    DOM.translationContent.textContent = translation.trim();
                    generateFlashcard(text);
                } catch (error) { console.error('Error translating text:', error); DOM.translationLoading.style.display = 'none'; DOM.translationContent.textContent = 'An error occurred during translation.'; }
            }

             async function generateFlashcard(text) {
                 if (!state.userApiSettings || !state.userApiSettings.api_key) return;
                 const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                 try {
                     const prompt = `Extract a single useful vocabulary word or short phrase from this text that would be good for an English language learner focusing on Vietnamese translation. Choose the most salient or potentially difficult word/phrase.\n\nText: "${text}"\n\nReturn ONLY a JSON object in this exact format, with no extra text, comments, or markdown formatting around it:\n{\n    "word": "the extracted word or short phrase in English",\n    "phrase": "An example English sentence using the word/phrase in context, with the <b>word/phrase</b> wrapped in <b> tags.",\n    "translation_answer": "Vietnamese translation of the word/phrase\\nA brief definition or explanation in English"\n}`;

                     const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);

                     if (response.error) { console.error('Error generating flashcard:', response.error); return; }

                     const flashcardText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '';
                     try {
                         const jsonMatch = flashcardText.match(/\{[\s\S]*\}/);
                         if (jsonMatch) {
                             const flashcardData = JSON.parse(jsonMatch[0]);
                             if (flashcardData && flashcardData.word && flashcardData.phrase && flashcardData.translation_answer) {
                                showFlashcardToast(flashcardData);
                             } else {
                                 console.warn('Parsed flashcard JSON missing required fields:', flashcardData);
                             }
                         } else {
                              console.warn('Could not find valid JSON in flashcard response:', flashcardText);
                         }
                     } catch (jsonError) {
                         console.error('Error parsing flashcard JSON:', jsonError, flashcardText);
                     }
                 } catch (error) {
                     console.error('Error in generateFlashcard function:', error);
                 }
             }


            function formatTranslation(translation) {
                const parts = translation.split('\n');
                if (parts.length > 1) return `<b>${escapeHTML(parts[0])}</b><br><i>${escapeHTML(parts.slice(1).join('; '))}</i>`;
                return `<b>${escapeHTML(translation)}</b>`;
            }

             function showFlashcardToast(flashcardData) {
                 const existingToast = document.querySelector('.flashcard-toast');
                 if (existingToast) existingToast.remove();

                 const toast = document.createElement('div');
                 toast.className = 'flashcard-toast visible';

                 toast.innerHTML = `
                     <div class="flashcard-header">
                         <div class="flashcard-word">${escapeHTML(flashcardData.word)}</div>
                         <button type="button" class="flashcard-close-btn" aria-label="Close">×</button>
                     </div>
                     <div class="flashcard-translation">${formatTranslation(flashcardData.translation_answer)}</div>
                     <div class="flashcard-actions">
                         <button type="button" class="flashcard-speak-btn" aria-label="Speak">🔊</button>
                         <button type="button" class="flashcard-save-btn">Save</button>
                     </div>`;

                 document.body.appendChild(toast);

                 if (state.lastSelectionRect) {
                     const toastRect = toast.getBoundingClientRect();
                     const selRect = state.lastSelectionRect;
                     const viewportWidth = window.innerWidth;
                     const viewportHeight = window.innerHeight;
                     const margin = 10;

                      let top = selRect.bottom + margin;
                      let left = selRect.left + (selRect.width / 2) - (toastRect.width / 2);

                      left = Math.max(margin, Math.min(left, viewportWidth - toastRect.width - margin));

                      if (top + toastRect.height > viewportHeight - margin) {
                           top = selRect.top - toastRect.height - margin;
                      }
                      top = Math.max(margin, top);


                     toast.style.position = 'fixed';
                     toast.style.top = `${top}px`;
                     toast.style.left = `${left}px`;
                     toast.style.bottom = 'auto';
                     toast.style.right = 'auto';
                 } else {
                     toast.style.bottom = "20px";
                     toast.style.right = "20px";
                     toast.style.top = 'auto';
                     toast.style.left = 'auto';
                 }


                 const removeToast = () => {
                     toast.classList.add('fade-out');
                     setTimeout(() => {
                         if (toast.parentNode) toast.parentNode.removeChild(toast);
                     }, 500);
                 };

                 toast.querySelector('.flashcard-close-btn').addEventListener('click', removeToast);
                 toast.querySelector('.flashcard-speak-btn').addEventListener('click', () => speakText(flashcardData.word));

                 const autoSpeakEnabled = localStorage.getItem('auto-speak-enabled') !== 'false';
                 const speakSelectionEnabled = state.settings.speakSelectionEnabled;
                 if (autoSpeakEnabled && !speakSelectionEnabled) {
                     setTimeout(() => speakText(flashcardData.word), 300);
                 }

                 toast.querySelector('.flashcard-save-btn').addEventListener('click', async () => {
                     const saveButton = toast.querySelector('.flashcard-save-btn');
                     saveButton.textContent = 'Saving...';
                     saveButton.disabled = true;
                     const { data: { session } } = await supabase.auth.getSession();
                     if (!session) { showToast('Please sign in to save flashcards'); saveButton.textContent = 'Save'; saveButton.disabled = false; return; }
                     try {
                         const { error } = await supabase.from('flashcards').upsert({
                             user_id: session.user.id,
                             word: flashcardData.word,
                             phrase: flashcardData.phrase,
                             translation_answer: flashcardData.translation_answer,
                             state: "new",
                             due: new Date().toISOString(),
                             stability: 0.5,
                             difficulty: 5,
                             elapsed_days: 0,
                             scheduled_days: 0,
                             reps: 0,
                             lapses: 0
                         }, { onConflict: 'user_id, word' });

                         if (error) throw error;
                         saveButton.textContent = 'Saved!';
                         setTimeout(removeToast, 1000);
                     } catch (error) {
                         console.error('Error saving/upserting flashcard:', error);
                         saveButton.textContent = 'Failed';
                          showToast(`Save failed: ${error.message}`, 3000);
                         setTimeout(() => { saveButton.textContent = 'Retry'; saveButton.disabled = false; }, 1500);
                     }
                 });

                 setTimeout(removeToast, 20000);
             }

            function speakText(text) {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    const language = localStorage.getItem('speech-language') || 'en-US';
                    utterance.lang = language;

                    const voices = window.speechSynthesis.getVoices();
                    let selectedVoice = voices.find(voice => voice.lang === language);
                    if (!selectedVoice) {
                         selectedVoice = voices.find(voice => voice.lang.startsWith(language.split('-')[0]));
                    }
                     if (!selectedVoice && language.startsWith('en')) {
                         selectedVoice = voices.find(voice => voice.lang.startsWith('en-'));
                     }
                    if (selectedVoice) {
                        utterance.voice = selectedVoice;
                    } else {
                         console.warn(`No voice found for language: ${language}. Using default.`);
                    }

                    utterance.rate = 0.9;
                    utterance.pitch = 1.0;
                    window.speechSynthesis.speak(utterance);
                } else {
                    console.error('Text-to-speech not supported in this browser');
                    showToast('Text-to-speech not supported in this browser');
                }
            }
            if ('speechSynthesis' in window && window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = () => { window.speechSynthesis.getVoices(); };
            }


            async function saveUserPreferences() {
                 const preferences = {
                     fontSize: state.settings.fontSize,
                     lineHeight: state.settings.lineHeight,
                     theme: state.settings.theme,
                     viewRawHtmlEnabled: state.settings.viewRawHtmlEnabled,
                     translationEnabled: DOM.translationToggle.checked,
                     autoSpeakEnabled: DOM.autoSpeakToggle.checked,
                     speakSelectionEnabled: state.settings.speakSelectionEnabled,
                     speechLanguage: DOM.speechLanguage.value
                 };

                 localStorage.setItem('ebook-fontsize', preferences.fontSize);
                 localStorage.setItem('ebook-lineheight', preferences.lineHeight);
                 localStorage.setItem('ebook-theme', preferences.theme);
                 localStorage.setItem('ebook-viewrawhtml', preferences.viewRawHtmlEnabled);
                 localStorage.setItem('ebook-translation', preferences.translationEnabled);
                 localStorage.setItem('ebook-autospeak', preferences.autoSpeakEnabled);
                 localStorage.setItem('ebook-speakselection', preferences.speakSelectionEnabled);
                 localStorage.setItem('ebook-speechlanguage', preferences.speechLanguage);


                 const { data: { session } } = await supabase.auth.getSession();
                 if (!session) return;

                 try {
                     const { error } = await supabase
                         .from('user_settings')
                         .upsert({ user_id: session.user.id, preferences: preferences }, { onConflict: 'user_id' });

                     if (error) throw error;

                 } catch (error) {
                     console.error('Error saving user preferences to DB:', error);
                 }
             }


             async function loadUserPreferences() {
                 state.settings.fontSize = parseInt(localStorage.getItem('ebook-fontsize') || '100', 10);
                 state.settings.lineHeight = parseFloat(localStorage.getItem('ebook-lineheight') || '1.6');
                 state.settings.theme = localStorage.getItem('ebook-theme') || 'dark';
                 state.settings.viewRawHtmlEnabled = localStorage.getItem('ebook-viewrawhtml') === 'true';
                 state.settings.speakSelectionEnabled = localStorage.getItem('ebook-speakselection') === 'true';

                 DOM.translationToggle.checked = localStorage.getItem('ebook-translation') !== 'false';
                 DOM.autoSpeakToggle.checked = localStorage.getItem('ebook-autospeak') !== 'false';
                 DOM.speechLanguage.value = localStorage.getItem('ebook-speechlanguage') || 'en-US';

                 updateFontSize();
                 updateLineHeight();
                 setTheme(state.settings.theme);
                 DOM.viewRawHtmlToggle.checked = state.settings.viewRawHtmlEnabled;
                 DOM.speakSelectionToggle.checked = state.settings.speakSelectionEnabled;

                 const { data: { session } } = await supabase.auth.getSession();
                 if (!session) return;

                 try {
                     const { data, error } = await supabase
                         .from('user_settings')
                         .select('preferences')
                         .eq('user_id', session.user.id)
                         .maybeSingle();

                     if (error) {
                         console.error('Error loading user preferences from DB:', error);
                         return;
                     }

                     if (data && data.preferences) {
                         const prefs = data.preferences;
                         console.log("Loaded preferences from DB:", prefs);

                         if (prefs.fontSize !== undefined) state.settings.fontSize = prefs.fontSize;
                         if (prefs.lineHeight !== undefined) state.settings.lineHeight = prefs.lineHeight;
                         if (prefs.theme) state.settings.theme = prefs.theme;
                         if (prefs.viewRawHtmlEnabled !== undefined) state.settings.viewRawHtmlEnabled = prefs.viewRawHtmlEnabled;
                         if (prefs.speakSelectionEnabled !== undefined) state.settings.speakSelectionEnabled = prefs.speakSelectionEnabled;
                         if (prefs.translationEnabled !== undefined) DOM.translationToggle.checked = prefs.translationEnabled;
                         if (prefs.autoSpeakEnabled !== undefined) DOM.autoSpeakToggle.checked = prefs.autoSpeakEnabled;
                         if (prefs.speechLanguage) DOM.speechLanguage.value = prefs.speechLanguage;

                         updateFontSize();
                         updateLineHeight();
                         setTheme(state.settings.theme);
                         DOM.viewRawHtmlToggle.checked = state.settings.viewRawHtmlEnabled;
                         DOM.speakSelectionToggle.checked = state.settings.speakSelectionEnabled;

                         localStorage.setItem('ebook-fontsize', state.settings.fontSize);
                         localStorage.setItem('ebook-lineheight', state.settings.lineHeight);
                         localStorage.setItem('ebook-theme', state.settings.theme);
                         localStorage.setItem('ebook-viewrawhtml', state.settings.viewRawHtmlEnabled);
                         localStorage.setItem('ebook-translation', DOM.translationToggle.checked);
                         localStorage.setItem('ebook-autospeak', DOM.autoSpeakToggle.checked);
                         localStorage.setItem('ebook-speakselection', state.settings.speakSelectionEnabled);
                         localStorage.setItem('ebook-speechlanguage', DOM.speechLanguage.value);

                     } else {
                          console.log("No preferences found in DB for user, saving current settings.");
                          saveUserPreferences();
                     }

                 } catch (error) {
                     console.error('Exception loading/processing user preferences:', error);
                 }
             }


            async function generateTitleAndCategory(content, modelName) {
                 if (!state.userApiSettings || !state.userApiSettings.api_key) { console.warn("Gemini API key not available for title/category generation."); return { generatedTitle: null, listId: null }; }
                 if (!state.bookLists) { console.warn("Book lists not loaded yet for categorization."); }

                 const maxContentLength = 5000;
                 const truncatedContent = content.length > maxContentLength ? content.substring(0, maxContentLength) + "..." : content;

                 const listOptions = (state.bookLists && state.bookLists.length > 0)
                     ? state.bookLists.map(list => `- ${list.name} (ID: ${list.id})`).join('\n')
                     : "No lists available.";

                 const prompt = `Analyze the following text content scraped from a webpage.\n\nContent Snippet:\n---\n${truncatedContent}\n---\n\nBased on the content, perform the following tasks:\n1.  **Generate a concise and relevant title** for this content (max 10 words).\n2.  **Categorize the content** into ONE of the following existing lists. Choose the list that best fits the topic. If none fit well, choose null.\n\nAvailable Lists:\n${listOptions}\n- Unlisted (ID: null)\n\nReturn the result ONLY in this exact JSON format. The value for "list_id" MUST be either the numeric ID of the chosen list (e.g., 6) or the literal value null (not the string "null"). Do not include the list name in the "list_id" field.\n\nExample Output 1:\n{\n  "title": "Example Title About AI",\n  "list_id": 6 \n}\n\nExample Output 2 (if no list fits):\n{\n  "title": "Example Title About Something Else",\n  "list_id": null\n}\n\nActual Output JSON:\n`;

                 const modelToUse = modelName || state.userApiSettings?.model || 'gemini-1.5-flash-latest';

                 try {
                     const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);
                     if (response.error) throw new Error(response.error.message);

                     const resultText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
                     let parsedResult = { title: null, list_id: null };

                     try {
                         const jsonMatch = resultText.match(/\{[\s\S]*\}/);
                         if (jsonMatch) {
                             parsedResult = JSON.parse(jsonMatch[0]);
                         } else {
                             console.warn("AI did not return valid JSON for title/category.", resultText);
                         }
                     } catch (jsonError) {
                         console.error('Error parsing title/category JSON:', jsonError, resultText);
                     }

                     let listId = parsedResult.list_id;
                      if (listId === 'null' || listId === undefined) {
                         listId = null;
                     } else if (typeof listId === 'string' && !isNaN(parseInt(listId, 10))) {
                         listId = parseInt(listId, 10);
                     } else if (typeof listId !== 'number' && listId !== null) {
                          console.warn(`Received unexpected list_id type: ${typeof listId}, value: ${listId}. Defaulting to null.`);
                         listId = null;
                     }
                      if(listId !== null && !state.bookLists.some(l => l.id === listId)) {
                         console.warn(`AI returned list_id ${listId} which does not exist. Defaulting to null.`);
                         listId = null;
                      }


                     return {
                         generatedTitle: (typeof parsedResult.title === 'string' ? parsedResult.title.trim() : null) || null,
                         listId: listId
                     };

                 } catch (error) {
                     console.error('Error generating title and category:', error);
                     showToast(`AI title/category generation failed: ${error.message}`, 4000);
                     return { generatedTitle: null, listId: null };
                 }
             }


            async function summarizeCurrentChapter() {
                 if (!state.userApiSettings || !state.userApiSettings.api_key) {
                     showToast("Gemini API key needed for summarization. Configure in dashboard.", 4000);
                     checkAuthAndLoadApiSettings();
                     return;
                 }

                 const chapter = state.bookData.chapters[state.bookData.currentPosition];
                 if (!chapter) { showToast("No chapter loaded to summarize.", 2000); return; }

                 const contentToSummarize = chapter.markdownContent || chapter.content || '';
                 if (!contentToSummarize.trim()) { showToast("Chapter content is empty, cannot summarize.", 2000); return; }

                 DOM.aiResponseArea.style.display = 'block';
                 DOM.aiResponseArea.innerHTML = '<p>Generating summary...</p>';
                 DOM.summarizeChapterBtn.disabled = true;
                 DOM.summarizeChapterBtn.classList.add('loading');

                 try {
                     const maxContentLength = 15000;
                     const truncatedContent = contentToSummarize.length > maxContentLength
                         ? contentToSummarize.substring(0, maxContentLength) + "\n... [Content Truncated]"
                         : contentToSummarize;

                     const prompt = `Summarize the following text from a book chapter titled "${chapter.title}":\n\n---\n${truncatedContent}\n---\n\nProvide a concise summary (about 3-5 sentences). Focus on the key points and main ideas presented in the text. Use basic Markdown for clarity (bold, italics).`;

                     const modelToUse = state.userApiSettings?.model || 'gemini-1.5-flash-latest';
                     const response = await geminiSingleRequest(state.userApiSettings.api_key, prompt, modelToUse);

                     if (response.error) throw new Error(response.error.message);

                     const summary = response?.candidates?.[0]?.content?.parts?.[0]?.text || 'Failed to generate summary.';
                      DOM.aiResponseArea.innerHTML = markdownToHtml(summary);

                 } catch (error) {
                     console.error('Error generating summary:', error);
                     DOM.aiResponseArea.innerHTML = `<p>An error occurred: ${escapeHTML(error.message)}</p>`;
                 } finally {
                     DOM.summarizeChapterBtn.disabled = false;
                     DOM.summarizeChapterBtn.classList.remove('loading');
                     DOM.settingsPanel.scrollTop = DOM.settingsPanel.scrollHeight;
                 }
            }


            return { init };
        })();

        document.addEventListener('DOMContentLoaded', function() {
            EbookApp.init();
        });

        function calculateOverallProgress(book) {
            if (!book || !book.last_position) return 0;

            const lastPos = book.last_position;
            const totalChapters = (book.metadata?.chapters?.length) || 1;
            const currentChapterIndex = lastPos.chapter !== undefined ? lastPos.chapter : 0;
            const chapterProgress = lastPos.percentComplete !== undefined ? lastPos.percentComplete : 0;

            const validTotalChapters = Math.max(1, totalChapters);
            const validCurrentChapterIndex = Math.max(0, Math.min(currentChapterIndex, validTotalChapters - 1));
            const validChapterProgress = Math.max(0, Math.min(1, chapterProgress));

            let overallProgress = 0;
            if (validTotalChapters > 0) {
                 overallProgress = (validCurrentChapterIndex / validTotalChapters) + (validChapterProgress / validTotalChapters);
            }

             overallProgress = Math.min(1, overallProgress);

            return Math.round(overallProgress * 100);
        }
    </script>
</body>
</html>