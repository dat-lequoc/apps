<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Ebook Reader</title>
    <!-- Include external libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* CSS Reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        /* CSS Variables for theming */
        :root {
            /* Light theme variables */
            --light-bg: #f8f8f8;
            --light-text: #333;
            --light-panel-bg: #fff;
            --light-border: #eee;
            --light-panel-shadow: rgba(0,0,0,0.1);
            --light-highlight: rgba(66, 133, 244, 0.3);
            
            /* Sepia theme variables */
            --sepia-bg: #f8f1e3;
            --sepia-text: #5f4b32;
            --sepia-panel-bg: #f7f0e0;
            --sepia-border: rgba(95, 75, 50, 0.15);
            --sepia-panel-shadow: rgba(95, 75, 50, 0.15);
            --sepia-highlight: rgba(210, 180, 140, 0.3);
            
            /* Dark theme variables */
            --dark-bg: #222;
            --dark-text: #e0e0e0;
            --dark-panel-bg: #333;
            --dark-border: #444;
            --dark-panel-shadow: rgba(0,0,0,0.3);
            --dark-highlight: rgba(66, 133, 244, 0.4);
            
            /* Common UI colors */
            --primary-color: #4285f4;
            --success-color: #34a853;
            --danger-color: #d93025;
            --panel-radius: 12px;
            
            /* Default to dark theme */
            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
        }
        
        /* Theme classes */
        body.light-theme {
            --bg-color: var(--light-bg);
            --text-color: var(--light-text);
            --panel-bg: var(--light-panel-bg);
            --border-color: var(--light-border);
            --panel-shadow: var(--light-panel-shadow);
            --highlight-color: var(--light-highlight);
        }
        
        body.sepia-theme {
            --bg-color: var(--sepia-bg);
            --text-color: var(--sepia-text);
            --panel-bg: var(--sepia-panel-bg);
            --border-color: var(--sepia-border);
            --panel-shadow: var(--sepia-panel-shadow);
            --highlight-color: var(--sepia-highlight);
        }
        
        body.dark-theme {
            --bg-color: var(--dark-bg);
            --text-color: var(--dark-text);
            --panel-bg: var(--dark-panel-bg);
            --border-color: var(--dark-border);
            --panel-shadow: var(--dark-panel-shadow);
            --highlight-color: var(--dark-highlight);
            --input-bg: rgba(255, 255, 255, 0.05); /* Added for input backgrounds */
            --text-muted: rgba(224, 224, 224, 0.7);
        }

        .hidden {
            display: none !important; /* Use important to override potential inline styles if needed */
        }

        #ai-response-area {
            display: none; /* Initially hidden, controlled by JS */
        }

        /* Base styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        /* Selection styling */
        ::selection {
            background-color: var(--highlight-color);
        }
        
        /* Responsive typography */
        html {
            font-size: 16px;
        }
        
        @media (max-width: 768px) {
            html {
                font-size: 14px;
            }
        }
        
        /* Main container */
        #app {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
        }
        
        /* Welcome screen */
        #welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Allow scrolling from top */
            background-color: var(--bg-color);
            z-index: 100;
            padding: 5vh 1rem; /* Add vertical padding */
            overflow-y: auto;
        }

        #welcome-screen h1 {
            margin-bottom: 1.5rem; /* Increased margin */
            text-align: center;
            font-size: 2.2rem; /* Slightly larger */
        }

        .welcome-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            padding: 1rem; /* Adjusted padding */
        }

        .welcome-actions { /* Renamed for clarity */
            display: flex;
            flex-direction: column; /* Stack actions vertically */
            gap: 1.5rem; /* Increased gap */
            margin-top: 1.5rem;
            width: 100%;
            align-items: center;
        }

        .main-actions { /* Group main buttons */
             display: flex;
             gap: 1rem;
             justify-content: center;
             flex-wrap: wrap; /* Allow wrapping on small screens */
             width: 100%;
        }

        #library-section {
            width: 100%;
            max-width: 600px;
            margin-top: 2.5rem;
            padding: 1.25rem;
            background-color: var(--panel-bg);
            border-radius: 8px;
            max-height: 50vh; /* Keep max height */
            overflow-y: auto;
            box-shadow: 0 2px 8px var(--panel-shadow);
        }

        /* Input Group Styling */
        .input-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* Space between elements in the group */
        }

        .input-row {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .input-field { /* Common style for text/url inputs */
            flex: 1;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: inherit;
            font-size: 1rem;
        }

        #text-input { /* Specific textarea style */
            width: 100%;
            min-height: 120px; /* Slightly smaller default height */
            margin-bottom: 0; /* Remove bottom margin, handled by gap */
        }

        #toggle-text-input-container {
            text-align: center;
            margin-top: 0.5rem; /* Keep small margin */
        }

        #toggle-text-input {
            font-size: 0.9rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        #toggle-text-input:hover {
            text-decoration: underline;
        }

        #text-input-container {
            width: 100%;
            /* display: none; /* Controlled by JS */
        }

        .library-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .library-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .library-item-details {
            flex: 1;
            min-width: 0; /* Allow text truncation */
        }
        
        .library-item-title {
            font-weight: 500;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .library-item-meta {
            font-size: 0.75rem;
            color: rgba(var(--text-color), 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .progress-bar-container {
            height: 4px;
            background-color: rgba(var(--text-color), 0.1);
            border-radius: 2px;
            margin-top: 0.3rem;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .library-item-actions {
            display: flex;
            gap: 0.5rem;
            margin-left: 0.5rem;
        }
        
        .library-item-delete {
            color: var(--danger-color);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.125rem;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            width: 1.75rem;
            height: 1.75rem;
        }
        
        .library-item-delete:hover {
            background-color: rgba(217, 48, 37, 0.1);
        }
        
        .auth-section {
            margin-top: 1.875rem;
            text-align: center;
        }
        
        .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transition: background-color 0.2s, transform 0.1s;
        }
        
        .button:hover {
            background-color: #3367d6;
        }
        
        .button:active {
            transform: translateY(1px);
        }

        /* Button loading state */
        .button.loading {
            position: relative;
            color: transparent !important; /* Hide text */
            pointer-events: none; /* Disable clicks */
        }

        .button.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1rem; /* Spinner size */
            height: 1rem; /* Spinner size */
            margin-top: -0.5rem; /* Center vertically */
            margin-left: -0.5rem; /* Center horizontally */
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: button-spin 0.8s linear infinite;
        }

        @keyframes button-spin {
            to { transform: rotate(360deg); }
        }
        
        .success-button {
            background-color: var(--success-color);
        }
        
        .success-button:hover {
            background-color: #2e9549;
        }
        
        /* Example book section */
        .example-book-section {
            margin-top: 1.875rem;
            text-align: center;
            padding: 1.25rem;
            background-color: rgba(66, 133, 244, 0.1);
            border-radius: 8px;
            margin-bottom: 1.25rem;
        }

        .example-book-section p {
            margin-bottom: 0.75rem; /* Add space below the paragraph */
        }
        
        /* Top navbar */
        #navbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3.5rem;
            background-color: var(--panel-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transform: translateY(-100%);
            transition: transform 0.3s ease;
            z-index: 20;
        }
        
        #navbar.visible {
            transform: translateY(0);
        }
        
        #book-title {
            font-size: 1.125rem;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 40%;
        }
        
        #navbar-buttons {
            display: flex;
            gap: 1rem;
        }
        
        .navbar-btn {
            background-color: transparent;
            border: none;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
            font-size: 1.25rem;
            transition: background-color 0.2s;
        }
        
        .navbar-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Reader content */
        #reader-container {
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        
        #content-area {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
            padding-top: 2rem;
            -webkit-overflow-scrolling: touch;
            user-select: text;
            -webkit-user-select: text;
            transition: background-color 0.3s ease, color 0.3s ease;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        #content-area p {
            margin-bottom: 1rem;
            line-height: 1.7;
        }
        
        /* Settings panel */
        #settings-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--panel-bg);
            padding: 1.25rem;
            border-top-left-radius: var(--panel-radius);
            border-top-right-radius: var(--panel-radius);
            box-shadow: 0 -2px 10px var(--panel-shadow);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 30;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #settings-panel.visible {
            transform: translateY(0);
        }
        
        .settings-section {
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .settings-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
        }
        
        #ai-settings-content {
            margin-bottom: 1rem;
        }

        .settings-row.ai-toggle {
            margin-top: 0.75rem;
        }

        #ai-response-area {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            padding: 0.75rem;
            margin-top: 0.75rem;
            font-size: 0.875rem;
            max-height: 12.5rem;
            overflow-y: auto;
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .font-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--panel-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
        }
        
        .theme-options {
            display: flex;
            gap: 1rem;
        }
        
        .theme-option {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }
        
        .theme-option.active {
            border-color: var(--primary-color);
        }
        
        .light-option {
            background-color: var(--light-bg);
            border: 1px solid var(--light-border);
        }
        
        .sepia-option {
            background-color: var(--sepia-bg);
        }
        
        .dark-option {
            background-color: var(--dark-bg);
        }
        
        /* Navigation controls */
        #nav-controls {
            position: fixed;
            bottom: 1.25rem;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 1.25rem;
            pointer-events: none;
            z-index: 15;
        }
        
        .nav-btn {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background-color: var(--panel-bg);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 2px 5px var(--panel-shadow);
            transition: background-color 0.2s;
        }
        
        .nav-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Table of contents panel */
        #toc-panel {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            width: 80%;
            max-width: 20rem;
            background-color: var(--panel-bg);
            z-index: 30;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 10px var(--panel-shadow);
        }
        
        #toc-panel.visible {
            transform: translateX(0);
        }
        
        #toc-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #toc-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .toc-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .toc-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .toc-item.toc-active {
            font-weight: bold;
            background-color: rgba(var(--primary-color), 0.1);
        }
        
        /* Overlay for panels */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.4);
            z-index: 25;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #overlay.visible {
            display: block;
            opacity: 1;
        }
        
        /* Progress indicator */
        #progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background-color: var(--primary-color);
            transition: width 0.2s ease;
            z-index: 10;
        }
        
        /* Loading indicator */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #loading.visible {
            display: flex;
            opacity: 1;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-left-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Translation popup */
        #translation-popup {
            position: fixed;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.15);
            padding: 16px;
            min-width: 220px;
            max-width: 320px;
            z-index: 100;
            display: none;
            border: 1px solid rgba(0,0,0,0.08);
            transform: translateY(10px);
            opacity: 0;
            transition: transform 0.2s ease, opacity 0.2s ease;
            font-style: italic;
            color: #4285f4;
        }
        
        #translation-popup.visible {
            transform: translateY(0);
            opacity: 1;
        }
        
        body.light-theme #translation-popup {
            background-color: #ffffff;
            color: #4285f4;
        }
        
        body.sepia-theme #translation-popup {
            background-color: #f7f0e0;
            color: #4285f4;
            border-color: rgba(95, 75, 50, 0.15);
        }
        
        body.dark-theme #translation-popup {
            background-color: #2d2d2d;
            color: #4285f4;
            border-color: rgba(255,255,255,0.1);
        }
        
        #translation-popup:before {
            content: '';
            position: absolute;
            top: -8px;
            left: 20px;
            width: 14px;
            height: 14px;
            background-color: inherit;
            border-top: 1px solid rgba(0,0,0,0.08);
            border-left: 1px solid rgba(0,0,0,0.08);
            transform: rotate(45deg);
        }
        
        body.dark-theme #translation-popup:before {
            border-color: rgba(255,255,255,0.1);
        }
        
        body.sepia-theme #translation-popup:before {
            border-color: rgba(95, 75, 50, 0.15);
        }
        
        #translation-content {
            margin-bottom: 10px;
            font-size: 15px;
            line-height: 1.5;
        }
        
        #translation-loading {
            display: none;
            align-items: center;
            justify-content: center;
            height: 30px;
        }
        
        #translation-loading .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-left-color: #4285f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        body.dark-theme #translation-loading .spinner {
            border-color: rgba(255,255,255,0.1);
            border-left-color: #4285f4;
        }
        
        /* Flashcard toast styles */
        .flashcard-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            padding: 8px 12px;
            width: 240px;
            z-index: 1000;
            font-size: 14px;
            opacity: 1;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        body.dark-theme .flashcard-toast {
            background-color: #333;
            color: #e0e0e0;
        }
        
        .flashcard-toast.visible {
            display: block;
        }
        
        .flashcard-toast.fade-out {
            opacity: 0;
            transform: translateY(10px);
        }
        
        .flashcard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .flashcard-close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #888;
            padding: 0;
            margin: 0;
        }
        
        .flashcard-word {
            font-weight: bold;
            font-size: 16px;
        }
        
        .flashcard-translation {
            margin-bottom: 8px;
            line-height: 1.3;
            font-size: 13px;
        }
        
        .flashcard-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .flashcard-speak-btn {
            background-color: #34a853;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 0 0 auto;
        }
        
        .flashcard-save-btn {
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            flex: 1;
        }
        
        .flashcard-save-btn:disabled {
            background-color: #a4c2f4;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #toc-panel {
                width: 100%;
                max-width: none;
            }
            
            .welcome-buttons {
                flex-direction: column;
                width: 100%;
            }
            
            .welcome-buttons .button {
                width: 100%;
                text-align: center;
            }
            
            #book-title {
                max-width: 60%;
            }
            
            #navbar-buttons {
                gap: 0.5rem;
            }
            
            .flashcard-toast {
                left: 1.25rem;
                right: 1.25rem;
                width: auto;
            }
        }
        
        /* Accessibility improvements */
        button, input[type="checkbox"] {
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
        }
        
        a {
            color: var(--primary-color);
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        /* Toast notification */
        #toast {
            position: fixed;
            bottom: 1.25rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: var(--panel-bg);
            color: var(--text-color);
            padding: 0.75rem 1.25rem;
            border-radius: 4px;
            box-shadow: 0 4px 12px var(--panel-shadow);
            z-index: 1000;
            transition: transform 0.3s ease;
            text-align: center;
        }
        
        #toast.visible {
            transform: translateX(-50%) translateY(0);
        }
        
        /* Line height control */
        .line-height-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
    </style>
</head>
<body class="dark-theme">
    <div id="app">
        <!-- Welcome screen -->
        <div id="welcome-screen">
            <div class="welcome-content">
                <h1>Enhanced Ebook Reader</h1>
                <p>Open a local file, read from a URL, or paste text.</p>

                <div class="welcome-actions">
                    <!-- Main Actions: Open File / Sign In -->
                    <div class="main-actions">
                        <button type="button" id="open-file-btn" class="button">Open File</button>
                        <button type="button" id="login-btn" class="button hidden">Sign In</button> <!-- JS controlled -->
                    </div>

                    <!-- URL Input Group -->
                    <div class="input-group" id="url-input-container">
                        <div class="input-row">
                            <input id="url-input" type="url" placeholder="Or enter a URL to read" class="input-field">
                            <button type="button" id="process-url-btn" class="button">Read URL</button>
                        </div>
                    </div>

                    <!-- Text Input Group (Initially hidden) -->
                    <div id="toggle-text-input-container">
                        <a href="#" id="toggle-text-input">or paste text directly</a>
                    </div>
                    <div class="input-group" id="text-input-container" style="display: none;"> <!-- JS controlled -->
                        <textarea id="text-input" class="input-field" placeholder="Paste your text here..."></textarea>
                        <div class="input-row">
                            <input id="text-input-title" type="text" placeholder="Enter a title (optional)" class="input-field">
                            <button type="button" id="process-text-btn" class="button">Read Text</button>
                        </div>
                    </div>

                    <!-- Example Ebook Section -->
                    <div class="example-book-section">
                        <p>Don't have an ebook? Try our example:</p>
                        <a id="example-book-btn" class="button success-button" href="https://raw.githubusercontent.com/dat-lequoc/apps/refs/heads/main/ebooks/Kundera%2C%20Milan%20-%20The%20Unbearable%20Lightness%20of%20Being%20(2017%2C%20Faber%20and%20Faber)%20-%20libgen.li.epub" target="_blank" rel="noopener">Download Sample Book</a>
                    </div>
                </div>

                <div class="auth-section" id="auth-section">
                    <!-- Content dynamically updated by JS -->
                    <p>Sign in to save books to your library.</p>
                </div>
                
                <!-- Library Section -->
                <div id="library-section" style="display: none;">
                    <h2>Your Library</h2>
                    <div id="library-list">
                        <!-- Library items will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Top navbar -->
        <div id="navbar">
            <div id="book-title">Ebook Title</div>
            <div id="navbar-buttons">
                <button type="button" class="navbar-btn" id="toc-btn" aria-label="Table of Contents">☰</button>
                <button type="button" class="navbar-btn" id="settings-btn" aria-label="Settings">⚙️</button>
                <button type="button" class="navbar-btn" id="home-btn" aria-label="Home">⌂</button>
            </div>
        </div>

        <!-- Main reader area -->
        <div id="reader-container">
            <div id="content-area"></div>
            <div id="progress-bar"></div>
        </div>
        
        <!-- Navigation buttons -->
        <div id="nav-controls">
            <button type="button" class="nav-btn" id="prev-btn" aria-label="Previous Chapter">←</button>
            <button type="button" class="nav-btn" id="next-btn" aria-label="Next Chapter">→</button>
        </div>

        <!-- Table of contents panel -->
        <div id="toc-panel">
            <div id="toc-header">
                <h3>Table of Contents</h3>
                <button type="button" class="navbar-btn" id="close-toc-btn" aria-label="Close">✕</button>
            </div>
            <div id="toc-content"></div>
        </div>

        <!-- Settings panel -->
        <div id="settings-panel">
            <div class="settings-section">
                <div class="settings-title">Font Size</div>
                <div class="font-size-controls">
                    <button type="button" class="font-btn" id="font-decrease-btn" aria-label="Decrease Font Size">A-</button>
                    <span id="font-size-value">100%</span>
                    <button type="button" class="font-btn" id="font-increase-btn" aria-label="Increase Font Size">A+</button>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Line Height</div>
                <div class="line-height-controls">
                    <button type="button" class="font-btn" id="line-height-decrease-btn" aria-label="Decrease Line Height">-</button>
                    <span id="line-height-value">1.6</span>
                    <button type="button" class="font-btn" id="line-height-increase-btn" aria-label="Increase Line Height">+</button>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Theme</div>
                <div class="theme-options">
                    <div class="theme-option light-option" data-theme="light" title="Light Theme"></div>
                    <div class="theme-option sepia-option" data-theme="sepia" title="Sepia Theme"></div>
                    <div class="theme-option dark-option active" data-theme="dark" title="Dark Theme"></div>
                </div>
            </div>
            
            <div class="settings-section">
                <div class="settings-title">Display Mode</div>
                <div class="settings-row">
                    <label for="markdown-mode-toggle">Raw Markdown Mode</label>
                    <input type="checkbox" id="markdown-mode-toggle">
                </div>
            </div>

            <!-- AI Features Section -->
            <div class="settings-section" id="ai-features-section">
                <div class="settings-title">AI Features</div>
                <div id="ai-settings-content">
                    <!-- This will be populated dynamically -->
                    <p>Loading AI settings...</p>
                </div>
                <div class="settings-row ai-toggle">
                    <label for="translation-toggle">Text Selection Translation</label>
                    <input type="checkbox" id="translation-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="auto-speak-toggle">Auto Speak Flashcard Words</label>
                    <input type="checkbox" id="auto-speak-toggle" checked>
                </div>
                <div class="settings-row">
                    <label for="speech-language">Speech Language</label>
                    <select id="speech-language">
                        <option value="en-US">English</option>
                        <option value="fr-FR">French</option>
                    </select>
                </div>
                <button type="button" id="summarize-chapter-btn" class="button" style="margin-top: 0.75rem;">Summarize Chapter</button> <!-- JS controlled, display handled by JS -->
                <div id="ai-response-area"></div> <!-- JS controlled -->
            </div>
        </div>

        <!-- Overlay for panels -->
        <div id="overlay"></div>
        
        <!-- Loading indicator -->
        <div id="loading">
            <div class="spinner"></div>
        </div>
        
        <!-- Translation popup -->
        <div id="translation-popup">
            <div id="translation-content"></div>
            <div id="translation-loading">
                <div class="spinner"></div>
            </div>
        </div>
        
        <!-- Toast notification -->
        <div id="toast"></div>

        <!-- File input (hidden) -->
        <input type="file" id="file-input" accept=".txt,.epub,.pdf" style="display: none;"> <!-- Standard practice -->
    </div>

    <script>
        // App Modules
        const EbookApp = (function() {
            // Supabase client initialization
            const supabaseUrl = 'https://iioxqphxakvhhtyvdhrh.supabase.co';
            const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlpb3hxcGh4YWt2aGh0eXZkaHJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg4MzQ5MjAsImV4cCI6MjA1NDQxMDkyMH0.7I2CaBH1DyiRYEtzunIM5-l3GaWYT15Mly39jW-ga5Q';
            const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);
            
            // DOM Elements Cache
            const DOM = {
                app: document.getElementById('app'),
                welcomeScreen: document.getElementById('welcome-screen'),
                readerContainer: document.getElementById('reader-container'),
                contentArea: document.getElementById('content-area'),
                navbar: document.getElementById('navbar'),
                bookTitle: document.getElementById('book-title'),
                tocBtn: document.getElementById('toc-btn'),
                settingsBtn: document.getElementById('settings-btn'),
                homeBtn: document.getElementById('home-btn'),
                tocPanel: document.getElementById('toc-panel'),
                closeTocBtn: document.getElementById('close-toc-btn'),
                tocContent: document.getElementById('toc-content'),
                settingsPanel: document.getElementById('settings-panel'),
                overlay: document.getElementById('overlay'),
                fileInput: document.getElementById('file-input'),
                openFileBtn: document.getElementById('open-file-btn'),
                exampleBookBtn: document.getElementById('example-book-btn'),
                textInput: document.getElementById('text-input'),
                textInputTitle: document.getElementById('text-input-title'),
                processTextBtn: document.getElementById('process-text-btn'),
                toggleTextInput: document.getElementById('toggle-text-input'),
                textInputContainer: document.getElementById('text-input-container'),
                urlInputContainer: document.getElementById('url-input-container'),
                urlInput: document.getElementById('url-input'),
                processUrlBtn: document.getElementById('process-url-btn'),
                fontDecreaseBtn: document.getElementById('font-decrease-btn'),
                fontIncreaseBtn: document.getElementById('font-increase-btn'),
                fontSizeValue: document.getElementById('font-size-value'),
                lineHeightDecreaseBtn: document.getElementById('line-height-decrease-btn'),
                lineHeightIncreaseBtn: document.getElementById('line-height-increase-btn'),
                lineHeightValue: document.getElementById('line-height-value'),
                themeOptions: document.querySelectorAll('.theme-option'),
                progressBar: document.getElementById('progress-bar'),
                prevBtn: document.getElementById('prev-btn'),
                nextBtn: document.getElementById('next-btn'),
                loading: document.getElementById('loading'),
                toast: document.getElementById('toast'),
                loginBtn: document.getElementById('login-btn'),
                librarySection: document.getElementById('library-section'),
                authSection: document.getElementById('auth-section'),
                summarizeBtn: document.getElementById('summarize-chapter-btn'),
                aiSettingsContent: document.getElementById('ai-settings-content'),
                translationToggle: document.getElementById('translation-toggle'),
                autoSpeakToggle: document.getElementById('auto-speak-toggle'),
                speechLanguage: document.getElementById('speech-language'),
                aiResponseArea: document.getElementById('ai-response-area'),
                translationPopup: document.getElementById('translation-popup'),
                translationContent: document.getElementById('translation-content'),
                translationLoading: document.getElementById('translation-loading'),
                markdownModeToggle: document.getElementById('markdown-mode-toggle') // Added Markdown toggle
            };

            // App state
            let state = {
                // Book data
                bookData: {
                    title: '',
                    content: '',
                    chapters: [],
                    currentPosition: 0
                },
                
                // User settings
                settings: {
                    fontSize: 100,
                    lineHeight: 1.6,
                    theme: 'dark',
                    markdownModeEnabled: false // Added Markdown mode setting
                },
                
                // User data
                session: null,
                userApiSettings: null,
                
                // UI state
                translationTimer: null,
                navbarHideTimer: null,
                debounceTimers: {},

                // Event handling
                touchStartY: 0,
                touchEndY: 0,
                lastSelectionRect: null
            };

            // Initialize the app
            function init() {
                setupEventListeners();
                checkAuthAndLoadApiSettings();
                loadUserPreferences();
            }

            // Set up event listeners
            function setupEventListeners() {
                // File handling
                DOM.openFileBtn.addEventListener('click', () => DOM.fileInput.click());
                DOM.fileInput.addEventListener('change', handleFileSelected);
                DOM.processTextBtn.addEventListener('click', processInputText);
                DOM.exampleBookBtn.addEventListener('click', function() {
                    downloadExampleBook();
                });
                DOM.toggleTextInput.addEventListener('click', function(e) {
                    e.preventDefault();
                    DOM.textInputContainer.style.display = DOM.textInputContainer.style.display === 'none' ? 'block' : 'none';
                });
                DOM.processUrlBtn.addEventListener('click', processUrlInput);

                // Navigation
                DOM.tocBtn.addEventListener('click', toggleTocPanel);
                DOM.closeTocBtn.addEventListener('click', closeTocPanel);
                DOM.settingsBtn.addEventListener('click', toggleSettingsPanel);
                DOM.homeBtn.addEventListener('click', goToHome);
                DOM.overlay.addEventListener('click', closeAllPanels);
                DOM.prevBtn.addEventListener('click', goToPrevious);
                DOM.nextBtn.addEventListener('click', goToNext);
                
                // Content area interactions
                DOM.contentArea.addEventListener('click', handleContentClick);
                DOM.contentArea.addEventListener('scroll', debounce(updateProgressBar, 100));
                
                // Handle swipe gestures
                DOM.contentArea.addEventListener('touchstart', handleTouchStart);
                DOM.contentArea.addEventListener('touchend', handleTouchEnd);
                
                // Font size controls
                DOM.fontDecreaseBtn.addEventListener('click', () => {
                    decreaseFontSize();
                    saveUserPreferences();
                });
                DOM.fontIncreaseBtn.addEventListener('click', () => {
                    increaseFontSize();
                    saveUserPreferences();
                });
                
                // Line height controls
                DOM.lineHeightDecreaseBtn.addEventListener('click', () => {
                    decreaseLineHeight();
                    saveUserPreferences();
                });
                DOM.lineHeightIncreaseBtn.addEventListener('click', () => {
                    increaseLineHeight();
                    saveUserPreferences();
                });
                
                // Theme selection
                DOM.themeOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        setTheme(option.getAttribute('data-theme'));
                        saveUserPreferences();
                    });
                });

                // Markdown Mode Toggle
                DOM.markdownModeToggle.addEventListener('change', function() {
                    state.settings.markdownModeEnabled = this.checked;
                    displayCurrentChapter(); // Re-render content
                    saveUserPreferences();
                });
                
                // AI features
                DOM.summarizeBtn.addEventListener('click', summarizeCurrentChapter);
                DOM.translationToggle.addEventListener('change', function() {
                    localStorage.setItem('translation-enabled', this.checked);
                    saveUserPreferences();
                });
                DOM.autoSpeakToggle.addEventListener('change', function() {
                    localStorage.setItem('auto-speak-enabled', this.checked);
                    saveUserPreferences();
                });
                
                DOM.speechLanguage.addEventListener('change', function() {
                    localStorage.setItem('speech-language', this.value);
                    saveUserPreferences();
                });
                
                // Selection for translation
                document.addEventListener('selectionchange', handleTextSelection);
                
                // Login button
                DOM.loginBtn.addEventListener('click', () => {
                    window.open('index.html', '_blank');
                });

                // Global document events
                document.addEventListener('keydown', handleKeyPress);
                document.addEventListener('selectionchange', debounce(handleTextSelection, 300));
            }

            // Handle keyboard shortcuts
            function handleKeyPress(e) {
                // Only handle shortcuts when not in input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                // Left arrow - previous chapter
                if (e.key === 'ArrowLeft' && e.altKey) {
                    goToPrevious();
                    e.preventDefault();
                }
                
                // Right arrow - next chapter
                if (e.key === 'ArrowRight' && e.altKey) {
                    goToNext();
                    e.preventDefault();
                }
                
                // Escape - close panels
                if (e.key === 'Escape') {
                    closeAllPanels();
                    e.preventDefault();
                }
                
                // T - toggle table of contents
                if (e.key === 't' && !e.ctrlKey && !e.metaKey) {
                    toggleTocPanel();
                    e.preventDefault();
                }
                
                // S - toggle settings
                if (e.key === 's' && !e.ctrlKey && !e.metaKey) {
                    toggleSettingsPanel();
                    e.preventDefault();
                }
                
                // H - go home
                if (e.key === 'h' && !e.ctrlKey && !e.metaKey) {
                    goToHome();
                    e.preventDefault();
                }
                
                // + or = increase font size
                if ((e.key === '+' || e.key === '=') && (e.ctrlKey || e.metaKey)) {
                    increaseFontSize();
                    saveUserPreferences();
                    e.preventDefault();
                }
                
                // - decrease font size
                if (e.key === '-' && (e.ctrlKey || e.metaKey)) {
                    decreaseFontSize();
                    saveUserPreferences();
                    e.preventDefault();
                }
            }

            // Handle touch gestures
            function handleTouchStart(e) {
                state.touchStartY = e.touches[0].clientY;
            }
            
            function handleTouchEnd(e) {
                state.touchEndY = e.changedTouches[0].clientY;
                
                // Calculate the distance of the swipe
                const distance = state.touchStartY - state.touchEndY;
                
                // If the swipe distance is greater than 50px and we're at the top of the content
                if (distance < -50 && DOM.contentArea.scrollTop <= 0) {
                    toggleNavbar();
                }
            }
            
            // File handling
            function handleFileSelected() {
                const file = DOM.fileInput.files[0];
                if (!file) return;
                
                showLoading();
                
                // Update book title
                DOM.bookTitle.textContent = file.name;
                state.bookData.title = file.name;
                
                // Process file based on extension
                const fileExtension = file.name.split('.').pop().toLowerCase();
                
                if (fileExtension === 'txt') {
                    processTextFile(file);
                } else if (fileExtension === 'epub') {
                    processEpubFile(file);
                } else if (fileExtension === 'pdf') {
                    processPdfFile(file);
                } else {
                    hideLoading();
                    showToast('Unsupported file format');
                }
            }
            
            function processInputText() {
                const text = DOM.textInput.value.trim();
                if (!text) {
                    showToast('Please enter some text');
                    return;
                }
                
                showLoading();
                
                // Update book title
                let customTitle = DOM.textInputTitle.value.trim();
                
                // If no title is given, use the first 30 characters of the text
                if (!customTitle) {
                    customTitle = text.substring(0, 20).trim();
                    // Add ellipsis if the text was truncated
                    if (text.length > 20) {
                        customTitle += '...';
                    }
                }
                
                DOM.bookTitle.textContent = customTitle;
                state.bookData.title = customTitle;
                
                try {
                    state.bookData.content = text;
                    
                    // Create a single chapter with all the text content
                    state.bookData.chapters = [{
                        title: customTitle,
                        content: text,
                        startLine: 0,
                        endLine: text.split('\n').length
                    }];
                    
                    showBook();
                } catch (error) {
                    console.error('Error processing input text:', error);
                    showToast('Error processing text');
                } finally {
                    hideLoading();
                }
            }
            
            function processTextFile(file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        state.bookData.content = text;
                        
                        // Simple chapter detection based on line breaks and possible chapter indicators
                        const lines = text.split('\n');
                        let chapters = [];
                        let chapterMarkers = [];
                        
                        // Find potential chapter breaks
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            
                            // Look for chapter indicators
                            if ((line === '' || i === 0) && i < lines.length - 1) {
                                const nextLine = lines[i+1].trim();
                                // Match chapter headings: Chapter X, CHAPTER X, Part X, Section X, or Roman numerals
                                if (nextLine.match(/^(Chapter|CHAPTER|\bPart\b|\bSection\b|[IVXLCDM]+\.?)/)) {
                                    chapterMarkers.push(i === 0 ? 0 : i+1);
                                }
                            }
                        }
                        
                        // If no chapters detected, create arbitrary chapters every 1000 lines
                        if (chapterMarkers.length <= 1) {
                            for (let i = 0; i < lines.length; i += 1000) {
                                chapterMarkers.push(i);
                            }
                        }
                        
                        // Create chapters
                        for (let i = 0; i < chapterMarkers.length; i++) {
                            const start = chapterMarkers[i];
                            const end = i < chapterMarkers.length - 1 ? chapterMarkers[i+1] : lines.length;
                            const chapterContent = lines.slice(start, end).join('\n');
                            
                            // Get a reasonable chapter title
                            let title = `Chapter ${i+1}`;
                            if (lines[start] && lines[start].trim()) {
                                title = lines[start].trim();
                                // If title is too long, truncate it
                                if (title.length > 50) {
                                    title = title.substring(0, 47) + '...';
                                }
                            }
                            
                            chapters.push({
                                title: title,
                                content: chapterContent,
                                startLine: start,
                                endLine: end
                            });
                        }
                        
                        state.bookData.chapters = chapters;
                        showBook();
                    } catch (error) {
                        console.error('Error processing text file:', error);
                        showToast('Error processing file');
                    } finally {
                        hideLoading();
                    }
                };
                
                reader.onerror = function(error) {
                    console.error('Error reading file:', error);
                    hideLoading();
                    showToast('Error reading file');
                };
                
                reader.readAsText(file);
            }
            
            function processEpubFile(file) {
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    try {
                        const arrayBuffer = e.target.result;
                        
                        // Check if JSZip is available
                        if (typeof JSZip === 'undefined') {
                            // Load JSZip dynamically if not available
                            await loadExternalScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
                        }
                        
                        await extractEpubContent(arrayBuffer);
                    } catch (error) {
                        console.error('Error processing EPUB:', error);
                        hideLoading();
                        showToast('Error processing EPUB file');
                    }
                };
                
                reader.onerror = function(error) {
                    console.error('Error reading EPUB file:', error);
                    hideLoading();
                    showToast('Error reading EPUB file');
                };
                
                reader.readAsArrayBuffer(file);
            }
            
            async function loadExternalScript(url) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = url;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
                    document.head.appendChild(script);
                });
            }
            
            async function extractEpubContent(arrayBuffer) {
                try {
                    const jszip = new JSZip();
                    const zip = await jszip.loadAsync(arrayBuffer);
                    
                    // Find the OPF file through container.xml
                    const containerXml = await zip.file('META-INF/container.xml').async('text');
                    const parser = new DOMParser();
                    const containerDoc = parser.parseFromString(containerXml, 'application/xml');
                    const rootFile = containerDoc.querySelector('rootfile');
                    
                    if (!rootFile) {
                        throw new Error('Invalid EPUB: container.xml doesn\'t contain a rootfile');
                    }
                    
                    const rootFilePath = rootFile.getAttribute('full-path');
                    const rootDir = rootFilePath.substring(0, rootFilePath.lastIndexOf('/') + 1) || '';
                    
                    // Get the OPF file
                    const opfContent = await zip.file(rootFilePath).async('text');
                    const opfDoc = parser.parseFromString(opfContent, 'application/xml');
                    
                    // Get metadata
                    const metadataElem = opfDoc.querySelector('metadata');
                    if (metadataElem) {
                        const titleElem = metadataElem.querySelector('dc\\:title, title');
                        if (titleElem && titleElem.textContent) {
                            state.bookData.title = titleElem.textContent.trim();
                            DOM.bookTitle.textContent = state.bookData.title;
                        }
                    }
                    
                    // Get the spine items (reading order)
                    const spine = opfDoc.querySelector('spine');
                    const manifest = opfDoc.querySelector('manifest');
                    
                    if (!spine || !manifest) {
                        throw new Error('Invalid EPUB: missing spine or manifest');
                    }
                    
                    // Map all manifest items
                    const manifestItems = {};
                    manifest.querySelectorAll('item').forEach(item => {
                        const id = item.getAttribute('id');
                        const href = item.getAttribute('href');
                        const mediaType = item.getAttribute('media-type');
                        
                        manifestItems[id] = { href, mediaType };
                    });
                    
                    // Get reading order from spine
                    const spineItems = [];
                    spine.querySelectorAll('itemref').forEach(itemref => {
                        const idref = itemref.getAttribute('idref');
                        if (manifestItems[idref] && manifestItems[idref].mediaType.includes('html')) {
                            spineItems.push({
                                id: idref,
                                href: manifestItems[idref].href
                            });
                        }
                    });
                    
                    // Load all HTML files from the spine
                    const contentPromises = spineItems.map(item => {
                        const fullPath = rootDir + item.href;
                        return zip.file(fullPath).async('text').then(content => {
                            return { id: item.id, content, href: item.href };
                        }).catch(error => {
                            console.error(`Error loading ${fullPath}:`, error);
                            return { id: item.id, content: `[Error loading content: ${error.message}]`, href: item.href };
                        });
                    });
                    
                    const chaptersContent = await Promise.all(contentPromises);
                    
                    // Process chapter content
                    state.bookData.chapters = [];
                    
                    chaptersContent.forEach((chapter, index) => {
                        // Extract text from HTML
                        const htmlDoc = parser.parseFromString(chapter.content, 'text/html');
                        
                        // Extract title
                        let title = `Chapter ${index + 1}`;
                        // Try to get title from headings
                        const headingElements = htmlDoc.querySelectorAll('h1, h2, h3, h4');
                        if (headingElements.length > 0) {
                            title = headingElements[0].textContent.trim();
                        } else {
                            // Try to get title from filename
                            const filename = chapter.href.split('/').pop().replace(/\.[^/.]+$/, "");
                            if (filename && !filename.startsWith('chapter') && !/^\d+$/.test(filename)) {
                                title = filename.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                            }
                        }
                        
                        // Extract text content with improved formatting
                        let textContent = '';
                        
                        // Process all content elements
                        const contentElements = htmlDoc.querySelectorAll('body *');
                        contentElements.forEach(element => {
                            // Skip script and style tags
                            if (element.tagName === 'SCRIPT' || element.tagName === 'STYLE') {
                                return;
                            }
                            
                            // Process by element type
                            if (element.tagName.match(/^H[1-6]$/)) {
                                if (element.textContent.trim()) {
                                    textContent += element.textContent.trim() + '\n\n';
                                }
                            } else if (element.tagName === 'P') {
                                if (element.textContent.trim()) {
                                    textContent += element.textContent.trim() + '\n\n';
                                }
                            } else if (element.tagName === 'BR') {
                                textContent += '\n';
                            } else if (element.tagName === 'HR') {
                                textContent += '\n* * *\n\n';
                            } else if (element.tagName === 'BLOCKQUOTE') {
                                if (element.textContent.trim()) {
                                    textContent += '> ' + element.textContent.trim().replace(/\n/g, '\n> ') + '\n\n';
                                }
                            } else if (element.tagName === 'UL' || element.tagName === 'OL') {
                                const listItems = element.querySelectorAll('li');
                                listItems.forEach((li, liIndex) => {
                                    const prefix = element.tagName === 'OL' ? `${liIndex + 1}. ` : '- ';
                                    if (li.textContent.trim()) {
                                        textContent += prefix + li.textContent.trim() + '\n';
                                    }
                                });
                                textContent += '\n';
                            } else if (element.tagName === 'DIV' && element.children.length === 0 && element.textContent.trim()) {
                                // Only add text from divs that don't have child elements and have text
                                textContent += element.textContent.trim() + '\n\n';
                            }
                        });
                        
                        // Fallback if no content was extracted
                        if (textContent.trim() === '') {
                            const body = htmlDoc.querySelector('body');
                            if (body) {
                                textContent = body.textContent.trim().replace(/\s+/g, ' ');
                                
                                // Add paragraph breaks
                                textContent = textContent.replace(/\.\s+/g, '.\n\n');
                            }
                        }
                        
                        // Remove excessive newlines
                        textContent = textContent.replace(/\n{3,}/g, '\n\n');
                        
                        state.bookData.chapters.push({
                            title: title,
                            content: textContent,
                            startLine: 0,
                            endLine: textContent.split('\n').length
                        });
                    });
                    
                    if (state.bookData.chapters.length === 0) {
                        // Create a fallback chapter if extraction failed
                        state.bookData.chapters.push({
                            title: state.bookData.title || 'Content',
                            content: "Could not extract readable content from this EPUB file.",
                            startLine: 0,
                            endLine: 1
                        });
                    }
                    
                    showBook();
                    hideLoading();
                } catch (error) {
                    console.error('Error extracting EPUB content:', error);
                    hideLoading();
                    showToast('Error processing EPUB file');
                }
            }
            
            function processPdfFile(file) {
                const reader = new FileReader();
                reader.onload = function() {
                    showToast('PDF support is limited. For a better experience, use a dedicated PDF reader app.');
                    
                    // Create a basic chapter with an explanation
                    state.bookData.chapters = [{
                        title: state.bookData.title || 'PDF Content',
                        content: "PDF content extraction is limited in this simple reader.\n\nFor a better experience with PDFs, consider using a dedicated PDF reader app.",
                        startLine: 0,
                        endLine: 2
                    }];
                    
                    showBook();
                    hideLoading();
                };
                reader.onerror = function(error) {
                    console.error('Error reading PDF file:', error);
                    hideLoading();
                    showToast('Error reading PDF file');
                };
                reader.readAsArrayBuffer(file);
            }

            // Firecrawl API helper
            async function firecrawlScrapeRequest(apiKey, url) {
                try {
                    const response = await fetch('https://api.firecrawl.dev/v0/scrape', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({ url: url })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `Firecrawl API request failed with status ${response.status}`);
                    }
                    
                    return await response.json();
                } catch (error) {
                    console.error('Error calling Firecrawl API:', error);
                    return { error: { message: error.message || 'Failed to connect to Firecrawl API' } };
                }
            }

            // Process URL input using Firecrawl
            async function processUrlInput() {
                const url = DOM.urlInput.value.trim();
                if (!url) {
                    showToast('Please enter a valid URL');
                    return;
                }

                // Check for Firecrawl API key
                if (!state.userApiSettings || !state.userApiSettings.firecrawl_api_key) {
                    showToast('Firecrawl API key not configured. Please set it up in the main dashboard.');
                    // Optionally open the dashboard in a new tab
                    // window.open('index.html', '_blank'); 
                    return;
                }

                // Add loading state to button
                DOM.processUrlBtn.classList.add('loading');
                DOM.processUrlBtn.disabled = true;
                // Optionally show the main loading overlay as well
                // showLoading(); 

                DOM.bookTitle.textContent = `Reading: ${url}`; // Temporary title
                state.bookData.title = url; // Use URL as initial title

                try {
                    const response = await firecrawlScrapeRequest(state.userApiSettings.firecrawl_api_key, url);

                    if (response.error) {
                        throw new Error(response.error.message);
                    }

                    if (!response.data || !response.data.markdown) {
                        throw new Error('No markdown content received from Firecrawl.');
                    }

                    const markdownContent = response.data.markdown;
                    state.bookData.content = markdownContent; // Store raw markdown

                    // Update title if Firecrawl provided one
                    if (response.data.metadata && response.data.metadata.title) {
                        state.bookData.title = response.data.metadata.title;
                        DOM.bookTitle.textContent = state.bookData.title;
                    }

                    // Process markdown into chapters (simple split for now, could be improved)
                    // Treat major headings (##) as chapter breaks
                    const lines = markdownContent.split('\n');
                    let chapters = [];
                    let currentChapterContent = [];
                    let currentChapterTitle = state.bookData.title || 'Chapter 1';
                    let chapterIndex = 1;

                    lines.forEach((line, index) => {
                        const trimmedLine = line.trim();
                        if (trimmedLine.startsWith('## ') && currentChapterContent.length > 0) {
                            // Start new chapter
                            chapters.push({
                                title: currentChapterTitle,
                                content: currentChapterContent.join('\n'),
                                startLine: 0, // Adjust if needed
                                endLine: 0    // Adjust if needed
                            });
                            currentChapterTitle = trimmedLine.substring(3).trim() || `Chapter ${++chapterIndex}`;
                            currentChapterContent = [line]; // Include the heading in the new chapter
                        } else {
                            if (trimmedLine.startsWith('## ') && currentChapterContent.length === 0) {
                                // Set title for the first chapter
                                currentChapterTitle = trimmedLine.substring(3).trim() || `Chapter ${chapterIndex}`;
                            }
                            currentChapterContent.push(line);
                        }
                    });

                    // Add the last chapter
                    if (currentChapterContent.length > 0) {
                         chapters.push({
                            title: currentChapterTitle,
                            content: currentChapterContent.join('\n'),
                            startLine: 0, // Adjust if needed
                            endLine: 0    // Adjust if needed
                        });
                    }
                    
                    // If no chapters were created (e.g., no '##' headings), create one chapter
                    if (chapters.length === 0) {
                         chapters.push({
                            title: state.bookData.title || 'Content',
                            content: markdownContent,
                            startLine: 0,
                            endLine: lines.length
                        });
                    }

                    state.bookData.chapters = chapters;

                    // --- Auto-enable Markdown mode for URL content ---
                    state.settings.markdownModeEnabled = true;
                    DOM.markdownModeToggle.checked = true;
                    // --- End change ---

                    showBook(); // This will now render with Markdown enabled

                } catch (error) {
                    console.error('Error processing URL:', error);
                    showToast(`Error reading URL: ${error.message}`);
                    goToHome(); // Go back to welcome screen on error
                } finally {
                    hideLoading();
                }
            }
            
            // Book display functions
            function showBook() {
                // Hide welcome screen
                DOM.welcomeScreen.style.display = 'none';
                
                // Show content
                displayCurrentChapter();
                
                // Show navbar briefly
                DOM.navbar.classList.add('visible');
                
                // Set timeout to auto-hide navbar
                clearTimeout(state.navbarHideTimer);
                state.navbarHideTimer = setTimeout(() => {
                    DOM.navbar.classList.remove('visible');
                }, 3000);
                
                // Populate table of contents
                populateToc();
                
                // Save book to library
                saveBookToLibrary();
            }
            
            function displayCurrentChapter() {
                const chapter = state.bookData.chapters[state.bookData.currentPosition];
                if (!chapter) return;
                
                DOM.contentArea.innerHTML = ''; // Clear previous content
                
                // Update chapter title in navbar
                DOM.bookTitle.textContent = `${state.bookData.title || 'Book'} - ${chapter.title}`;

                // Check if Markdown mode is enabled
                if (state.settings.markdownModeEnabled) {
                    // Render Markdown with basic formatting (links, bold) while preserving line breaks
                    let processedContent = chapter.content;

                    // Apply [link text](url) markdown -> <a> tags FIRST
                    // Added rel="noopener noreferrer" for security
                    processedContent = processedContent.replace(/\[(.*?)\]\((.*?)\)/g, (match, text, url) => {
                        const safeUrl = url.trim().replace(/"/g, '&quot;'); // Escape quotes in URL
                        // Basic check for common protocols or relative/anchor paths
                        if (safeUrl.startsWith('http:') || safeUrl.startsWith('https:') || safeUrl.startsWith('/') || safeUrl.startsWith('#')) {
                             // Escape HTML entities in link text to prevent XSS if text contains HTML chars
                             // We will apply bold *after* this, so don't escape the asterisks here yet.
                             const escapedText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                             return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${escapedText}</a>`;
                        }
                        // If URL looks unsafe or not standard, just display the escaped text
                        return text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    });

                    // Apply **bold** markdown -> <strong> tags SECOND
                    // Using a non-greedy match for content inside **
                    // This will now correctly apply bold inside the already created <a> tags or anywhere else.
                    processedContent = processedContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

                    // Replace newline characters with <br> tags to preserve line breaks
                    processedContent = processedContent.replace(/\n/g, '<br>');

                    // Set the innerHTML. Assumes the original markdown source is relatively safe
                    // or that the potential harm from unescaped HTML (outside links/bold) is acceptable.
                    DOM.contentArea.innerHTML = processedContent;

                    // Ensure wrapping works correctly, overriding potential inherited styles
                    DOM.contentArea.style.whiteSpace = 'normal';
                    DOM.contentArea.style.wordWrap = 'break-word';

                } else {
                    // Original HTML rendering logic
                    const lines = chapter.content.split('\n');
                    let currentElement = null;

                    lines.forEach((line, index) => {
                        // ... (keep existing HTML rendering logic here) ...
                        const trimmedLine = line.trim();

                        if (trimmedLine.startsWith('# ')) { // H1
                            const h = document.createElement('h1');
                            h.textContent = trimmedLine.substring(2).trim();
                            DOM.contentArea.appendChild(h);
                            currentElement = null;
                        } else if (trimmedLine.startsWith('## ')) { // H2
                            const h = document.createElement('h2');
                            h.textContent = trimmedLine.substring(3).trim();
                            DOM.contentArea.appendChild(h);
                            currentElement = null;
                        } else if (trimmedLine.startsWith('### ')) { // H3
                            const h = document.createElement('h3');
                            h.textContent = trimmedLine.substring(4).trim();
                            DOM.contentArea.appendChild(h);
                            currentElement = null;
                        } else if (trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ')) { // List item
                            if (!currentElement || currentElement.tagName !== 'UL') {
                                currentElement = document.createElement('ul');
                                DOM.contentArea.appendChild(currentElement);
                            }
                            const li = document.createElement('li');
                            li.textContent = trimmedLine.substring(2).trim();
                            currentElement.appendChild(li);
                        } else if (trimmedLine === '---' || trimmedLine === '***') { // Horizontal rule
                            DOM.contentArea.appendChild(document.createElement('hr'));
                            currentElement = null;
                        } else if (trimmedLine) { // Paragraph
                            const p = document.createElement('p');
                            // Basic inline markdown (bold, italic) - could be expanded
                            let processedLine = line.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                            processedLine = processedLine.replace(/\*(.*?)\*/g, '<em>$1</em>');
                            p.innerHTML = processedLine; // Use innerHTML for basic formatting
                            p.setAttribute('data-p-index', index); // Add index for position tracking
                            DOM.contentArea.appendChild(p);
                            currentElement = null;
                        } else if (currentElement && currentElement.tagName === 'P') {
                             // Add extra space after a paragraph if followed by a blank line
                             DOM.contentArea.appendChild(document.createElement('br'));
                             currentElement = null;
                        } else if (!currentElement) {
                             // Add single break for consecutive blank lines outside paragraphs/lists
                             DOM.contentArea.appendChild(document.createElement('br'));
                        }
                    });
                } // End of the 'else' block for HTML rendering
                
                // Initially scroll to top (will be updated if restoring position)
                DOM.contentArea.scrollTop = 0;
                
                // Update navigation buttons visibility
                updateNavigationButtonsState();
                
                // Update progress bar
                updateProgressBar();
                
                // Make summarize button visible if API settings are available
                if (state.userApiSettings) {
                    DOM.summarizeBtn.style.display = 'block';
                }
            }
            
            function populateToc() {
                DOM.tocContent.innerHTML = '';
                
                state.bookData.chapters.forEach((chapter, index) => {
                    const item = document.createElement('div');
                    item.className = 'toc-item';
                    item.textContent = chapter.title;
                    item.setAttribute('data-index', index);
                    
                    if (index === state.bookData.currentPosition) {
                        item.classList.add('toc-active');
                    }
                    
                    item.addEventListener('click', () => {
                        state.bookData.currentPosition = index;
                        displayCurrentChapter();
                        closeTocPanel();
                        
                        // Save progress after TOC navigation
                        saveBookToLibrary();
                    });
                    
                    DOM.tocContent.appendChild(item);
                });
            }
            
            function updateNavigationButtonsState() {
                // Update previous button visibility
                if (state.bookData.currentPosition <= 0) {
                    DOM.prevBtn.style.opacity = '0.5';
                    DOM.prevBtn.style.pointerEvents = 'none';
                } else {
                    DOM.prevBtn.style.opacity = '1';
                    DOM.prevBtn.style.pointerEvents = 'auto';
                }
                
                // Update next button visibility
                if (state.bookData.currentPosition >= state.bookData.chapters.length - 1) {
                    DOM.nextBtn.style.opacity = '0.5';
                    DOM.nextBtn.style.pointerEvents = 'none';
                } else {
                    DOM.nextBtn.style.opacity = '1';
                    DOM.nextBtn.style.pointerEvents = 'auto';
                }
            }
            
            // Navigation functions
            function goToPrevious() {
                if (state.bookData.currentPosition > 0) {
                    state.bookData.currentPosition--;
                    displayCurrentChapter();
                    saveBookToLibrary();
                }
            }
            
            function goToNext() {
                if (state.bookData.currentPosition < state.bookData.chapters.length - 1) {
                    state.bookData.currentPosition++;
                    displayCurrentChapter();
                    saveBookToLibrary();
                }
            }
            
            // UI Controls
            function toggleNavbar() {
                DOM.navbar.classList.toggle('visible');
                
                if (DOM.navbar.classList.contains('visible')) {
                    clearTimeout(state.navbarHideTimer);
                    state.navbarHideTimer = setTimeout(() => {
                        DOM.navbar.classList.remove('visible');
                    }, 3000);
                }
            }
            
            function toggleTocPanel() {
                DOM.tocPanel.classList.toggle('visible');
                DOM.overlay.classList.toggle('visible');
                DOM.settingsPanel.classList.remove('visible');
                
                // If the TOC panel is now visible, scroll to the active chapter
                if (DOM.tocPanel.classList.contains('visible')) {
                    // Find the active TOC item
                    const activeItem = DOM.tocContent.querySelector('.toc-item[data-index="' + state.bookData.currentPosition + '"]');
                    
                    if (activeItem) {
                        // Scroll the item into view with some offset from the top
                        setTimeout(() => {
                            activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 100); // Small delay to ensure panel is visible
                    }
                }
            }
            
            function closeTocPanel() {
                DOM.tocPanel.classList.remove('visible');
                DOM.overlay.classList.remove('visible');
            }
            
            function toggleSettingsPanel() {
                DOM.settingsPanel.classList.toggle('visible');
                DOM.overlay.classList.toggle('visible');
                DOM.tocPanel.classList.remove('visible');
            }
            
            function closeSettingsPanel() {
                DOM.settingsPanel.classList.remove('visible');
                DOM.overlay.classList.remove('visible');
            }
            
            function closeAllPanels() {
                DOM.tocPanel.classList.remove('visible');
                DOM.settingsPanel.classList.remove('visible');
                DOM.overlay.classList.remove('visible');
            }
            
            function goToHome() {
                DOM.welcomeScreen.style.display = 'flex';
                DOM.navbar.classList.remove('visible');
                closeAllPanels();
                DOM.fileInput.value = ''; // Reset file input
                DOM.textInput.value = ''; // Reset text input
                DOM.textInputTitle.value = ''; // Reset text input title
                
                // Reset book data
                state.bookData = {
                    title: '',
                    content: '',
                    chapters: [],
                    currentPosition: 0
                };
                
                // Refresh library if user is logged in
                supabase.auth.getSession().then(({ data: { session } }) => {
                    if (session) {
                        loadUserLibrary();
                    }
                });
            }
            
            function handleContentClick(e) {
                // Don't toggle UI if text is being selected
                const selection = window.getSelection();
                if (selection && selection.toString().trim().length > 0) return;
                
                // Get click position
                const clickY = e.clientY;
                const viewportHeight = window.innerHeight;
                
                // If navbar is visible, hide it on click outside of navbar
                if (DOM.navbar.classList.contains('visible')) {
                    // Check if click is outside navbar
                    if (!DOM.navbar.contains(e.target)) {
                        DOM.navbar.classList.remove('visible');
                    }
                } 
                // If navbar is hidden, show it on click in top area
                else if (clickY <= viewportHeight * 0.15) {
                    DOM.navbar.classList.add('visible');
                    
                    // Auto-hide after delay
                    clearTimeout(state.navbarHideTimer);
                    state.navbarHideTimer = setTimeout(() => {
                        DOM.navbar.classList.remove('visible');
                    }, 3000);
                }
                
                // Hide translation popup when clicking elsewhere
                DOM.translationPopup.classList.remove('visible');
                setTimeout(() => {
                    DOM.translationPopup.style.display = 'none';
                }, 200); // Match transition duration
            }
            
            // Handle text selection for translation
            function handleTextSelection() {
                // Check if translation is enabled
                const translationEnabled = DOM.translationToggle.checked;
                if (!translationEnabled) {
                    return;
                }
                
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                // Hide the popup if no text is selected
                if (!selectedText) {
                    DOM.translationPopup.style.display = 'none';
                    clearTimeout(state.translationTimer);
                    return;
                }
                
                // Only proceed for reasonable text selection
                if (selectedText.length > 1 && selectedText.length < 500) {
                    // Clear any existing timer
                    clearTimeout(state.translationTimer);
                    
                    // Set a new timer for translation (750ms delay)
                    state.translationTimer = setTimeout(() => {
                        // Get the selection's bounding box
                        const range = selection.getRangeAt(0);
                        const rect = range.getBoundingClientRect();
                        state.lastSelectionRect = rect; // <-- SAVE the rect for flashcard positioning
                        
                        // Position the translation popup safely within viewport
                        positionTranslationPopup(rect);
                        
                        // Show loading state
                        DOM.translationContent.textContent = 'Translating...';
                        DOM.translationLoading.style.display = 'flex';
                        
                        // Get translation
                        translateText(selectedText);
                    }, 750);
                }
            }
            
            function positionTranslationPopup(rect) {
                const popup = DOM.translationPopup;
                
                // Get viewport dimensions
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Make sure popup is displayed so we can get its dimensions
                popup.style.display = 'block';
                popup.classList.remove('visible');
                
                // Initial position
                let leftPos = rect.left + window.scrollX;
                let topPos = rect.bottom + window.scrollY + 10;
                
                // Get popup dimensions
                const popupWidth = popup.offsetWidth;
                const popupHeight = popup.offsetHeight;
                
                // Adjust horizontal position
                if (leftPos + popupWidth > viewportWidth - 10) {
                    leftPos = Math.max(10, viewportWidth - popupWidth - 10);
                }
                
                // Adjust vertical position
                if (topPos + popupHeight > viewportHeight + window.scrollY - 10) {
                    // Position above selection if it would go off bottom
                    topPos = rect.top + window.scrollY - popupHeight - 10;
                    
                    // If now goes off top, position to the side instead
                    if (topPos < window.scrollY) {
                        // Try right side
                        leftPos = rect.right + window.scrollX + 10;
                        topPos = rect.top + window.scrollY;
                        
                        // If goes off right edge, try left side
                        if (leftPos + popupWidth > viewportWidth - 10) {
                            leftPos = Math.max(10, rect.left + window.scrollX - popupWidth - 10);
                        }
                    }
                }
                
                // Update popup position
                popup.style.left = `${leftPos}px`;
                popup.style.top = `${topPos}px`;
                
                // Show the popup with transition
                requestAnimationFrame(() => {
                    popup.classList.add('visible');
                });
            }
            
            // Settings controls
            function decreaseFontSize() {
                if (state.settings.fontSize > 70) {
                    state.settings.fontSize -= 10;
                    updateFontSize();
                } else {
                    showToast('Minimum font size reached');
                }
            }
            
            function increaseFontSize() {
                if (state.settings.fontSize < 200) {
                    state.settings.fontSize += 10;
                    updateFontSize();
                } else {
                    showToast('Maximum font size reached');
                }
            }
            
            function updateFontSize() {
                DOM.contentArea.style.fontSize = `${state.settings.fontSize}%`;
                DOM.fontSizeValue.textContent = `${state.settings.fontSize}%`;
                // Save immediately to localStorage
                localStorage.setItem('ebook-font-size', state.settings.fontSize);
            }
            
            function decreaseLineHeight() {
                if (state.settings.lineHeight > 1.2) {
                    state.settings.lineHeight = Math.round((state.settings.lineHeight - 0.1) * 10) / 10;
                    updateLineHeight();
                } else {
                    showToast('Minimum line height reached');
                }
            }
            
            function increaseLineHeight() {
                if (state.settings.lineHeight < 2.4) {
                    state.settings.lineHeight = Math.round((state.settings.lineHeight + 0.1) * 10) / 10;
                    updateLineHeight();
                } else {
                    showToast('Maximum line height reached');
                }
            }
            
            function updateLineHeight() {
                DOM.contentArea.style.lineHeight = state.settings.lineHeight;
                DOM.lineHeightValue.textContent = state.settings.lineHeight;
                // Save immediately to localStorage
                localStorage.setItem('ebook-line-height', state.settings.lineHeight);
            }
            
            function setTheme(theme) {
                // Remove all theme classes
                document.body.classList.remove('light-theme', 'sepia-theme', 'dark-theme');
                // Add the selected theme class
                document.body.classList.add(`${theme}-theme`);
                
                // Update active state on theme options
                DOM.themeOptions.forEach(option => {
                    option.classList.remove('active');
                    if (option.getAttribute('data-theme') === theme) {
                        option.classList.add('active');
                    }
                });
                
                state.settings.theme = theme;
                // Save immediately to localStorage
                localStorage.setItem('ebook-theme', theme);
            }
            
            function updateProgressBar() {
                if (!state.bookData.chapters.length) return;
                
                const scrollTop = DOM.contentArea.scrollTop;
                const scrollHeight = DOM.contentArea.scrollHeight;
                const clientHeight = DOM.contentArea.clientHeight;
                
                // Calculate chapter progress (0-1)
                let chapterProgress = 0;
                if (scrollHeight > clientHeight) {
                    chapterProgress = scrollTop / (scrollHeight - clientHeight);
                }
                
                // Calculate overall progress 
                const chaptersProgress = state.bookData.currentPosition / Math.max(1, state.bookData.chapters.length - 1);
                const weightedChapterProgress = chapterProgress / state.bookData.chapters.length;
                const overallProgress = (chaptersProgress + weightedChapterProgress) * 100;
                
                // Update progress bar width
                DOM.progressBar.style.width = `${overallProgress}%`;
                
                // Save reading progress to library after a delay
                debounce(saveReadingProgress, 1500)();
            }
            
            // Save reading progress with enhanced position tracking
            function saveReadingProgress() {
                // Store additional metadata for better position restoration
                const currentPosition = {
                    // Basic chapter position
                    chapter: state.bookData.currentPosition,
                    
                    // Percentage through chapter (more resilient to font/layout changes)
                    percentComplete: calculatePercentageComplete(),
                    
                    // Absolute scroll position as fallback
                    scroll: DOM.contentArea.scrollTop || 0,
                    
                    // Current viewport data for validation
                    viewportHeight: DOM.contentArea.clientHeight,
                    contentHeight: DOM.contentArea.scrollHeight,
                    
                    // Timestamp for freshness check
                    timestamp: new Date().getTime(),
                    
                    // Store text anchor for even more precise positioning
                    textAnchor: findVisibleTextAnchor()
                };
                
                // Store in local state
                state.lastPosition = currentPosition;
                
                // Save to library storage
                saveBookToLibrary();
            }
            
            // Calculate percentage complete in current chapter
            function calculatePercentageComplete() {
                const scrollTop = DOM.contentArea.scrollTop;
                const scrollHeight = DOM.contentArea.scrollHeight;
                const clientHeight = DOM.contentArea.clientHeight;
                
                if (scrollHeight <= clientHeight) return 0;
                return scrollTop / (scrollHeight - clientHeight);
            }
            
            // Find the first visible text element as an anchor
            function findVisibleTextAnchor() {
                const paragraphs = DOM.contentArea.querySelectorAll('p');
                const scrollTop = DOM.contentArea.scrollTop;
                const viewportHeight = DOM.contentArea.clientHeight;
                
                // Add index attribute to paragraphs if not already there
                if (!paragraphs[0]?.hasAttribute('data-p-index')) {
                    paragraphs.forEach((p, index) => {
                        p.setAttribute('data-p-index', index);
                    });
                }
                
                // Find the first paragraph that's visible in the viewport
                for (let i = 0; i < paragraphs.length; i++) {
                    const rect = paragraphs[i].getBoundingClientRect();
                    const paragraphTop = rect.top + scrollTop - DOM.contentArea.offsetTop;
                    
                    // If this paragraph is fully or partially visible
                    if (paragraphTop + rect.height > scrollTop && paragraphTop < scrollTop + viewportHeight) {
                        // Get first 50 chars of content for validation, and calculate offset
                        const text = paragraphs[i].textContent?.substring(0, 50) || '';
                        const offset = (scrollTop - paragraphTop) / rect.height;
                        
                        // Return anchor data
                        return {
                            index: parseInt(paragraphs[i].getAttribute('data-p-index')),
                            text: text,
                            offset: Math.max(0, Math.min(1, offset))  // Clamp between 0 and 1
                        };
                    }
                }
                
                // Fallback if no paragraph is found
                return null;
            }
            
            // Utility functions
            function showLoading() {
                DOM.loading.classList.add('visible');
            }
            
            function hideLoading() {
                DOM.loading.classList.remove('visible');
            }
            
            function showToast(message, duration = 3000) {
                const toast = DOM.toast;
                toast.textContent = message;
                toast.classList.add('visible');
                
                setTimeout(() => {
                    toast.classList.remove('visible');
                }, duration);
            }
            
            function debounce(func, delay) {
                const context = this;
                return function() {
                    const args = arguments;
                    const functionName = func.name || 'anonymous';
                    
                    clearTimeout(state.debounceTimers[functionName]);
                    
                    state.debounceTimers[functionName] = setTimeout(() => {
                        func.apply(context, args);
                        delete state.debounceTimers[functionName];
                    }, delay);
                };
            }
            
            // Authentication & API Settings functions
            async function checkAuthAndLoadApiSettings() {
                // Check if the user is logged in
                const { data: { session } } = await supabase.auth.getSession();
                state.session = session;
                
                if (!session) {
                    // Show login button
                    DOM.loginBtn.classList.remove('hidden');

                    // Update auth section
                    DOM.authSection.innerHTML = `
                        <p>Sign in to save books to your library</p>
                    `;
                    
                    // Update AI settings
                    DOM.aiSettingsContent.innerHTML = `
                        <p>Please <a href="index.html" target="_blank">sign in</a> to use AI features.</p>
                    `;
                    return;
                } else {
                    // User is signed in
                    DOM.loginBtn.classList.add('hidden');
                    DOM.authSection.innerHTML = `
                        <p>Signed in as ${session.user.email}</p>
                    `;
                    
                    // Load user's library
                    DOM.librarySection.style.display = 'block';
                    loadUserLibrary();
                }
                
                // User is logged in, check if they have API settings
                state.userApiSettings = await getUserApiSettings();
                
                let aiSettingsHtml = '';
                let canUseAi = false;
                let canUseFirecrawl = false;

                if (state.userApiSettings) {
                    if (state.userApiSettings.api_key && state.userApiSettings.model) {
                        aiSettingsHtml += `
                            <p>✅ Gemini API Key configured</p>
                            <p>Model: ${state.userApiSettings.model}</p>`;
                        canUseAi = true;
                    } else {
                         aiSettingsHtml += `<p>❌ Gemini API Key not configured. <a href="index.html" target="_blank">Set up in dashboard</a>.</p>`;
                    }
                    
                    if (state.userApiSettings.firecrawl_api_key) {
                        aiSettingsHtml += `<p>✅ Firecrawl API Key configured</p>`;
                        canUseFirecrawl = true;
                    } else {
                        aiSettingsHtml += `<p>❌ Firecrawl API Key not configured. <a href="index.html" target="_blank">Set up in dashboard</a>.</p>`;
                    }
                } else {
                    aiSettingsHtml = `
                        <p>To use AI features (Summarize, Translate, Read URL), please 
                        <a href="index.html" target="_blank">sign in and configure API keys</a> in the main dashboard.</p>
                    `;
                }

                DOM.aiSettingsContent.innerHTML = aiSettingsHtml;

                // Enable/disable features based on keys
                DOM.summarizeBtn.style.display = canUseAi ? 'block' : 'none';
                DOM.translationToggle.disabled = !canUseAi; // Disable toggle if no Gemini key
                DOM.processUrlBtn.disabled = !canUseFirecrawl; // Disable URL button if no Firecrawl key
                
                // Add tooltip or visual cue for disabled URL button
                if (!canUseFirecrawl) {
                    DOM.urlInputContainer.title = "Firecrawl API key needed. Set it up in the main dashboard.";
                    DOM.processUrlBtn.style.opacity = "0.5";
                    DOM.processUrlBtn.style.cursor = "not-allowed";
                } else {
                    DOM.urlInputContainer.title = "";
                    DOM.processUrlBtn.style.opacity = "1";
                    DOM.processUrlBtn.style.cursor = "pointer";
                }
            }

            // Get the user's Gemini API settings from Supabase
            async function getUserApiSettings() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return null;
                
                const { data, error } = await supabase
                    .from('user_settings')
                    .select('api_key, model, firecrawl_api_key') // Select all needed keys
                    .eq('user_id', session.user.id)
                    .maybeSingle();
                    
                if (error) {
                    console.error('Error fetching API settings:', error);
                    return null;
                }
                
                return data;
            }
            
            // Library functions
            async function loadUserLibrary() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                
                const libraryList = document.getElementById('library-list');
                libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Loading your books...</div>';
                
                try {
                    // Fetch user's books from Supabase
                    const { data: books, error } = await supabase
                        .from('ebooks')
                        .select('*')
                        .eq('user_id', session.user.id)
                        .order('updated_at', { ascending: false });
                    
                    if (error) {
                        throw error;
                    }
                    
                    if (!books || books.length === 0) {
                        libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Your library is empty</div>';
                        return;
                    }
                    
                    // Display books
                    libraryList.innerHTML = '';
                    books.forEach(book => {
                        const date = new Date(book.updated_at).toLocaleDateString();
                        const progress = calculateOverallProgress(book);
                        
                        const item = document.createElement('div');
                        item.className = 'library-item';
                        item.innerHTML = `
                            <div class="library-item-details">
                                <div class="library-item-title">${escapeHTML(book.title)}</div>
                                <div class="library-item-meta">
                                    ${book.file_type.toUpperCase()} • Last read: ${date} • ${progress}% complete
                                </div>
                                <div class="progress-bar-container">
                                    <div class="progress-bar" style="width: ${progress}%"></div>
                                </div>
                            </div>
                            <div class="library-item-actions">
                                <button class="library-item-delete" data-id="${book.id}">×</button>
                            </div>
                        `;
                        
                        // Add click event to open the book
                        item.addEventListener('click', (event) => {
                            // Don't open if the delete button was clicked
                            if (event.target.classList.contains('library-item-delete')) {
                                return;
                            }
                            loadBookFromLibrary(book);
                        });
                        
                        libraryList.appendChild(item);
                    });
                    
                    // Add delete button event listeners
                    document.querySelectorAll('.library-item-delete').forEach(button => {
                        button.addEventListener('click', async (event) => {
                            event.stopPropagation();
                            const bookId = button.getAttribute('data-id');
                            
                            if (confirm('Remove this book from your library?')) {
                                await deleteBookFromLibrary(bookId);
                            }
                        });
                    });
                } catch (error) {
                    console.error('Error loading library:', error);
                    libraryList.innerHTML = '<div style="text-align: center; padding: 20px;">Error loading library</div>';
                }
            }
            
            // Escape HTML to prevent XSS
            function escapeHTML(str) {
                return str
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }
            
            async function deleteBookFromLibrary(bookId) {
                try {
                    const { error } = await supabase
                        .from('ebooks')
                        .delete()
                        .eq('id', bookId);
                    
                    if (error) {
                        throw error;
                    }
                    
                    // Reload library
                    loadUserLibrary();
                    showToast('Book removed from library');
                } catch (error) {
                    console.error('Error deleting book:', error);
                    showToast('Could not delete the book');
                }
            }
            
            async function saveBookToLibrary() {
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return false;
                
                if (!state.bookData.title) return false;
                
                try {
                    // Determine file type
                    let fileType = 'txt';
                    if (state.bookData.title.includes('.')) {
                        fileType = state.bookData.title.split('.').pop().toLowerCase();
                    }
                    
                    // Prepare book data
                    const bookContent = state.bookData.content && state.bookData.content.length < 100000 
                        ? state.bookData.content 
                        : null;
                    
                    // Create metadata with chapter information (without full content)
                    const metadata = {
                        chapters: state.bookData.chapters.map(chapter => {
                            // Store selective chapter content to reduce database size
                            return {
                                title: chapter.title,
                                startLine: chapter.startLine,
                                endLine: chapter.endLine,
                                content: chapter.content // Include content for better offline experience
                            };
                        }),
                        // --- Save Markdown mode preference ---
                        markdownModeEnabled: state.settings.markdownModeEnabled
                        // --- End change ---
                    };
                    
                    // Use enhanced position data if available, otherwise create basic position
                    const lastPosition = state.lastPosition || {
                        chapter: state.bookData.currentPosition,
                        scroll: DOM.contentArea.scrollTop || 0,
                        percentComplete: calculatePercentageComplete(),
                        timestamp: new Date().getTime()
                    };
                    
                    // Check if this book already exists
                    const { data: existingBooks } = await supabase
                        .from('ebooks')
                        .select('id')
                        .eq('title', state.bookData.title)
                        .eq('user_id', session.user.id)
                        .maybeSingle();
                    
                    if (existingBooks && existingBooks.id) {
                        // Update existing book
                        const { error } = await supabase
                            .from('ebooks')
                            .update({
                                title: state.bookData.title,
                                content: bookContent,
                                file_type: fileType,
                                metadata: metadata,
                                last_position: lastPosition,
                                updated_at: new Date()
                            })
                            .eq('id', existingBooks.id);
                        
                        if (error) throw error;
                    } else {
                        // Insert new book
                        const { error } = await supabase
                            .from('ebooks')
                            .insert({
                                user_id: session.user.id,
                                title: state.bookData.title,
                                content: bookContent,
                                file_type: fileType,
                                metadata: metadata,
                                last_position: lastPosition
                            });
                        
                        if (error) throw error;
                    }
                    
                    return true;
                } catch (error) {
                    console.error('Error saving book:', error);
                    return false;
                }
            }
            
            async function loadBookFromLibrary(book) {
                showLoading();
                
                try {
                    // Set up book data
                    state.bookData.title = book.title;
                    DOM.bookTitle.textContent = book.title;
                    
                    // Check for chapters in metadata
                    if (book.metadata && book.metadata.chapters && book.metadata.chapters.length > 0) {
                        state.bookData.chapters = book.metadata.chapters.map(chapter => {
                            return {
                                title: chapter.title,
                                content: chapter.content || "Chapter content not available",
                                startLine: chapter.startLine,
                                endLine: chapter.endLine
                            };
                        });
                    }
                    // Fallback to content if no chapters in metadata
                    else if (book.content) {
                        state.bookData.content = book.content;
                        
                        // Create a single chapter from content
                        state.bookData.chapters = [{
                            title: book.title,
                            content: book.content,
                            startLine: 0,
                            endLine: book.content.split('\n').length
                        }];
                    } 
                    // No usable content
                    else {
                        throw new Error('Book content not available');
                    }

                    // --- Restore Markdown mode preference ---
                    if (book.metadata && book.metadata.markdownModeEnabled !== undefined) {
                        state.settings.markdownModeEnabled = book.metadata.markdownModeEnabled;
                    } else {
                        // Default for older books or if not set
                        state.settings.markdownModeEnabled = false;
                    }
                    DOM.markdownModeToggle.checked = state.settings.markdownModeEnabled;
                    // --- End change ---

                    // Save last position data for restoration after render
                    const lastPosition = book.last_position || {};

                    // Restore chapter position
                    if (lastPosition.chapter !== undefined) {
                        state.bookData.currentPosition = lastPosition.chapter;
                    }
                    
                    // Show the book
                    showBook();
                    
                    // Attempt to restore reading position with adaptive approach
                    restoreReadingPosition(lastPosition);
                    
                    hideLoading();
                } catch (error) {
                    console.error('Error loading book:', error);
                    hideLoading();
                    showToast('Error loading book: ' + error.message);
                }
            }
            
            // Restore reading position using multiple methods for reliability
            function restoreReadingPosition(lastPosition) {
                if (!lastPosition) return;
                
                // Show toast notification about restoring position
                showToast('Restoring reading position...', 1500);
                
                // Use requestAnimationFrame to ensure content is rendered
                requestAnimationFrame(() => {
                    // Check if position information is fresh enough (within last 90 days)
                    const isPositionRecent = lastPosition.timestamp && 
                        (Date.now() - lastPosition.timestamp < 90 * 24 * 60 * 60 * 1000);
                
                    // First try restoring by text anchor (most reliable across different font sizes/layouts)
                    if (isPositionRecent && lastPosition.textAnchor) {
                        const restored = restoreByTextAnchor(lastPosition.textAnchor);
                        if (restored) return;
                    }
                    
                    // Next try percentage-based position (good for different screen sizes)
                    if (lastPosition.percentComplete !== undefined) {
                        const scrollHeight = DOM.contentArea.scrollHeight;
                        const clientHeight = DOM.contentArea.clientHeight;
                        
                        if (scrollHeight > clientHeight) {
                            const targetPosition = lastPosition.percentComplete * (scrollHeight - clientHeight);
                            DOM.contentArea.scrollTo({
                                top: targetPosition,
                                behavior: 'smooth'
                            });
                            return;
                        }
                    }
                    
                    // Fallback to absolute scroll position
                    if (lastPosition.scroll) {
                        // Check if content height ratio is similar to maintain relative position
                        if (lastPosition.contentHeight && lastPosition.viewportHeight) {
                            const oldRatio = lastPosition.contentHeight / lastPosition.viewportHeight;
                            const newRatio = DOM.contentArea.scrollHeight / DOM.contentArea.clientHeight;
                            
                            // If ratios are reasonably similar, scale the scroll position
                            if (Math.abs(oldRatio - newRatio) < 0.5) {
                                const scaledPosition = lastPosition.scroll * (newRatio / oldRatio);
                                DOM.contentArea.scrollTo({
                                    top: scaledPosition,
                                    behavior: 'smooth'
                                });
                                return;
                            }
                        }
                        
                        // Last resort: try direct scroll position
                        DOM.contentArea.scrollTo({
                            top: lastPosition.scroll,
                            behavior: 'smooth'
                        });
                    }
                });
            }
            
            // Try to find and scroll to the text anchor
            function restoreByTextAnchor(textAnchor) {
                if (!textAnchor || textAnchor.index === undefined) return false;
                
                // Find all paragraphs
                const paragraphs = DOM.contentArea.querySelectorAll('p');
                
                // Try to find paragraph by index
                const paragraph = paragraphs[textAnchor.index];
                if (!paragraph) return false;
                
                // Verify content if text anchor has text (avoid wrong positioning)
                if (textAnchor.text) {
                    const actualText = paragraph.textContent?.substring(0, textAnchor.text.length) || '';
                    // Simple similarity check
                    const isSimilar = actualText.length > 0 && 
                        (actualText === textAnchor.text || 
                        (actualText.length > 10 && actualText.slice(0, 10) === textAnchor.text.slice(0, 10)));
                    
                    if (!isSimilar) {
                        // Content doesn't match, try finding by text search
                        for (let i = 0; i < paragraphs.length; i++) {
                            const searchText = paragraphs[i].textContent?.substring(0, textAnchor.text.length) || '';
                            if (searchText === textAnchor.text || 
                                (searchText.length > 10 && searchText.slice(0, 10) === textAnchor.text.slice(0, 10))) {
                                // Found matching paragraph
                                const rect = paragraphs[i].getBoundingClientRect();
                                const top = paragraphs[i].offsetTop - DOM.contentArea.offsetTop;
                                
                                // Apply offset within paragraph if available
                                const offset = textAnchor.offset || 0;
                                const scrollTarget = top + (offset * rect.height);
                                
                                // Scroll to position with slight offset for better reading
                                DOM.contentArea.scrollTo({
                                    top: Math.max(0, scrollTarget - 50),
                                    behavior: 'smooth'
                                });
                                return true;
                            }
                        }
                        return false;
                    }
                }
                
                // Calculate position in paragraph
                const rect = paragraph.getBoundingClientRect();
                const top = paragraph.offsetTop - DOM.contentArea.offsetTop;
                
                // Apply offset within paragraph if available
                const offset = textAnchor.offset || 0;
                const scrollTarget = top + (offset * rect.height);
                
                // Scroll to position with slight offset for better reading
                DOM.contentArea.scrollTo({
                    top: Math.max(0, scrollTarget - 50),
                    behavior: 'smooth'
                });
                
                return true;
            }
            
            // AI features
            // Gemini API helper functions
            const getApiUrl = (model) => `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=`;
            
            async function geminiRequest(apiKey, message, model) {
                try {
                    const res = await fetch(`${getApiUrl(model)}${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: message }]
                            }]
                        })
                    });
                    
                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(errorData.error?.message || 'API request failed');
                    }
                    
                    return res.json();
                } catch (error) {
                    console.error('Error calling Gemini API:', error);
                    return { error: { message: error.message || 'Failed to connect to Gemini API' } };
                }
            }
            
            // Translate text using Gemini API
            async function translateText(text) {
                if (!state.userApiSettings) {
                    DOM.translationContent.textContent = 'Please configure API key in settings to use translation.';
                    return;
                }
                
                // Show loading indicator
                DOM.translationContent.textContent = '';
                DOM.translationLoading.style.display = 'flex';
                
                try {
                    const prompt = `Translate the following English text to Vietnamese. Only return the translation without any explanation or additional text.\n\nText: "${text}"`;
                    
                    const response = await geminiRequest(
                        state.userApiSettings.api_key, 
                        prompt, 
                        state.userApiSettings.model
                    );
                    
                    // Hide loading indicator
                    DOM.translationLoading.style.display = 'none';
                    
                    if (response.error) {
                        DOM.translationContent.textContent = `Error: ${response.error.message}`;
                        return;
                    }
                    
                    const translation = response?.candidates?.[0]?.content?.parts?.[0]?.text || 'Translation failed.';
                    DOM.translationContent.textContent = translation;
                    
                    // Generate flashcard in parallel
                    generateFlashcard(text);
                } catch (error) {
                    console.error('Error translating text:', error);
                    DOM.translationLoading.style.display = 'none';
                    DOM.translationContent.textContent = 'An error occurred during translation.';
                }
            }
            
            // Generate a flashcard from selected text
            async function generateFlashcard(text) {
                if (!state.userApiSettings) return;
                
                try {
                    const prompt = `Extract a single useful vocabulary word or phrase from this text that would be good for a language learner. If the text is long, choose the most difficult or interesting word/phrase.
                    
                    Text: "${text}"
                    
                    Return in this JSON format without any additional text:
                    {
                        "word": "the extracted word or short phrase",
                        "phrase": "A sentence showing the word in context, with the <b>word</b> in bold",
                        "translation_answer": "vietnamese translation\\nBrief definition in English"
                    }`;
                    
                    const response = await geminiRequest(
                        state.userApiSettings.api_key, 
                        prompt, 
                        state.userApiSettings.model
                    );
                    
                    if (response.error) {
                        console.error('Error generating flashcard:', response.error);
                        return;
                    }
                    
                    const flashcardText = response?.candidates?.[0]?.content?.parts?.[0]?.text || '';
                    
                    // Try to extract JSON from the response
                    try {
                        // Find the JSON part in the response
                        const jsonMatch = flashcardText.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const flashcardData = JSON.parse(jsonMatch[0]);
                            showFlashcardToast(flashcardData);
                        }
                    } catch (jsonError) {
                        console.error('Error parsing flashcard JSON:', jsonError, flashcardText);
                    }
                } catch (error) {
                    console.error('Error generating flashcard:', error);
                }
            }
            
            // Format translation to make Vietnamese part bold and English part italic
            function formatTranslation(translation) {
                // Split by newline - first part is Vietnamese, second part is English definition
                const parts = translation.split('\n');
                if (parts.length > 1) {
                    return `<b>${escapeHTML(parts[0])}</b><br><i>${escapeHTML(parts.slice(1).join('\n'))}</i>`;
                }
                return escapeHTML(translation);
            }
            
            // Show flashcard as a toast notification
            function showFlashcardToast(flashcardData) {
                // Remove any existing flashcard toast
                const existingToast = document.querySelector('.flashcard-toast');
                if (existingToast) {
                    existingToast.remove();
                }
                
                // Create toast element
                const toast = document.createElement('div');
                toast.className = 'flashcard-toast visible';
                
                // New positioning logic: if we have a selection rectangle, position near it
                if (state.lastSelectionRect) {
                    let left = state.lastSelectionRect.left;
                    let top = state.lastSelectionRect.bottom + 10; // 10px offset below the selection
                    
                    // Ensure the flashcard does not run off-screen horizontally.
                    const flashcardWidth = 240; // using the width from our CSS (flashcard-toast width)
                    if (left + flashcardWidth > window.innerWidth) {
                        left = window.innerWidth - flashcardWidth - 10;
                    }
                    
                    // Set inline style to override default CSS positioning
                    toast.style.left = `${left}px`;
                    toast.style.top = `${top}px`;
                    toast.style.bottom = 'auto';
                    toast.style.right = 'auto';
                } else {
                    // Fallback to default bottom-right positioning if no selection rect is available
                    toast.style.bottom = "20px";
                    toast.style.right = "20px";
                }
                
                // Create flashcard content with HTML escaping for security
                toast.innerHTML = `
                    <div class="flashcard-header">
                        <div class="flashcard-word">${escapeHTML(flashcardData.word)}</div>
                        <button type="button" class="flashcard-close-btn" aria-label="Close">×</button>
                    </div>
                    <div class="flashcard-translation">${formatTranslation(flashcardData.translation_answer)}</div>
                    <div class="flashcard-actions">
                        <button type="button" class="flashcard-speak-btn" aria-label="Speak">🔊</button>
                        <button type="button" class="flashcard-save-btn">Save</button>
                    </div>
                `;
                
                // Add to the document
                document.body.appendChild(toast);
                
                // Add close button functionality
                toast.querySelector('.flashcard-close-btn').addEventListener('click', () => {
                    toast.classList.add('fade-out');
                    setTimeout(() => {
                        toast.remove();
                    }, 500);
                });
                
                // Add speak button functionality
                toast.querySelector('.flashcard-speak-btn').addEventListener('click', () => {
                    speakText(flashcardData.word);
                });
                
                // Auto-speak if enabled
                const autoSpeakEnabled = localStorage.getItem('auto-speak-enabled') !== 'false';
                if (autoSpeakEnabled) {
                    // Small delay to ensure the toast is fully rendered
                    setTimeout(() => speakText(flashcardData.word), 300);
                }
                
                // Save button functionality
                toast.querySelector('.flashcard-save-btn').addEventListener('click', async () => {
                    const saveButton = toast.querySelector('.flashcard-save-btn');
                    
                    // Disable button while saving
                    saveButton.textContent = 'Saving...';
                    saveButton.disabled = true;
                    
                    // Only proceed if user is logged in
                    const { data: { session } } = await supabase.auth.getSession();
                    if (!session) {
                        showToast('Please sign in to save flashcards');
                        saveButton.textContent = 'Save';
                        saveButton.disabled = false;
                        return;
                    }
                    
                    try {
                        // Save to Supabase
                        const { error } = await supabase
                            .from('flashcards')
                            .insert({
                                user_id: session.user.id,
                                word: flashcardData.word,
                                phrase: flashcardData.phrase,
                                translation_answer: flashcardData.translation_answer,
                                state: "new",
                                due: new Date().toISOString(),
                                stability: 0.5, // Default stability
                                difficulty: 5, // Default difficulty 
                                elapsed_days: 0,
                                scheduled_days: 0,
                                reps: 0, 
                                lapses: 0
                            });
                            
                        if (error) throw error;
                        
                        // Update UI to show success
                        saveButton.textContent = 'Saved!';
                        saveButton.disabled = true;
                        
                        // Add fade-out animation after a short delay
                        setTimeout(() => {
                            toast.classList.add('fade-out');
                            
                            // Remove the element after the animation completes
                            setTimeout(() => {
                                if (document.body.contains(toast)) {
                                    toast.remove();
                                }
                            }, 500); // Match this duration to the CSS transition time
                        }, 1000);
                        
                    } catch (error) {
                        console.error('Error saving flashcard:', error);
                        saveButton.textContent = 'Failed';
                        
                        // Reset after a delay
                        setTimeout(() => {
                            saveButton.textContent = 'Retry';
                            saveButton.disabled = false;
                        }, 1500);
                    }
                });
                
                // Auto-hide after 20 seconds
                setTimeout(() => {
                    if (document.body.contains(toast)) {
                        toast.classList.add('fade-out');
                        setTimeout(() => toast.remove(), 500);
                    }
                }, 20000);
                
                // Smart positioning to avoid overlaps with selection and translation popup
                if (state.lastSelectionRect) {
                    // Get necessary rectangles and dimensions
                    const toastRect = toast.getBoundingClientRect();
                    const selRect = state.lastSelectionRect;
                    const viewportHeight = window.innerHeight;
                    const viewportWidth = window.innerWidth;
                    const margin = 10; // Margin to maintain between elements
                    
                    // Check if translation popup is visible first
                    let transRect = null;
                    if (DOM.translationPopup.classList.contains('visible')) {
                        transRect = DOM.translationPopup.getBoundingClientRect();
                    }
                    
                    // Calculate possible positions
                    const positions = {
                        below: {
                            top: selRect.bottom + margin,
                            left: Math.max(viewportWidth - toastRect.width - margin, 
                                  Math.min(selRect.left, viewportWidth - toastRect.width - margin))
                        },
                        above: {
                            top: selRect.top - toastRect.height - margin,
                            left: Math.max(viewportWidth - toastRect.width - margin, 
                                  Math.min(selRect.left, viewportWidth - toastRect.width - margin))
                        },
                        right: {
                            top: Math.min(selRect.top, viewportHeight - toastRect.height - margin),
                            left: Math.max(viewportWidth - toastRect.width - margin, selRect.right + margin)
                        },
                        left: {
                            top: Math.min(selRect.top, viewportHeight - toastRect.height - margin),
                            left: Math.max(viewportWidth - toastRect.width - margin, 
                                  selRect.left - toastRect.width - margin)
                        }
                    };
                    
                    // If translation popup is visible, add position below the translation
                    if (transRect) {
                        positions.belowTranslation = {
                            top: transRect.bottom + margin,
                            left: Math.max(viewportWidth - toastRect.width - margin, 
                                  Math.min(transRect.left, viewportWidth - toastRect.width - margin))
                        };
                    }
                    
                    // Function to check if a position would overlap with an element
                    const wouldOverlap = (pos, rect) => {
                        if (!rect) return false;
                        
                        const posRight = pos.left + toastRect.width;
                        const posBottom = pos.top + toastRect.height;
                        
                        return !(posBottom < rect.top || 
                                 pos.top > rect.bottom || 
                                 posRight < rect.left || 
                                 pos.left > rect.right);
                    };
                    
                    // Function to check if position is on screen
                    const isOnScreen = (pos) => {
                        return pos.top >= 0 && 
                               pos.left >= 0 && 
                               pos.left + toastRect.width <= viewportWidth &&
                               pos.top + toastRect.height <= viewportHeight;
                    };
                    
                    // Try each position in order of preference
                    const positionOrder = transRect ? 
                        ['belowTranslation', 'below', 'right', 'left', 'above'] : 
                        ['below', 'right', 'left', 'above'];
                    
                    let bestPosition = null;
                    
                    for (const posName of positionOrder) {
                        const pos = positions[posName];
                        
                        // Skip if position doesn't exist
                        if (!pos) continue;
                        
                        // Skip positions that would be off-screen
                        if (!isOnScreen(pos)) continue;
                        
                        // Check overlaps
                        const overlapsSelection = wouldOverlap(pos, selRect);
                        const overlapsTranslation = wouldOverlap(pos, transRect);
                        
                        // Perfect position - no overlaps
                        if (!overlapsSelection && !overlapsTranslation) {
                            bestPosition = pos;
                            break;
                        }
                        
                        // If we haven't found any valid position yet, use one that at least
                        // doesn't overlap the translation popup (overlapping selection is less problematic)
                        if (!bestPosition && !overlapsTranslation) {
                            bestPosition = pos;
                        }
                    }
                    
                    // If no good position was found, use a fallback
                    if (!bestPosition) {
                        // Try bottom-right corner of viewport as last resort
                        bestPosition = {
                            top: viewportHeight - toastRect.height - margin,
                            left: viewportWidth - toastRect.width - margin
                        };
                    }
                    
                    // Apply the best position
                    toast.style.top = `${bestPosition.top}px`;
                    toast.style.left = `${bestPosition.left}px`;
                    toast.style.bottom = 'auto';
                    toast.style.right = 'auto';
                }
            }
            
            // Function to speak text aloud
            function speakText(text) {
                // Check if speech synthesis is available
                if ('speechSynthesis' in window) {
                    // Cancel any ongoing speech
                    window.speechSynthesis.cancel();
                    
                    // Create a new speech synthesis utterance
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    // Get language from settings
                    const language = localStorage.getItem('speech-language') || 'en-US';
                    utterance.lang = language;
                    
                    // Try to find a good voice
                    const voices = window.speechSynthesis.getVoices();
                    const languageVoices = voices.filter(voice => voice.lang.startsWith(language.split('-')[0] + '-'));
                    
                    if (languageVoices.length > 0) {
                        // Prefer female voices if available (generally clearer for language learning)
                        const femaleVoice = languageVoices.find(voice => voice.name.includes('female') || voice.name.includes('Female'));
                        utterance.voice = femaleVoice || languageVoices[0];
                    }
                    
                    // Adjust settings for clarity
                    utterance.rate = 0.9; // Slightly slower rate
                    utterance.pitch = 1.0;
                    
                    // Speak the text
                    window.speechSynthesis.speak(utterance);
                } else {
                    console.error('Text-to-speech not supported in this browser');
                    showToast('Text-to-speech not supported in this browser');
                }
            }
            
            // Summarize current chapter using AI
            async function summarizeCurrentChapter() {
                if (!state.userApiSettings) {
                    await checkAuthAndLoadApiSettings();
                    
                    if (!state.userApiSettings) {
                        showToast('Please configure API key in settings to use AI features');
                        return;
                    }
                }
                
                const chapter = state.bookData.chapters[state.bookData.currentPosition];
                if (!chapter) return;
                
                // Show response area and set initial message
                DOM.aiResponseArea.style.display = 'block';
                DOM.aiResponseArea.textContent = 'Generating summary...';
                
                try {
                    // Limit content to avoid token limits
                    const maxContentLength = 15000;
                    const chapterContent = chapter.content.length > maxContentLength 
                        ? chapter.content.substring(0, maxContentLength) + "..." 
                        : chapter.content;
                    
                    const prompt = `Summarize the following text from a book chapter titled "${chapter.title}":\n\n${chapterContent}\n\nProvide a concise summary (about 3-5 sentences) that captures the main points and ideas.`;
                    
                    const response = await geminiRequest(
                        state.userApiSettings.api_key, 
                        prompt, 
                        state.userApiSettings.model
                    );
                    
                    if (response.error) {
                        throw new Error(response.error.message);
                    }
                    
                    const summary = response?.candidates?.[0]?.content?.parts?.[0]?.text || 'Failed to generate summary.';
                    DOM.aiResponseArea.textContent = summary;
                } catch (error) {
                    console.error('Error generating summary:', error);
                    DOM.aiResponseArea.textContent = `Error: ${error.message || 'An error occurred while generating the summary.'}`;
                }
            }
            
            // Save user preferences to Supabase or localStorage
            async function saveUserPreferences() {
                // Build preferences object
                const preferences = {
                    fontSize: state.settings.fontSize,
                    lineHeight: state.settings.lineHeight,
                    theme: state.settings.theme,
                    markdownModeEnabled: state.settings.markdownModeEnabled, // Added Markdown mode
                    translationEnabled: DOM.translationToggle.checked,
                    autoSpeakEnabled: DOM.autoSpeakToggle.checked,
                    speechLanguage: DOM.speechLanguage.value
                };
                
                // Always save to localStorage as fallback
                localStorage.setItem('ebook-font-size', preferences.fontSize);
                localStorage.setItem('ebook-line-height', preferences.lineHeight);
                localStorage.setItem('ebook-theme', preferences.theme);
                localStorage.setItem('markdown-mode-enabled', preferences.markdownModeEnabled); // Added Markdown mode
                localStorage.setItem('translation-enabled', preferences.translationEnabled);
                localStorage.setItem('auto-speak-enabled', preferences.autoSpeakEnabled);
                localStorage.setItem('speech-language', preferences.speechLanguage);
                
                // If user is logged in, save to Supabase
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                
                try {
                    // Get existing user_settings
                    const { data, error } = await supabase
                        .from('user_settings')
                        .select('*')
                        .eq('user_id', session.user.id)
                        .maybeSingle();
                    
                    if (error) throw error;
                    
                    // If no settings exist yet, we can't update
                    if (!data) return;
                    
                    // Update with new preferences (preserving existing fields like api_key)
                    const updatedSettings = {
                        ...data,
                        preferences: preferences
                    };
                    
                    // Save to Supabase
                    const { error: updateError } = await supabase
                        .from('user_settings')
                        .update(updatedSettings)
                        .eq('user_id', session.user.id);
                    
                    if (updateError) throw updateError;
                } catch (error) {
                    console.error('Error saving user preferences:', error);
                }
            }
            
            // Load user preferences from Supabase or localStorage
            async function loadUserPreferences() {
                // Try to load from localStorage first (fallback)
                const fontSizeFromStorage = parseInt(localStorage.getItem('ebook-font-size')) || 100;
                const lineHeightFromStorage = parseFloat(localStorage.getItem('ebook-line-height')) || 1.6;
                const themeFromStorage = localStorage.getItem('ebook-theme') || 'dark';
                
                // Apply localStorage settings immediately
                state.settings.fontSize = fontSizeFromStorage;
                state.settings.lineHeight = lineHeightFromStorage;
                state.settings.theme = themeFromStorage;
                
                // Update UI to reflect settings
                updateFontSize();
                updateLineHeight();
                setTheme(state.settings.theme);
                
                // Load translation toggle state
                if (localStorage.getItem('translation-enabled') === 'false') {
                    DOM.translationToggle.checked = false;
                } else {
                    DOM.translationToggle.checked = true;
                }
                
                // Load auto-speak toggle state
                if (localStorage.getItem('auto-speak-enabled') === 'false') {
                    DOM.autoSpeakToggle.checked = false;
                } else {
                    DOM.autoSpeakToggle.checked = true;
                }
                
                // Load speech language setting
                const speechLanguage = localStorage.getItem('speech-language') || 'en-US';
                DOM.speechLanguage.value = speechLanguage;

                // Load Markdown mode setting
                const markdownModeEnabled = localStorage.getItem('markdown-mode-enabled') === 'true';
                state.settings.markdownModeEnabled = markdownModeEnabled;
                DOM.markdownModeToggle.checked = markdownModeEnabled;
                
                // Check if user is logged in to load server settings
                const { data: { session } } = await supabase.auth.getSession();
                if (!session) return;
                
                try {
                    // Try to load from Supabase
                    const { data, error } = await supabase
                        .from('user_settings')
                        .select('preferences')
                        .eq('user_id', session.user.id)
                        .maybeSingle();
                    
                    if (error || !data || !data.preferences) return;
                    
                    const prefs = data.preferences;
                    
                    // Apply font size from server
                    if (prefs.fontSize) {
                        state.settings.fontSize = prefs.fontSize;
                        updateFontSize();
                    }
                    
                    // Apply line height from server
                    if (prefs.lineHeight) {
                        state.settings.lineHeight = prefs.lineHeight;
                        updateLineHeight();
                    }
                    
                    // Apply theme from server
                    if (prefs.theme) {
                        setTheme(prefs.theme);
                    }
                    
                    // Apply translation toggle
                    if (prefs.translationEnabled !== undefined) {
                        DOM.translationToggle.checked = prefs.translationEnabled;
                        localStorage.setItem('translation-enabled', prefs.translationEnabled);
                    }
                    
                    // Apply auto speak toggle
                    if (prefs.autoSpeakEnabled !== undefined) {
                        DOM.autoSpeakToggle.checked = prefs.autoSpeakEnabled;
                        localStorage.setItem('auto-speak-enabled', prefs.autoSpeakEnabled);
                    }
                    
                    // Apply speech language
                    if (prefs.speechLanguage) {
                        DOM.speechLanguage.value = prefs.speechLanguage;
                        localStorage.setItem('speech-language', prefs.speechLanguage);
                    }

                    // Apply Markdown mode
                    if (prefs.markdownModeEnabled !== undefined) {
                        state.settings.markdownModeEnabled = prefs.markdownModeEnabled;
                        DOM.markdownModeToggle.checked = prefs.markdownModeEnabled;
                        localStorage.setItem('markdown-mode-enabled', prefs.markdownModeEnabled);
                    }
                } catch (error) {
                    console.error('Error loading user preferences:', error);
                }
            }
            
            // Return public API
            return {
                init
            };
        })();
        
        // Initialize the app when DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            EbookApp.init();
        });

        // Calculate overall reading progress for a book
        function calculateOverallProgress(book) {
            if (!book.last_position) return 0;
            
            // If we have chapters, calculate based on chapter position and chapter progress
            if (book.metadata && book.metadata.chapters && book.metadata.chapters.length > 0) {
                const chaptersLength = book.metadata.chapters.length;
                const currentChapter = book.last_position.chapter || 0;
                const chapterProgress = book.last_position.percentComplete || 0;
                
                // Same formula as in updateProgressBar
                const chaptersProgress = currentChapter / Math.max(1, chaptersLength - 1);
                const weightedChapterProgress = chapterProgress / chaptersLength;
                return Math.round((chaptersProgress + weightedChapterProgress) * 100);
            }
            
            // If we don't have chapters, just use the percentComplete
            return Math.round((book.last_position.percentComplete || 0) * 100);
        }
    </script>
</body>
</html>
